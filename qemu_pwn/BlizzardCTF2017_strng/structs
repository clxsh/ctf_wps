struct __va_list_tag {
	unsigned int               gp_offset;            /*     0     4 */
	unsigned int               fp_offset;            /*     4     4 */
	void *                     overflow_arg_area;    /*     8     8 */
	void *                     reg_save_area;        /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct __pthread_internal_list {
	struct __pthread_internal_list * __prev;         /*     0     8 */
	struct __pthread_internal_list * __next;         /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct __pthread_mutex_s {
	int                        __lock;               /*     0     4 */
	unsigned int               __count;              /*     4     4 */
	int                        __owner;              /*     8     4 */
	unsigned int               __nusers;             /*    12     4 */
	int                        __kind;               /*    16     4 */
	short int                  __spins;              /*    20     2 */
	short int                  __elision;            /*    22     2 */
	__pthread_list_t           __list;               /*    24    16 */

	/* size: 40, cachelines: 1, members: 8 */
	/* last cacheline: 40 bytes */
};
struct _IO_FILE {
	int                        _flags;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     _IO_read_ptr;         /*     8     8 */
	char *                     _IO_read_end;         /*    16     8 */
	char *                     _IO_read_base;        /*    24     8 */
	char *                     _IO_write_base;       /*    32     8 */
	char *                     _IO_write_ptr;        /*    40     8 */
	char *                     _IO_write_end;        /*    48     8 */
	char *                     _IO_buf_base;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     _IO_buf_end;          /*    64     8 */
	char *                     _IO_save_base;        /*    72     8 */
	char *                     _IO_backup_base;      /*    80     8 */
	char *                     _IO_save_end;         /*    88     8 */
	struct _IO_marker *        _markers;             /*    96     8 */
	struct _IO_FILE *          _chain;               /*   104     8 */
	int                        _fileno;              /*   112     4 */
	int                        _flags2;              /*   116     4 */
	__off_t                    _old_offset;          /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	short unsigned int         _cur_column;          /*   128     2 */
	signed char                _vtable_offset;       /*   130     1 */
	char                       _shortbuf[1];         /*   131     1 */

	/* XXX 4 bytes hole, try to pack */

	_IO_lock_t *               _lock;                /*   136     8 */
	__off64_t                  _offset;              /*   144     8 */
	void *                     __pad1;               /*   152     8 */
	void *                     __pad2;               /*   160     8 */
	void *                     __pad3;               /*   168     8 */
	void *                     __pad4;               /*   176     8 */
	size_t                     __pad5;               /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        _mode;                /*   192     4 */
	char                       _unused2[20];         /*   196    20 */

	/* size: 216, cachelines: 4, members: 29 */
	/* sum members: 208, holes: 2, sum holes: 8 */
	/* last cacheline: 24 bytes */
};
struct _IO_marker {
	struct _IO_marker *        _next;                /*     0     8 */
	struct _IO_FILE *          _sbuf;                /*     8     8 */
	int                        _pos;                 /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct __jmp_buf_tag {
	__jmp_buf                  __jmpbuf;             /*     0    64 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        __mask_was_saved;     /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	__sigset_t                 __saved_mask;         /*    72   128 */

	/* size: 200, cachelines: 4, members: 3 */
	/* sum members: 196, holes: 1, sum holes: 4 */
	/* last cacheline: 8 bytes */
};
struct _GSList {
	gpointer                   data;                 /*     0     8 */
	GSList *                   next;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct AddressSpace {
	struct rcu_head            rcu;                  /*     0    16 */
	char *                     name;                 /*    16     8 */
	MemoryRegion *             root;                 /*    24     8 */
	int                        ref_count;            /*    32     4 */
	_Bool                      malloced;             /*    36     1 */

	/* XXX 3 bytes hole, try to pack */

	struct FlatView *          current_map;          /*    40     8 */
	int                        ioeventfd_nb;         /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	struct MemoryRegionIoeventfd * ioeventfds;       /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	struct AddressSpaceDispatch * dispatch;          /*    64     8 */
	struct AddressSpaceDispatch * next_dispatch;     /*    72     8 */
	MemoryListener             dispatch_listener;    /*    80   160 */
	/* --- cacheline 3 boundary (192 bytes) was 48 bytes ago --- */
	struct memory_listeners_as listeners;            /*   240    16 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	struct {
		struct AddressSpace * tqe_next;          /*   256     8 */
		struct AddressSpace * * tqe_prev;        /*   264     8 */
	} address_spaces_link;                           /*   256    16 */

	/* size: 272, cachelines: 5, members: 13 */
	/* sum members: 265, holes: 2, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct BusState {
	Object                     obj;                  /*     0    40 */
	DeviceState *              parent;               /*    40     8 */
	char *                     name;                 /*    48     8 */
	HotplugHandler *           hotplug_handler;      /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        max_index;            /*    64     4 */
	_Bool                      realized;             /*    68     1 */

	/* XXX 3 bytes hole, try to pack */

	struct ChildrenHead        children;             /*    72    16 */
	struct {
		struct BusState *  le_next;              /*    88     8 */
		struct BusState * * le_prev;             /*    96     8 */
	} sibling;                                       /*    88    16 */

	/* size: 104, cachelines: 2, members: 8 */
	/* sum members: 101, holes: 1, sum holes: 3 */
	/* last cacheline: 40 bytes */
};
struct CPUAddressSpace {
	CPUState *                 cpu;                  /*     0     8 */
	AddressSpace *             as;                   /*     8     8 */
	struct AddressSpaceDispatch * memory_dispatch;   /*    16     8 */
	MemoryListener             tcg_as_listener;      /*    24   160 */

	/* size: 184, cachelines: 3, members: 4 */
	/* last cacheline: 56 bytes */
};
struct CPUState {
	DeviceState                parent_obj;           /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	int                        nr_cores;             /*   112     4 */
	int                        nr_threads;           /*   116     4 */
	int                        numa_node;            /*   120     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 2 boundary (128 bytes) --- */
	struct QemuThread *        thread;               /*   128     8 */
	int                        thread_id;            /*   136     4 */
	uint32_t                   host_tid;             /*   140     4 */
	_Bool                      running;              /*   144     1 */
	_Bool                      has_waiter;           /*   145     1 */

	/* XXX 6 bytes hole, try to pack */

	struct QemuCond *          halt_cond;            /*   152     8 */
	_Bool                      thread_kicked;        /*   160     1 */
	_Bool                      created;              /*   161     1 */
	_Bool                      stop;                 /*   162     1 */
	_Bool                      stopped;              /*   163     1 */
	_Bool                      unplug;               /*   164     1 */
	_Bool                      crash_occurred;       /*   165     1 */
	_Bool                      exit_request;         /*   166     1 */

	/* XXX 1 byte hole, try to pack */

	uint32_t                   interrupt_request;    /*   168     4 */
	int                        singlestep_enabled;   /*   172     4 */
	int64_t                    icount_extra;         /*   176     8 */
	sigjmp_buf                 jmp_env;              /*   184   200 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	QemuMutex                  work_mutex;           /*   384    40 */
	struct qemu_work_item *    queued_work_first;    /*   424     8 */
	struct qemu_work_item *    queued_work_last;     /*   432     8 */
	CPUAddressSpace *          cpu_ases;             /*   440     8 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	int                        num_ases;             /*   448     4 */

	/* XXX 4 bytes hole, try to pack */

	AddressSpace *             as;                   /*   456     8 */
	MemoryRegion *             memory;               /*   464     8 */
	void *                     env_ptr;              /*   472     8 */
	struct TranslationBlock *  tb_jmp_cache[4096];   /*   480 32768 */
	/* --- cacheline 519 boundary (33216 bytes) was 32 bytes ago --- */
	struct GDBRegisterState *  gdb_regs;             /* 33248     8 */
	int                        gdb_num_regs;         /* 33256     4 */
	int                        gdb_num_g_regs;       /* 33260     4 */
	struct {
		struct CPUState *  tqe_next;             /* 33264     8 */
		struct CPUState * * tqe_prev;            /* 33272     8 */
	} node;                                          /* 33264    16 */
	/* --- cacheline 520 boundary (33280 bytes) --- */
	struct breakpoints_head    breakpoints;          /* 33280    16 */
	struct watchpoints_head    watchpoints;          /* 33296    16 */
	CPUWatchpoint *            watchpoint_hit;       /* 33312     8 */
	void *                     opaque;               /* 33320     8 */
	uintptr_t                  mem_io_pc;            /* 33328     8 */
	vaddr                      mem_io_vaddr;         /* 33336     8 */
	/* --- cacheline 521 boundary (33344 bytes) --- */
	int                        kvm_fd;               /* 33344     4 */
	_Bool                      kvm_vcpu_dirty;       /* 33348     1 */

	/* XXX 3 bytes hole, try to pack */

	struct KVMState *          kvm_state;            /* 33352     8 */
	struct kvm_run *           kvm_run;              /* 33360     8 */
	long unsigned int *        trace_dstate;         /* 33368     8 */
	int                        cpu_index;            /* 33376     4 */
	uint32_t                   halted;               /* 33380     4 */
	union {
		uint32_t           u32;                  /* 33384     4 */
		icount_decr_u16    u16;                  /* 33384     4 */
	} icount_decr;                                   /* 33384     4 */
	uint32_t                   can_do_io;            /* 33388     4 */
	int32_t                    exception_index;      /* 33392     4 */
	_Bool                      throttle_thread_scheduled; /* 33396     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   tcg_exit_req;         /* 33400     4 */

	/* size: 33408, cachelines: 522, members: 52 */
	/* sum members: 33383, holes: 6, sum holes: 21 */
	/* padding: 4 */
};
struct DeviceState {
	Object                     parent_obj;           /*     0    40 */
	const char  *              id;                   /*    40     8 */
	_Bool                      realized;             /*    48     1 */
	_Bool                      pending_deleted_event; /*    49     1 */

	/* XXX 6 bytes hole, try to pack */

	QemuOpts *                 opts;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        hotplugged;           /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	BusState *                 parent_bus;           /*    72     8 */
	struct {
		struct NamedGPIOList * lh_first;         /*    80     8 */
	} gpios;                                         /*    80     8 */
	struct {
		struct BusState *  lh_first;             /*    88     8 */
	} child_bus;                                     /*    88     8 */
	int                        num_child_bus;        /*    96     4 */
	int                        instance_id_alias;    /*   100     4 */
	int                        alias_required_for_version; /*   104     4 */

	/* size: 112, cachelines: 2, members: 12 */
	/* sum members: 98, holes: 2, sum holes: 10 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct EventNotifier {
	int                        rfd;                  /*     0     4 */
	int                        wfd;                  /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct MachineState {
	Object                     parent_obj;           /*     0    40 */
	Notifier                   sysbus_notifier;      /*    40    24 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     accel;                /*    64     8 */
	_Bool                      kernel_irqchip_allowed; /*    72     1 */
	_Bool                      kernel_irqchip_required; /*    73     1 */
	_Bool                      kernel_irqchip_split; /*    74     1 */

	/* XXX 1 byte hole, try to pack */

	int                        kvm_shadow_mem;       /*    76     4 */
	char *                     dtb;                  /*    80     8 */
	char *                     dumpdtb;              /*    88     8 */
	int                        phandle_start;        /*    96     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     dt_compatible;        /*   104     8 */
	_Bool                      dump_guest_core;      /*   112     1 */
	_Bool                      mem_merge;            /*   113     1 */
	_Bool                      usb;                  /*   114     1 */
	_Bool                      usb_disabled;         /*   115     1 */
	_Bool                      igd_gfx_passthru;     /*   116     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     firmware;             /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	_Bool                      iommu;                /*   128     1 */
	_Bool                      suppress_vmdesc;      /*   129     1 */
	_Bool                      enforce_config_section; /*   130     1 */
	_Bool                      enable_graphics;      /*   131     1 */

	/* XXX 4 bytes hole, try to pack */

	ram_addr_t                 ram_size;             /*   136     8 */
	ram_addr_t                 maxram_size;          /*   144     8 */
	uint64_t                   ram_slots;            /*   152     8 */
	const char  *              boot_order;           /*   160     8 */
	char *                     kernel_filename;      /*   168     8 */
	char *                     kernel_cmdline;       /*   176     8 */
	char *                     initrd_filename;      /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	const char  *              cpu_model;            /*   192     8 */
	AccelState *               accelerator;          /*   200     8 */

	/* size: 208, cachelines: 4, members: 30 */
	/* sum members: 196, holes: 4, sum holes: 12 */
	/* last cacheline: 16 bytes */
};
struct MemoryListener {
	void                       (*begin)(MemoryListener *); /*     0     8 */
	void                       (*commit)(MemoryListener *); /*     8     8 */
	void                       (*region_add)(MemoryListener *, MemoryRegionSection *); /*    16     8 */
	void                       (*region_del)(MemoryListener *, MemoryRegionSection *); /*    24     8 */
	void                       (*region_nop)(MemoryListener *, MemoryRegionSection *); /*    32     8 */
	void                       (*log_start)(MemoryListener *, MemoryRegionSection *, int, int); /*    40     8 */
	void                       (*log_stop)(MemoryListener *, MemoryRegionSection *, int, int); /*    48     8 */
	void                       (*log_sync)(MemoryListener *, MemoryRegionSection *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*log_global_start)(MemoryListener *); /*    64     8 */
	void                       (*log_global_stop)(MemoryListener *); /*    72     8 */
	void                       (*eventfd_add)(MemoryListener *, MemoryRegionSection *, _Bool, uint64_t, EventNotifier *); /*    80     8 */
	void                       (*eventfd_del)(MemoryListener *, MemoryRegionSection *, _Bool, uint64_t, EventNotifier *); /*    88     8 */
	void                       (*coalesced_mmio_add)(MemoryListener *, MemoryRegionSection *, hwaddr, hwaddr); /*    96     8 */
	void                       (*coalesced_mmio_del)(MemoryListener *, MemoryRegionSection *, hwaddr, hwaddr); /*   104     8 */
	unsigned int               priority;             /*   112     4 */

	/* XXX 4 bytes hole, try to pack */

	AddressSpace *             address_space;        /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	struct {
		struct MemoryListener * tqe_next;        /*   128     8 */
		struct MemoryListener * * tqe_prev;      /*   136     8 */
	} link;                                          /*   128    16 */
	struct {
		struct MemoryListener * tqe_next;        /*   144     8 */
		struct MemoryListener * * tqe_prev;      /*   152     8 */
	} link_as;                                       /*   144    16 */

	/* size: 160, cachelines: 3, members: 18 */
	/* sum members: 156, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct MemoryRegion {
	Object                     parent_obj;           /*     0    40 */
	_Bool                      romd_mode;            /*    40     1 */
	_Bool                      ram;                  /*    41     1 */
	_Bool                      subpage;              /*    42     1 */
	_Bool                      readonly;             /*    43     1 */
	_Bool                      rom_device;           /*    44     1 */
	_Bool                      flush_coalesced_mmio; /*    45     1 */
	_Bool                      global_locking;       /*    46     1 */
	uint8_t                    dirty_log_mask;       /*    47     1 */
	RAMBlock *                 ram_block;            /*    48     8 */
	Object *                   owner;                /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	const MemoryRegionIOMMUOps  * iommu_ops;         /*    64     8 */
	const MemoryRegionOps  *   ops;                  /*    72     8 */
	void *                     opaque;               /*    80     8 */
	MemoryRegion *             container;            /*    88     8 */
	Int128                     size;                 /*    96    16 */
	hwaddr                     addr;                 /*   112     8 */
	void                       (*destructor)(MemoryRegion *); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint64_t                   align;                /*   128     8 */
	_Bool                      terminates;           /*   136     1 */
	_Bool                      ram_device;           /*   137     1 */
	_Bool                      enabled;              /*   138     1 */
	_Bool                      warning_printed;      /*   139     1 */
	uint8_t                    vga_logging_count;    /*   140     1 */

	/* XXX 3 bytes hole, try to pack */

	MemoryRegion *             alias;                /*   144     8 */
	hwaddr                     alias_offset;         /*   152     8 */
	int32_t                    priority;             /*   160     4 */

	/* XXX 4 bytes hole, try to pack */

	struct subregions          subregions;           /*   168    16 */
	struct {
		struct MemoryRegion * tqe_next;          /*   184     8 */
		/* --- cacheline 3 boundary (192 bytes) --- */
		struct MemoryRegion * * tqe_prev;        /*   192     8 */
	} subregions_link;                               /*   184    16 */
	struct coalesced_ranges    coalesced;            /*   200    16 */
	const char  *              name;                 /*   216     8 */
	unsigned int               ioeventfd_nb;         /*   224     4 */

	/* XXX 4 bytes hole, try to pack */

	MemoryRegionIoeventfd *    ioeventfds;           /*   232     8 */
	struct {
		struct IOMMUNotifier * lh_first;         /*   240     8 */
	} iommu_notify;                                  /*   240     8 */
	IOMMUNotifierFlag          iommu_notify_flags;   /*   248     4 */

	/* size: 256, cachelines: 4, members: 35 */
	/* sum members: 241, holes: 3, sum holes: 11 */
	/* padding: 4 */
};
struct MemoryRegionSection {
	MemoryRegion *             mr;                   /*     0     8 */
	AddressSpace *             address_space;        /*     8     8 */
	hwaddr                     offset_within_region; /*    16     8 */

	/* XXX 8 bytes hole, try to pack */

	Int128                     size;                 /*    32    16 */
	hwaddr                     offset_within_address_space; /*    48     8 */
	_Bool                      readonly;             /*    56     1 */

	/* size: 64, cachelines: 1, members: 6 */
	/* sum members: 49, holes: 1, sum holes: 8 */
	/* padding: 7 */
};
struct Property {
	const char  *              name;                 /*     0     8 */
	PropertyInfo *             info;                 /*     8     8 */
	ptrdiff_t                  offset;               /*    16     8 */
	uint8_t                    bitnr;                /*    24     1 */

	/* XXX 3 bytes hole, try to pack */

	QType                      qtype;                /*    28     4 */
	int64_t                    defval;               /*    32     8 */
	int                        arrayoffset;          /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	PropertyInfo *             arrayinfo;            /*    48     8 */
	int                        arrayfieldsize;       /*    56     4 */

	/* size: 64, cachelines: 1, members: 9 */
	/* sum members: 53, holes: 2, sum holes: 7 */
	/* padding: 4 */
};
struct PropertyInfo {
	const char  *              name;                 /*     0     8 */
	const char  *              description;          /*     8     8 */
	const char  * const *      enum_table;           /*    16     8 */
	int                        (*print)(DeviceState *, Property *, char *, size_t); /*    24     8 */
	ObjectPropertyAccessor *   get;                  /*    32     8 */
	ObjectPropertyAccessor *   set;                  /*    40     8 */
	ObjectPropertyRelease *    release;              /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* last cacheline: 56 bytes */
};
struct QEMUTimerListGroup {
	QEMUTimerList *            tl[4];                /*     0    32 */

	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */
};
struct QObject {
	QType                      type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     refcnt;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct RAMBlock {
	struct rcu_head            rcu;                  /*     0    16 */
	struct MemoryRegion *      mr;                   /*    16     8 */
	uint8_t *                  host;                 /*    24     8 */
	ram_addr_t                 offset;               /*    32     8 */
	ram_addr_t                 used_length;          /*    40     8 */
	ram_addr_t                 max_length;           /*    48     8 */
	void                       (*resized)(const char  *, uint64_t, void *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint32_t                   flags;                /*    64     4 */
	char                       idstr[256];           /*    68   256 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	struct {
		struct RAMBlock *  le_next;              /*   328     8 */
		struct RAMBlock * * le_prev;             /*   336     8 */
	} next;                                          /*   328    16 */
	int                        fd;                   /*   344     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     page_size;            /*   352     8 */

	/* size: 360, cachelines: 6, members: 12 */
	/* sum members: 352, holes: 2, sum holes: 8 */
	/* last cacheline: 40 bytes */
};
struct float_status {
	signed char                float_detect_tininess; /*     0     1 */
	signed char                float_rounding_mode;  /*     1     1 */
	uint8_t                    float_exception_flags; /*     2     1 */
	signed char                floatx80_rounding_precision; /*     3     1 */
	flag                       flush_to_zero;        /*     4     1 */
	flag                       flush_inputs_to_zero; /*     5     1 */
	flag                       default_nan_mode;     /*     6     1 */
	flag                       snan_bit_is_one;      /*     7     1 */

	/* size: 8, cachelines: 1, members: 8 */
	/* last cacheline: 8 bytes */
};
struct ObjectClass {
	Type                       type;                 /*     0     8 */
	GSList *                   interfaces;           /*     8     8 */
	const char  *              object_cast_cache[4]; /*    16    32 */
	const char  *              class_cast_cache[4];  /*    48    32 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	ObjectUnparent *           unparent;             /*    80     8 */
	GHashTable *               properties;           /*    88     8 */

	/* size: 96, cachelines: 2, members: 6 */
	/* last cacheline: 32 bytes */
};
struct Object {
	ObjectClass *              class;                /*     0     8 */
	ObjectFree *               free;                 /*     8     8 */
	GHashTable *               properties;           /*    16     8 */
	uint32_t                   ref;                  /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	Object *                   parent;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct HotplugHandler {
	Object                     Parent;               /*     0    40 */

	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
struct DeviceClass {
	ObjectClass                parent_class;         /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	long unsigned int          categories[1];        /*    96     8 */
	const char  *              fw_name;              /*   104     8 */
	const char  *              desc;                 /*   112     8 */
	Property *                 props;                /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	_Bool                      cannot_instantiate_with_device_add_yet; /*   128     1 */
	_Bool                      cannot_destroy_with_object_finalize_yet; /*   129     1 */
	_Bool                      hotpluggable;         /*   130     1 */

	/* XXX 5 bytes hole, try to pack */

	void                       (*reset)(DeviceState *); /*   136     8 */
	DeviceRealize              realize;              /*   144     8 */
	DeviceUnrealize            unrealize;            /*   152     8 */
	const struct VMStateDescription  * vmsd;         /*   160     8 */
	qdev_initfn                init;                 /*   168     8 */
	qdev_event                 exit;                 /*   176     8 */
	const char  *              bus_type;             /*   184     8 */

	/* size: 192, cachelines: 3, members: 15 */
	/* sum members: 187, holes: 1, sum holes: 5 */
};
struct VMStateDescription {
	const char  *              name;                 /*     0     8 */
	int                        unmigratable;         /*     8     4 */
	int                        version_id;           /*    12     4 */
	int                        minimum_version_id;   /*    16     4 */
	int                        minimum_version_id_old; /*    20     4 */
	LoadStateHandler *         load_state_old;       /*    24     8 */
	int                        (*pre_load)(void *);  /*    32     8 */
	int                        (*post_load)(void *, int); /*    40     8 */
	void                       (*pre_save)(void *);  /*    48     8 */
	_Bool                      (*needed)(void *);    /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	VMStateField *             fields;               /*    64     8 */
	const VMStateDescription  * * subsections;       /*    72     8 */

	/* size: 80, cachelines: 2, members: 12 */
	/* last cacheline: 16 bytes */
};
struct NamedGPIOList {
	char *                     name;                 /*     0     8 */
	qemu_irq *                 in;                   /*     8     8 */
	int                        num_in;               /*    16     4 */
	int                        num_out;              /*    20     4 */
	struct {
		struct NamedGPIOList * le_next;          /*    24     8 */
		struct NamedGPIOList * * le_prev;        /*    32     8 */
	} node;                                          /*    24    16 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct BusChild {
	DeviceState *              child;                /*     0     8 */
	int                        index;                /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct BusChild *  tqe_next;             /*    16     8 */
		struct BusChild * * tqe_prev;            /*    24     8 */
	} sibling;                                       /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct ChildrenHead {
	struct BusChild *          tqh_first;            /*     0     8 */
	struct BusChild * *        tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct symbol_cache_entry {
	const char  *              name;                 /*     0     8 */
	union {
		PTR                p;                    /*     8     8 */
		bfd_vma            i;                    /*     8     8 */
	} udata;                                         /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct disassemble_info {
	fprintf_function           fprintf_func;         /*     0     8 */
	FILE *                     stream;               /*     8     8 */
	PTR                        application_data;     /*    16     8 */
	enum bfd_flavour           flavour;              /*    24     4 */
	enum bfd_architecture      arch;                 /*    28     4 */
	long unsigned int          mach;                 /*    32     8 */
	enum bfd_endian            endian;               /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	asymbol * *                symbols;              /*    48     8 */
	int                        num_symbols;          /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	long unsigned int          flags;                /*    64     8 */
	PTR                        private_data;         /*    72     8 */
	int                        (*read_memory_func)(bfd_vma, bfd_byte *, int, struct disassemble_info *); /*    80     8 */
	void                       (*memory_error_func)(int, bfd_vma, struct disassemble_info *); /*    88     8 */
	void                       (*print_address_func)(bfd_vma, struct disassemble_info *); /*    96     8 */
	int                        (*print_insn)(bfd_vma, struct disassemble_info *); /*   104     8 */
	int                        (*symbol_at_address_func)(bfd_vma, struct disassemble_info *); /*   112     8 */
	bfd_byte *                 buffer;               /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	bfd_vma                    buffer_vma;           /*   128     8 */
	int                        buffer_length;        /*   136     4 */
	int                        bytes_per_line;       /*   140     4 */
	int                        bytes_per_chunk;      /*   144     4 */
	enum bfd_endian            display_endian;       /*   148     4 */
	char                       insn_info_valid;      /*   152     1 */
	char                       branch_delay_insns;   /*   153     1 */
	char                       data_size;            /*   154     1 */

	/* XXX 1 byte hole, try to pack */

	enum dis_insn_type         insn_type;            /*   156     4 */
	bfd_vma                    target;               /*   160     8 */
	bfd_vma                    target2;              /*   168     8 */
	char *                     disassembler_options; /*   176     8 */

	/* size: 184, cachelines: 3, members: 29 */
	/* sum members: 175, holes: 3, sum holes: 9 */
	/* last cacheline: 56 bytes */
};
struct MemTxAttrs {
	unsigned int               unspecified:1;        /*     0: 0  4 */
	unsigned int               secure:1;             /*     0: 1  4 */
	unsigned int               user:1;               /*     0: 2  4 */
	unsigned int               requester_id:16;      /*     0: 3  4 */

	/* size: 4, cachelines: 1, members: 4 */
	/* bit_padding: 13 bits */
	/* last cacheline: 4 bytes */
};
struct QemuMutex {
	pthread_mutex_t            lock;                 /*     0    40 */

	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
struct QemuCond {
	pthread_cond_t             cond;                 /*     0    48 */

	/* size: 48, cachelines: 1, members: 1 */
	/* last cacheline: 48 bytes */
};
struct QemuEvent {
	unsigned int               value;                /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct QemuThread {
	pthread_t                  thread;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct CPUWatchpoint {
	vaddr                      vaddr;                /*     0     8 */
	vaddr                      len;                  /*     8     8 */
	vaddr                      hitaddr;              /*    16     8 */
	MemTxAttrs                 hitattrs;             /*    24     4 */
	int                        flags;                /*    28     4 */
	struct {
		struct CPUWatchpoint * tqe_next;         /*    32     8 */
		struct CPUWatchpoint * * tqe_prev;       /*    40     8 */
	} entry;                                         /*    32    16 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct CPUClass {
	DeviceClass                parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	ObjectClass *              (*class_by_name)(const char  *); /*   192     8 */
	void                       (*parse_features)(const char  *, char *, Error * *); /*   200     8 */
	void                       (*reset)(CPUState *); /*   208     8 */
	int                        reset_dump_flags;     /*   216     4 */

	/* XXX 4 bytes hole, try to pack */

	_Bool                      (*has_work)(CPUState *); /*   224     8 */
	void                       (*do_interrupt)(CPUState *); /*   232     8 */
	CPUUnassignedAccess        do_unassigned_access; /*   240     8 */
	void                       (*do_unaligned_access)(CPUState *, vaddr, MMUAccessType, int, uintptr_t); /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	_Bool                      (*virtio_is_big_endian)(CPUState *); /*   256     8 */
	int                        (*memory_rw_debug)(CPUState *, vaddr, uint8_t *, int, _Bool); /*   264     8 */
	void                       (*dump_state)(CPUState *, FILE *, fprintf_function, int); /*   272     8 */
	void                       (*dump_statistics)(CPUState *, FILE *, fprintf_function, int); /*   280     8 */
	int64_t                    (*get_arch_id)(CPUState *); /*   288     8 */
	_Bool                      (*get_paging_enabled)(const CPUState  *); /*   296     8 */
	void                       (*get_memory_mapping)(CPUState *, MemoryMappingList *, Error * *); /*   304     8 */
	void                       (*set_pc)(CPUState *, vaddr); /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	void                       (*synchronize_from_tb)(CPUState *, struct TranslationBlock *); /*   320     8 */
	int                        (*handle_mmu_fault)(CPUState *, vaddr, int, int); /*   328     8 */
	hwaddr                     (*get_phys_page_debug)(CPUState *, vaddr); /*   336     8 */
	hwaddr                     (*get_phys_page_attrs_debug)(CPUState *, vaddr, MemTxAttrs *); /*   344     8 */
	int                        (*asidx_from_attrs)(CPUState *, MemTxAttrs); /*   352     8 */
	int                        (*gdb_read_register)(CPUState *, uint8_t *, int); /*   360     8 */
	int                        (*gdb_write_register)(CPUState *, uint8_t *, int); /*   368     8 */
	_Bool                      (*debug_check_watchpoint)(CPUState *, CPUWatchpoint *); /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	void                       (*debug_excp_handler)(CPUState *); /*   384     8 */
	int                        (*write_elf64_note)(WriteCoreDumpFunction, CPUState *, int, void *); /*   392     8 */
	int                        (*write_elf64_qemunote)(WriteCoreDumpFunction, CPUState *, void *); /*   400     8 */
	int                        (*write_elf32_note)(WriteCoreDumpFunction, CPUState *, int, void *); /*   408     8 */
	int                        (*write_elf32_qemunote)(WriteCoreDumpFunction, CPUState *, void *); /*   416     8 */
	const struct VMStateDescription  * vmsd;         /*   424     8 */
	int                        gdb_num_core_regs;    /*   432     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              gdb_core_xml_file;    /*   440     8 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	gchar *                    (*gdb_arch_name)(CPUState *); /*   448     8 */
	_Bool                      gdb_stop_before_watchpoint; /*   456     1 */

	/* XXX 7 bytes hole, try to pack */

	void                       (*cpu_exec_enter)(CPUState *); /*   464     8 */
	void                       (*cpu_exec_exit)(CPUState *); /*   472     8 */
	_Bool                      (*cpu_exec_interrupt)(CPUState *, int); /*   480     8 */
	void                       (*disas_set_info)(CPUState *, disassemble_info *); /*   488     8 */

	/* size: 496, cachelines: 8, members: 39 */
	/* sum members: 481, holes: 3, sum holes: 15 */
	/* last cacheline: 48 bytes */
};
struct TranslationBlock {
	target_ulong               pc;                   /*     0     8 */
	target_ulong               cs_base;              /*     8     8 */
	uint32_t                   flags;                /*    16     4 */
	uint16_t                   size;                 /*    20     2 */
	uint16_t                   icount;               /*    22     2 */
	uint32_t                   cflags;               /*    24     4 */
	uint16_t                   invalid;              /*    28     2 */

	/* XXX 2 bytes hole, try to pack */

	void *                     tc_ptr;               /*    32     8 */
	uint8_t *                  tc_search;            /*    40     8 */
	struct TranslationBlock *  orig_tb;              /*    48     8 */
	struct TranslationBlock *  page_next[2];         /*    56    16 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	tb_page_addr_t             page_addr[2];         /*    72    16 */
	uint16_t                   jmp_reset_offset[2];  /*    88     4 */
	uint16_t                   jmp_insn_offset[2];   /*    92     4 */
	uintptr_t                  jmp_list_next[2];     /*    96    16 */
	uintptr_t                  jmp_list_first;       /*   112     8 */

	/* size: 120, cachelines: 2, members: 16 */
	/* sum members: 118, holes: 1, sum holes: 2 */
	/* last cacheline: 56 bytes */
};
struct icount_decr_u16 {
	uint16_t                   low;                  /*     0     2 */
	uint16_t                   high;                 /*     2     2 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
struct CPUBreakpoint {
	vaddr                      pc;                   /*     0     8 */
	int                        flags;                /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct CPUBreakpoint * tqe_next;         /*    16     8 */
		struct CPUBreakpoint * * tqe_prev;       /*    24     8 */
	} entry;                                         /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct breakpoints_head {
	struct CPUBreakpoint *     tqh_first;            /*     0     8 */
	struct CPUBreakpoint * *   tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct watchpoints_head {
	struct CPUWatchpoint *     tqh_first;            /*     0     8 */
	struct CPUWatchpoint * *   tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct kvm_run {
	__u8                       request_interrupt_window; /*     0     1 */
	__u8                       padding1[7];          /*     1     7 */
	__u32                      exit_reason;          /*     8     4 */
	__u8                       ready_for_interrupt_injection; /*    12     1 */
	__u8                       if_flag;              /*    13     1 */
	__u16                      flags;                /*    14     2 */
	__u64                      cr8;                  /*    16     8 */
	__u64                      apic_base;            /*    24     8 */
	union {
		struct {
			__u64      hardware_exit_reason; /*    32     8 */
		} hw;                                    /*    32     8 */
		struct {
			__u64      hardware_entry_failure_reason; /*    32     8 */
		} fail_entry;                            /*    32     8 */
		struct {
			__u32      exception;            /*    32     4 */
			__u32      error_code;           /*    36     4 */
		} ex;                                    /*    32     8 */
		struct {
			__u8       direction;            /*    32     1 */
			__u8       size;                 /*    33     1 */
			__u16      port;                 /*    34     2 */
			__u32      count;                /*    36     4 */
			__u64      data_offset;          /*    40     8 */
		} io;                                    /*    32    16 */
		struct {
			struct kvm_debug_exit_arch arch; /*    32    32 */
		} debug;                                 /*    32    32 */
		struct {
			__u64      phys_addr;            /*    32     8 */
			__u8       data[8];              /*    40     8 */
			__u32      len;                  /*    48     4 */
			__u8       is_write;             /*    52     1 */
		} mmio;                                  /*    32    24 */
		struct {
			__u64      nr;                   /*    32     8 */
			__u64      args[6];              /*    40    48 */
			/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
			__u64      ret;                  /*    88     8 */
			__u32      longmode;             /*    96     4 */
			__u32      pad;                  /*   100     4 */
		} hypercall;                             /*    32    72 */
		struct {
			__u64      rip;                  /*    32     8 */
			__u32      is_write;             /*    40     4 */
			__u32      pad;                  /*    44     4 */
		} tpr_access;                            /*    32    16 */
		struct {
			__u8       icptcode;             /*    32     1 */

			/* XXX 1 byte hole, try to pack */

			__u16      ipa;                  /*    34     2 */
			__u32      ipb;                  /*    36     4 */
		} s390_sieic;                            /*    32     8 */
		__u64              s390_reset_flags;     /*    32     8 */
		struct {
			__u64      trans_exc_code;       /*    32     8 */
			__u32      pgm_code;             /*    40     4 */
		} s390_ucontrol;                         /*    32    16 */
		struct {
			__u32      dcrn;                 /*    32     4 */
			__u32      data;                 /*    36     4 */
			__u8       is_write;             /*    40     1 */
		} dcr;                                   /*    32    12 */
		struct {
			__u32      suberror;             /*    32     4 */
			__u32      ndata;                /*    36     4 */
			__u64      data[16];             /*    40   128 */
		} internal;                              /*    32   136 */
		struct {
			__u64      gprs[32];             /*    32   256 */
		} osi;                                   /*    32   256 */
		struct {
			__u64      nr;                   /*    32     8 */
			__u64      ret;                  /*    40     8 */
			__u64      args[9];              /*    48    72 */
		} papr_hcall;                            /*    32    88 */
		struct {
			__u16      subchannel_id;        /*    32     2 */
			__u16      subchannel_nr;        /*    34     2 */
			__u32      io_int_parm;          /*    36     4 */
			__u32      io_int_word;          /*    40     4 */
			__u32      ipb;                  /*    44     4 */
			__u8       dequeued;             /*    48     1 */
		} s390_tsch;                             /*    32    20 */
		struct {
			__u32      epr;                  /*    32     4 */
		} epr;                                   /*    32     4 */
		struct {
			__u32      type;                 /*    32     4 */

			/* XXX 4 bytes hole, try to pack */

			__u64      flags;                /*    40     8 */
		} system_event;                          /*    32    16 */
		struct {
			__u64      addr;                 /*    32     8 */
			__u8       ar;                   /*    40     1 */
			__u8       reserved;             /*    41     1 */
			__u8       fc;                   /*    42     1 */
			__u8       sel1;                 /*    43     1 */
			__u16      sel2;                 /*    44     2 */
		} s390_stsi;                             /*    32    16 */
		struct {
			__u8       vector;               /*    32     1 */
		} eoi;                                   /*    32     1 */
		struct kvm_hyperv_exit hyperv;           /*    32    40 */
		char               padding[256];         /*    32   256 */
	};                                               /*    32   256 */
	/* --- cacheline 4 boundary (256 bytes) was 32 bytes ago --- */
	__u64                      kvm_valid_regs;       /*   288     8 */
	__u64                      kvm_dirty_regs;       /*   296     8 */
	union {
		struct kvm_sync_regs regs;               /*   304     0 */
		char               padding[2048];        /*   304  2048 */
	} s;                                             /*   304  2048 */

	/* size: 2352, cachelines: 37, members: 12 */
	/* last cacheline: 48 bytes */
};
struct CPUTailQ {
	struct CPUState *          tqh_first;            /*     0     8 */
	struct CPUState * *        tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct Notifier {
	void                       (*notify)(Notifier *, void *); /*     0     8 */
	struct {
		struct Notifier *  le_next;              /*     8     8 */
		struct Notifier * * le_prev;             /*    16     8 */
	} node;                                          /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
struct CPUTLBEntry {
	union {
		struct {
			target_ulong addr_read;          /*     0     8 */
			target_ulong addr_write;         /*     8     8 */
			target_ulong addr_code;          /*    16     8 */
			uintptr_t  addend;               /*    24     8 */
		};                                       /*     0    32 */
		uint8_t            dummy[32];            /*     0    32 */
	};                                               /*     0    32 */

	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */
};
struct CPUIOTLBEntry {
	hwaddr                     addr;                 /*     0     8 */
	MemTxAttrs                 attrs;                /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct SegmentCache {
	uint32_t                   selector;             /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	target_ulong               base;                 /*     8     8 */
	uint32_t                   limit;                /*    16     4 */
	uint32_t                   flags;                /*    20     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
union ZMMReg {
	uint8_t                    _b_ZMMReg[64];      /*     0    64 */
	uint16_t                   _w_ZMMReg[32];      /*     0    64 */
	uint32_t                   _l_ZMMReg[16];      /*     0    64 */
	uint64_t                   _q_ZMMReg[8];       /*     0    64 */
	float32                    _s_ZMMReg[16];      /*     0    64 */
	float64                    _d_ZMMReg[8];       /*     0    64 */
};
union MMXReg {
	uint8_t                    _b_MMXReg[8];       /*     0     8 */
	uint16_t                   _w_MMXReg[4];       /*     0     8 */
	uint32_t                   _l_MMXReg[2];       /*     0     8 */
	uint64_t                   _q_MMXReg[1];       /*     0     8 */
	float32                    _s_MMXReg[2];       /*     0     8 */
	float64                    _d_MMXReg[1];       /*     0     8 */
};
struct BNDReg {
	uint64_t                   lb;                   /*     0     8 */
	uint64_t                   ub;                   /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BNDCSReg {
	uint64_t                   cfgu;                 /*     0     8 */
	uint64_t                   sts;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct CPUX86State {
	target_ulong               regs[16];             /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	target_ulong               eip;                  /*   128     8 */
	target_ulong               eflags;               /*   136     8 */
	target_ulong               cc_dst;               /*   144     8 */
	target_ulong               cc_src;               /*   152     8 */
	target_ulong               cc_src2;              /*   160     8 */
	uint32_t                   cc_op;                /*   168     4 */
	int32_t                    df;                   /*   172     4 */
	uint32_t                   hflags;               /*   176     4 */
	uint32_t                   hflags2;              /*   180     4 */
	SegmentCache               segs[6];              /*   184   144 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	SegmentCache               ldt;                  /*   328    24 */
	SegmentCache               tr;                   /*   352    24 */
	SegmentCache               gdt;                  /*   376    24 */
	/* --- cacheline 6 boundary (384 bytes) was 16 bytes ago --- */
	SegmentCache               idt;                  /*   400    24 */
	target_ulong               cr[5];                /*   424    40 */
	/* --- cacheline 7 boundary (448 bytes) was 16 bytes ago --- */
	int32_t                    a20_mask;             /*   464     4 */

	/* XXX 4 bytes hole, try to pack */

	BNDReg                     bnd_regs[4];          /*   472    64 */
	/* --- cacheline 8 boundary (512 bytes) was 24 bytes ago --- */
	BNDCSReg                   bndcs_regs;           /*   536    16 */
	uint64_t                   msr_bndcfgs;          /*   552     8 */
	uint64_t                   efer;                 /*   560     8 */
	struct {
	} start_init_save;                               /*   568     0 */
	unsigned int               fpstt;                /*   568     4 */
	uint16_t                   fpus;                 /*   572     2 */
	uint16_t                   fpuc;                 /*   574     2 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	uint8_t                    fptags[8];            /*   576     8 */

	/* XXX 8 bytes hole, try to pack */

	FPReg                      fpregs[8];            /*   592   128 */
	/* --- cacheline 11 boundary (704 bytes) was 16 bytes ago --- */
	uint16_t                   fpop;                 /*   720     2 */

	/* XXX 6 bytes hole, try to pack */

	uint64_t                   fpip;                 /*   728     8 */
	uint64_t                   fpdp;                 /*   736     8 */
	float_status               fp_status;            /*   744     8 */
	floatx80                   ft0;                  /*   752    16 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	float_status               mmx_status;           /*   768     8 */
	float_status               sse_status;           /*   776     8 */
	uint32_t                   mxcsr;                /*   784     4 */

	/* XXX 4 bytes hole, try to pack */

	ZMMReg                     xmm_regs[32];         /*   792  2048 */
	/* --- cacheline 44 boundary (2816 bytes) was 24 bytes ago --- */
	ZMMReg                     xmm_t0;               /*  2840    64 */
	/* --- cacheline 45 boundary (2880 bytes) was 24 bytes ago --- */
	MMXReg                     mmx_t0;               /*  2904     8 */
	uint64_t                   opmask_regs[8];       /*  2912    64 */
	/* --- cacheline 46 boundary (2944 bytes) was 32 bytes ago --- */
	uint32_t                   sysenter_cs;          /*  2976     4 */

	/* XXX 4 bytes hole, try to pack */

	target_ulong               sysenter_esp;         /*  2984     8 */
	target_ulong               sysenter_eip;         /*  2992     8 */
	uint64_t                   star;                 /*  3000     8 */
	/* --- cacheline 47 boundary (3008 bytes) --- */
	uint64_t                   vm_hsave;             /*  3008     8 */
	target_ulong               lstar;                /*  3016     8 */
	target_ulong               cstar;                /*  3024     8 */
	target_ulong               fmask;                /*  3032     8 */
	target_ulong               kernelgsbase;         /*  3040     8 */
	uint64_t                   tsc;                  /*  3048     8 */
	uint64_t                   tsc_adjust;           /*  3056     8 */
	uint64_t                   tsc_deadline;         /*  3064     8 */
	/* --- cacheline 48 boundary (3072 bytes) --- */
	uint64_t                   tsc_aux;              /*  3072     8 */
	uint64_t                   xcr0;                 /*  3080     8 */
	uint64_t                   mcg_status;           /*  3088     8 */
	uint64_t                   msr_ia32_misc_enable; /*  3096     8 */
	uint64_t                   msr_ia32_feature_control; /*  3104     8 */
	uint64_t                   msr_fixed_ctr_ctrl;   /*  3112     8 */
	uint64_t                   msr_global_ctrl;      /*  3120     8 */
	uint64_t                   msr_global_status;    /*  3128     8 */
	/* --- cacheline 49 boundary (3136 bytes) --- */
	uint64_t                   msr_global_ovf_ctrl;  /*  3136     8 */
	uint64_t                   msr_fixed_counters[3]; /*  3144    24 */
	uint64_t                   msr_gp_counters[18];  /*  3168   144 */
	/* --- cacheline 51 boundary (3264 bytes) was 48 bytes ago --- */
	uint64_t                   msr_gp_evtsel[18];    /*  3312   144 */
	/* --- cacheline 54 boundary (3456 bytes) --- */
	uint64_t                   pat;                  /*  3456     8 */
	uint32_t                   smbase;               /*  3464     4 */
	uint32_t                   pkru;                 /*  3468     4 */
	struct {
	} end_init_save;                                 /*  3472     0 */
	uint64_t                   system_time_msr;      /*  3472     8 */
	uint64_t                   wall_clock_msr;       /*  3480     8 */
	uint64_t                   steal_time_msr;       /*  3488     8 */
	uint64_t                   async_pf_en_msr;      /*  3496     8 */
	uint64_t                   pv_eoi_en_msr;        /*  3504     8 */
	uint64_t                   msr_hv_hypercall;     /*  3512     8 */
	/* --- cacheline 55 boundary (3520 bytes) --- */
	uint64_t                   msr_hv_guest_os_id;   /*  3520     8 */
	uint64_t                   msr_hv_vapic;         /*  3528     8 */
	uint64_t                   msr_hv_tsc;           /*  3536     8 */
	uint64_t                   msr_hv_crash_params[5]; /*  3544    40 */
	/* --- cacheline 56 boundary (3584 bytes) --- */
	uint64_t                   msr_hv_runtime;       /*  3584     8 */
	uint64_t                   msr_hv_synic_control; /*  3592     8 */
	uint64_t                   msr_hv_synic_version; /*  3600     8 */
	uint64_t                   msr_hv_synic_evt_page; /*  3608     8 */
	uint64_t                   msr_hv_synic_msg_page; /*  3616     8 */
	uint64_t                   msr_hv_synic_sint[16]; /*  3624   128 */
	/* --- cacheline 58 boundary (3712 bytes) was 40 bytes ago --- */
	uint64_t                   msr_hv_stimer_config[4]; /*  3752    32 */
	/* --- cacheline 59 boundary (3776 bytes) was 8 bytes ago --- */
	uint64_t                   msr_hv_stimer_count[4]; /*  3784    32 */
	int                        error_code;           /*  3816     4 */
	int                        exception_is_int;     /*  3820     4 */
	target_ulong               exception_next_eip;   /*  3824     8 */
	target_ulong               dr[8];                /*  3832    64 */
	/* --- cacheline 60 boundary (3840 bytes) was 56 bytes ago --- */
	union {
		struct CPUBreakpoint * cpu_breakpoint[4]; /*  3896    32 */
		struct CPUWatchpoint * cpu_watchpoint[4]; /*  3896    32 */
	};                                               /*  3896    32 */
	/* --- cacheline 61 boundary (3904 bytes) was 24 bytes ago --- */
	int                        old_exception;        /*  3928     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   vm_vmcb;              /*  3936     8 */
	uint64_t                   tsc_offset;           /*  3944     8 */
	uint64_t                   intercept;            /*  3952     8 */
	uint16_t                   intercept_cr_read;    /*  3960     2 */
	uint16_t                   intercept_cr_write;   /*  3962     2 */
	uint16_t                   intercept_dr_read;    /*  3964     2 */
	uint16_t                   intercept_dr_write;   /*  3966     2 */
	/* --- cacheline 62 boundary (3968 bytes) --- */
	uint32_t                   intercept_exceptions; /*  3968     4 */
	uint8_t                    v_tpr;                /*  3972     1 */
	uint8_t                    nmi_injected;         /*  3973     1 */
	uint8_t                    nmi_pending;          /*  3974     1 */

	/* XXX 1 byte hole, try to pack */

	CPUTLBEntry                tlb_table[3][256];    /*  3976 24576 */
	/* --- cacheline 446 boundary (28544 bytes) was 8 bytes ago --- */
	CPUTLBEntry                tlb_v_table[3][8];    /* 28552   768 */
	/* --- cacheline 458 boundary (29312 bytes) was 8 bytes ago --- */
	CPUIOTLBEntry              iotlb[3][256];        /* 29320 12288 */
	/* --- cacheline 650 boundary (41600 bytes) was 8 bytes ago --- */
	CPUIOTLBEntry              iotlb_v[3][8];        /* 41608   384 */
	/* --- cacheline 656 boundary (41984 bytes) was 8 bytes ago --- */
	target_ulong               tlb_flush_addr;       /* 41992     8 */
	target_ulong               tlb_flush_mask;       /* 42000     8 */
	target_ulong               vtlb_index;           /* 42008     8 */
	struct {
	} end_reset_fields;                              /* 42016     0 */
	uint32_t                   cpuid_min_level;      /* 42016     4 */
	uint32_t                   cpuid_min_xlevel;     /* 42020     4 */
	uint32_t                   cpuid_min_xlevel2;    /* 42024     4 */
	uint32_t                   cpuid_max_level;      /* 42028     4 */
	uint32_t                   cpuid_max_xlevel;     /* 42032     4 */
	uint32_t                   cpuid_max_xlevel2;    /* 42036     4 */
	uint32_t                   cpuid_level;          /* 42040     4 */
	uint32_t                   cpuid_xlevel;         /* 42044     4 */
	/* --- cacheline 657 boundary (42048 bytes) --- */
	uint32_t                   cpuid_xlevel2;        /* 42048     4 */
	uint32_t                   cpuid_vendor1;        /* 42052     4 */
	uint32_t                   cpuid_vendor2;        /* 42056     4 */
	uint32_t                   cpuid_vendor3;        /* 42060     4 */
	uint32_t                   cpuid_version;        /* 42064     4 */
	FeatureWordArray           features;             /* 42068    72 */
	/* --- cacheline 658 boundary (42112 bytes) was 28 bytes ago --- */
	uint32_t                   cpuid_model[12];      /* 42140    48 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 659 boundary (42176 bytes) was 16 bytes ago --- */
	uint64_t                   mtrr_fixed[11];       /* 42192    88 */
	/* --- cacheline 660 boundary (42240 bytes) was 40 bytes ago --- */
	uint64_t                   mtrr_deftype;         /* 42280     8 */
	MTRRVar                    mtrr_var[8];          /* 42288   128 */
	/* --- cacheline 662 boundary (42368 bytes) was 48 bytes ago --- */
	uint32_t                   mp_state;             /* 42416     4 */
	int32_t                    exception_injected;   /* 42420     4 */
	int32_t                    interrupt_injected;   /* 42424     4 */
	uint8_t                    soft_interrupt;       /* 42428     1 */
	uint8_t                    has_error_code;       /* 42429     1 */

	/* XXX 2 bytes hole, try to pack */

	/* --- cacheline 663 boundary (42432 bytes) --- */
	uint32_t                   sipi_vector;          /* 42432     4 */
	_Bool                      tsc_valid;            /* 42436     1 */

	/* XXX 3 bytes hole, try to pack */

	int64_t                    tsc_khz;              /* 42440     8 */
	int64_t                    user_tsc_khz;         /* 42448     8 */
	void *                     kvm_xsave_buf;        /* 42456     8 */
	uint64_t                   mcg_cap;              /* 42464     8 */
	uint64_t                   mcg_ctl;              /* 42472     8 */
	uint64_t                   mcg_ext_ctl;          /* 42480     8 */
	uint64_t                   mce_banks[40];        /* 42488   320 */
	/* --- cacheline 668 boundary (42752 bytes) was 56 bytes ago --- */
	uint64_t                   xstate_bv;            /* 42808     8 */
	/* --- cacheline 669 boundary (42816 bytes) --- */
	uint16_t                   fpus_vmstate;         /* 42816     2 */
	uint16_t                   fptag_vmstate;        /* 42818     2 */
	uint16_t                   fpregs_format_vmstate; /* 42820     2 */

	/* XXX 2 bytes hole, try to pack */

	uint64_t                   xss;                  /* 42824     8 */
	TPRAccess                  tpr_access_type;      /* 42832     4 */

	/* Force padding: */
	TPRAccess                  :32;
	TPRAccess                  :32;
	TPRAccess                  :32;

	/* size: 42848, cachelines: 670, members: 148 */
	/* sum members: 42794, holes: 11, sum holes: 42 */
	/* padding: 12 */
	/* last cacheline: 32 bytes */
};
struct rcu_reader_data {
	long unsigned int          ctr;                  /*     0     8 */
	_Bool                      waiting;              /*     8     1 */

	/* XXX 3 bytes hole, try to pack */

	unsigned int               depth;                /*    12     4 */
	struct {
		struct rcu_reader_data * le_next;        /*    16     8 */
		struct rcu_reader_data * * le_prev;      /*    24     8 */
	} node;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 29, holes: 1, sum holes: 3 */
	/* last cacheline: 32 bytes */
};
struct rcu_head {
	struct rcu_head *          next;                 /*     0     8 */
	RCUCBFunc *                func;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct MemoryRegionOps {
	uint64_t                   (*read)(void *, hwaddr, unsigned int); /*     0     8 */
	void                       (*write)(void *, hwaddr, uint64_t, unsigned int); /*     8     8 */
	MemTxResult                (*read_with_attrs)(void *, hwaddr, uint64_t *, unsigned int, MemTxAttrs); /*    16     8 */
	MemTxResult                (*write_with_attrs)(void *, hwaddr, uint64_t, unsigned int, MemTxAttrs); /*    24     8 */
	enum device_endian         endianness;           /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		unsigned int       min_access_size;      /*    40     4 */
		unsigned int       max_access_size;      /*    44     4 */
		_Bool              unaligned;            /*    48     1 */

		/* XXX 7 bytes hole, try to pack */

		_Bool              (*accepts)(void *, hwaddr, unsigned int, _Bool); /*    56     8 */
	} valid;                                         /*    40    24 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	struct {
		unsigned int       min_access_size;      /*    64     4 */
		unsigned int       max_access_size;      /*    68     4 */
		_Bool              unaligned;            /*    72     1 */
	} impl;                                          /*    64    12 */

	/* XXX last struct has 3 bytes of padding */
	/* XXX 4 bytes hole, try to pack */

	const MemoryRegionMmio     old_mmio;             /*    80    48 */

	/* size: 128, cachelines: 2, members: 8 */
	/* sum members: 120, holes: 2, sum holes: 8 */
	/* paddings: 1, sum paddings: 3 */
};
struct MemoryRegionMmio {
	CPUReadMemoryFunc *        read[3];              /*     0    24 */
	CPUWriteMemoryFunc *       write[3];             /*    24    24 */

	/* size: 48, cachelines: 1, members: 2 */
	/* last cacheline: 48 bytes */
};
struct IOMMUTLBEntry {
	AddressSpace *             target_as;            /*     0     8 */
	hwaddr                     iova;                 /*     8     8 */
	hwaddr                     translated_addr;      /*    16     8 */
	hwaddr                     addr_mask;            /*    24     8 */
	IOMMUAccessFlags           perm;                 /*    32     4 */

	/* size: 40, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct IOMMUNotifier {
	void                       (*notify)(struct IOMMUNotifier *, IOMMUTLBEntry *); /*     0     8 */
	IOMMUNotifierFlag          notifier_flags;       /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct IOMMUNotifier * le_next;          /*    16     8 */
		struct IOMMUNotifier * * le_prev;        /*    24     8 */
	} node;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct MemoryRegionIOMMUOps {
	IOMMUTLBEntry              (*translate)(MemoryRegion *, hwaddr, _Bool); /*     0     8 */
	uint64_t                   (*get_min_page_size)(MemoryRegion *); /*     8     8 */
	void                       (*notify_flag_changed)(MemoryRegion *, IOMMUNotifierFlag, IOMMUNotifierFlag); /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct subregions {
	struct MemoryRegion *      tqh_first;            /*     0     8 */
	struct MemoryRegion * *    tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct coalesced_ranges {
	struct CoalescedMemoryRange * tqh_first;         /*     0     8 */
	struct CoalescedMemoryRange * * tqh_last;        /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct memory_listeners_as {
	struct MemoryListener *    tqh_first;            /*     0     8 */
	struct MemoryListener * *  tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct AddressSpaceDispatch {
	struct rcu_head            rcu;                  /*     0    16 */
	MemoryRegionSection *      mru_section;          /*    16     8 */
	PhysPageEntry              phys_map;             /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	PhysPageMap                map;                  /*    32    48 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	AddressSpace *             as;                   /*    80     8 */

	/* size: 88, cachelines: 2, members: 5 */
	/* sum members: 84, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct qht {
	struct qht_map *           map;                  /*     0     8 */
	QemuMutex                  lock;                 /*     8    40 */
	unsigned int               mode;                 /*    48     4 */

	/* size: 56, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct TBContext {
	TranslationBlock *         tbs;                  /*     0     8 */
	struct qht                 htable;               /*     8    56 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        nb_tbs;               /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	QemuMutex                  tb_lock;              /*    72    40 */
	unsigned int               tb_flush_count;       /*   112     4 */
	int                        tb_phys_invalidate_count; /*   116     4 */

	/* size: 120, cachelines: 2, members: 6 */
	/* sum members: 116, holes: 1, sum holes: 4 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 56 bytes */
};
struct TCGPool {
	struct TCGPool *           next;                 /*     0     8 */
	int                        size;                 /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t                    data[];               /*    16     0 */

	/* size: 16, cachelines: 1, members: 3 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct TCGTemp {
	TCGReg                     reg:8;                /*     0: 0  4 */
	TCGTempVal                 val_type:8;           /*     0: 8  4 */
	TCGType                    base_type:8;          /*     0:16  4 */
	TCGType                    type:8;               /*     0:24  4 */
	unsigned int               fixed_reg:1;          /*     4: 0  4 */
	unsigned int               indirect_reg:1;       /*     4: 1  4 */
	unsigned int               indirect_base:1;      /*     4: 2  4 */
	unsigned int               mem_coherent:1;       /*     4: 3  4 */
	unsigned int               mem_allocated:1;      /*     4: 4  4 */
	unsigned int               temp_local:1;         /*     4: 5  4 */
	unsigned int               temp_allocated:1;     /*     4: 6  4 */

	/* XXX 25 bits hole, try to pack */

	tcg_target_long            val;                  /*     8     8 */
	struct TCGTemp *           mem_base;             /*    16     8 */
	intptr_t                   mem_offset;           /*    24     8 */
	const char  *              name;                 /*    32     8 */

	/* size: 40, cachelines: 1, members: 15 */
	/* sum members: 32 */
	/* sum bitfield members: 39 bits, bit holes: 1, sum bit holes: 25 bits */
	/* last cacheline: 40 bytes */
};
struct TCGContext {
	uint8_t *                  pool_cur;             /*     0     8 */
	uint8_t *                  pool_end;             /*     8     8 */
	TCGPool *                  pool_first;           /*    16     8 */
	TCGPool *                  pool_current;         /*    24     8 */
	TCGPool *                  pool_first_large;     /*    32     8 */
	int                        nb_labels;            /*    40     4 */
	int                        nb_globals;           /*    44     4 */
	int                        nb_temps;             /*    48     4 */
	int                        nb_indirects;         /*    52     4 */
	tcg_insn_unit *            code_buf;             /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint16_t *                 tb_jmp_reset_offset;  /*    64     8 */
	uint16_t *                 tb_jmp_insn_offset;   /*    72     8 */
	uintptr_t *                tb_jmp_target_addr;   /*    80     8 */
	TCGRegSet                  reserved_regs;        /*    88     4 */

	/* XXX 4 bytes hole, try to pack */

	intptr_t                   current_frame_offset; /*    96     8 */
	intptr_t                   frame_start;          /*   104     8 */
	intptr_t                   frame_end;            /*   112     8 */
	TCGTemp *                  frame_temp;           /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	tcg_insn_unit *            code_ptr;             /*   128     8 */
	GHashTable *               helpers;              /*   136     8 */
	int                        gen_next_op_idx;      /*   144     4 */
	int                        gen_next_parm_idx;    /*   148     4 */
	int                        code_gen_max_blocks;  /*   152     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     code_gen_prologue;    /*   160     8 */
	void *                     code_gen_buffer;      /*   168     8 */
	size_t                     code_gen_buffer_size; /*   176     8 */
	void *                     code_gen_ptr;         /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	void *                     code_gen_highwater;   /*   192     8 */
	TBContext                  tb_ctx;               /*   200   120 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	CPUState *                 cpu;                  /*   320     8 */
	TCGv_env                   tcg_env;              /*   328     8 */
	struct TCGBackendData *    be;                   /*   336     8 */
	TCGTempSet                 free_temps[4];        /*   344   256 */
	/* --- cacheline 9 boundary (576 bytes) was 24 bytes ago --- */
	TCGTemp                    temps[512];           /*   600 20480 */
	/* --- cacheline 329 boundary (21056 bytes) was 24 bytes ago --- */
	TCGTemp *                  reg_to_temp[16];      /* 21080   128 */
	/* --- cacheline 331 boundary (21184 bytes) was 24 bytes ago --- */
	TCGOp                      gen_op_buf[640];      /* 21208  5120 */
	/* --- cacheline 411 boundary (26304 bytes) was 24 bytes ago --- */
	TCGArg                     gen_opparam_buf[6400]; /* 26328 51200 */
	/* --- cacheline 1211 boundary (77504 bytes) was 24 bytes ago --- */
	uint16_t                   gen_insn_end_off[512]; /* 77528  1024 */
	/* --- cacheline 1227 boundary (78528 bytes) was 24 bytes ago --- */
	target_ulong               gen_insn_data[512][2]; /* 78552  8192 */

	/* size: 86744, cachelines: 1356, members: 39 */
	/* sum members: 86736, holes: 2, sum holes: 8 */
	/* last cacheline: 24 bytes */
};
struct TCGTempSet {
	long unsigned int          l[8];                 /*     0    64 */

	/* size: 64, cachelines: 1, members: 1 */
};
struct TCGOp {
	TCGOpcode                  opc:8;                /*     0: 0  4 */
	unsigned int               prev:10;              /*     0: 8  4 */
	unsigned int               next:10;              /*     0:18  4 */
	unsigned int               calli:4;              /*     0:28  4 */
	unsigned int               callo:2;              /*     4: 0  4 */
	unsigned int               args:14;              /*     4: 2  4 */
	unsigned int               life:16;              /*     4:16  4 */

	/* size: 8, cachelines: 1, members: 7 */
	/* last cacheline: 8 bytes */
};
struct AccelState {
	Object                     parent_obj;           /*     0    40 */

	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
struct VMStateInfo {
	const char  *              name;                 /*     0     8 */
	int                        (*get)(QEMUFile *, void *, size_t); /*     8     8 */
	void                       (*put)(QEMUFile *, void *, size_t); /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct kvm_debug_exit_arch {
	__u32                      exception;            /*     0     4 */
	__u32                      pad;                  /*     4     4 */
	__u64                      pc;                   /*     8     8 */
	__u64                      dr6;                  /*    16     8 */
	__u64                      dr7;                  /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct kvm_sync_regs {

	/* size: 0, cachelines: 0, members: 0 */
};
struct kvm_hyperv_exit {
	__u32                      type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		struct {
			__u32      msr;                  /*     8     4 */

			/* XXX 4 bytes hole, try to pack */

			__u64      control;              /*    16     8 */
			__u64      evt_page;             /*    24     8 */
			__u64      msg_page;             /*    32     8 */
		} synic;                                 /*     8    32 */
		struct {
			__u64      input;                /*     8     8 */
			__u64      result;               /*    16     8 */
			__u64      params[2];            /*    24    16 */
		} hcall;                                 /*     8    32 */
	} u;                                             /*     8    32 */

	/* size: 40, cachelines: 1, members: 2 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct TraceEvent {
	uint32_t                   id;                   /*     0     4 */
	uint32_t                   vcpu_id;              /*     4     4 */
	const char  *              name;                 /*     8     8 */
	const _Bool                sstate;               /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	uint16_t *                 dstate;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 25, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct RAMList {
	QemuMutex                  mutex;                /*     0    40 */
	RAMBlock *                 mru_block;            /*    40     8 */
	struct {
		struct RAMBlock *  lh_first;             /*    48     8 */
	} blocks;                                        /*    48     8 */
	DirtyMemoryBlocks *        dirty_memory[3];      /*    56    24 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	uint32_t                   version;              /*    80     4 */

	/* size: 88, cachelines: 2, members: 5 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct PhysPageEntry {
	uint32_t                   skip:6;               /*     0: 0  4 */
	uint32_t                   ptr:26;               /*     0: 6  4 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
struct PhysPageMap {
	struct rcu_head            rcu;                  /*     0    16 */
	unsigned int               sections_nb;          /*    16     4 */
	unsigned int               sections_nb_alloc;    /*    20     4 */
	unsigned int               nodes_nb;             /*    24     4 */
	unsigned int               nodes_nb_alloc;       /*    28     4 */
	Node *                     nodes;                /*    32     8 */
	MemoryRegionSection *      sections;             /*    40     8 */

	/* size: 48, cachelines: 1, members: 7 */
	/* last cacheline: 48 bytes */
};
struct subpage_t {
	MemoryRegion               iomem;                /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	AddressSpace *             as;                   /*   256     8 */
	hwaddr                     base;                 /*   264     8 */
	uint16_t                   sub_section[];        /*   272     0 */

	/* size: 272, cachelines: 5, members: 4 */
	/* last cacheline: 16 bytes */
};
struct MapClient {
	QEMUBH *                   bh;                   /*     0     8 */
	struct {
		struct MapClient * le_next;              /*     8     8 */
		struct MapClient * * le_prev;            /*    16     8 */
	} link;                                          /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
struct map_client_list {
	struct MapClient *         lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct timeval {
	__time_t                   tv_sec;               /*     0     8 */
	__suseconds_t              tv_usec;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct timezone {
	int                        tz_minuteswest;       /*     0     4 */
	int                        tz_dsttime;           /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct X86CPU {
	CPUState                   parent_obj;           /*     0 33408 */
	/* --- cacheline 522 boundary (33408 bytes) --- */
	CPUX86State                env;                  /* 33408 42848 */
	/* --- cacheline 1191 boundary (76224 bytes) was 32 bytes ago --- */
	_Bool                      hyperv_vapic;         /* 76256     1 */
	_Bool                      hyperv_relaxed_timing; /* 76257     1 */

	/* XXX 2 bytes hole, try to pack */

	int                        hyperv_spinlock_attempts; /* 76260     4 */
	char *                     hyperv_vendor_id;     /* 76264     8 */
	_Bool                      hyperv_time;          /* 76272     1 */
	_Bool                      hyperv_crash;         /* 76273     1 */
	_Bool                      hyperv_reset;         /* 76274     1 */
	_Bool                      hyperv_vpindex;       /* 76275     1 */
	_Bool                      hyperv_runtime;       /* 76276     1 */
	_Bool                      hyperv_synic;         /* 76277     1 */
	_Bool                      hyperv_stimer;        /* 76278     1 */
	_Bool                      check_cpuid;          /* 76279     1 */
	_Bool                      enforce_cpuid;        /* 76280     1 */
	_Bool                      expose_kvm;           /* 76281     1 */
	_Bool                      migratable;           /* 76282     1 */
	_Bool                      host_features;        /* 76283     1 */
	uint32_t                   apic_id;              /* 76284     4 */
	/* --- cacheline 1192 boundary (76288 bytes) --- */
	_Bool                      cache_info_passthrough; /* 76288     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   filtered_features[18]; /* 76292    72 */
	/* --- cacheline 1193 boundary (76352 bytes) was 12 bytes ago --- */
	_Bool                      enable_pmu;           /* 76364     1 */
	_Bool                      enable_lmce;          /* 76365     1 */
	_Bool                      enable_l3_cache;      /* 76366     1 */
	_Bool                      enable_cpuid_0xb;     /* 76367     1 */
	_Bool                      full_cpuid_auto_level; /* 76368     1 */
	_Bool                      fill_mtrr_mask;       /* 76369     1 */
	_Bool                      host_phys_bits;       /* 76370     1 */

	/* XXX 1 byte hole, try to pack */

	uint32_t                   phys_bits;            /* 76372     4 */
	struct DeviceState *       apic_state;           /* 76376     8 */
	struct MemoryRegion *      cpu_as_root;          /* 76384     8 */
	struct MemoryRegion *      cpu_as_mem;           /* 76392     8 */
	struct MemoryRegion *      smram;                /* 76400     8 */
	Notifier                   machine_done;         /* 76408    24 */
	/* --- cacheline 1194 boundary (76416 bytes) was 16 bytes ago --- */
	struct kvm_msrs *          kvm_msr_buf;          /* 76432     8 */
	int32_t                    socket_id;            /* 76440     4 */
	int32_t                    core_id;              /* 76444     4 */
	int32_t                    thread_id;            /* 76448     4 */

	/* Force padding: */
	int32_t                    :32;
	int32_t                    :32;
	int32_t                    :32;

	/* size: 76464, cachelines: 1195, members: 38 */
	/* sum members: 76446, holes: 3, sum holes: 6 */
	/* padding: 12 */
	/* last cacheline: 48 bytes */
};
struct qdist_entry {
	double                     x;                    /*     0     8 */
	long unsigned int          count;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct qdist {
	struct qdist_entry *       entries;              /*     0     8 */
	size_t                     n;                    /*     8     8 */
	size_t                     size;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct qht_stats {
	size_t                     head_buckets;         /*     0     8 */
	size_t                     used_head_buckets;    /*     8     8 */
	size_t                     entries;              /*    16     8 */
	struct qdist               chain;                /*    24    24 */
	struct qdist               occupancy;            /*    48    24 */

	/* size: 72, cachelines: 2, members: 5 */
	/* last cacheline: 8 bytes */
};
struct PageDesc {
	TranslationBlock *         first_tb;             /*     0     8 */
	unsigned int               code_write_count;     /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	long unsigned int *        code_bitmap;          /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct timespec {
	__time_t                   tv_sec;               /*     0     8 */
	__syscall_slong_t          tv_nsec;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct SyncClocks {
	int64_t                    diff_clk;             /*     0     8 */
	int64_t                    last_cpu_icount;      /*     8     8 */
	int64_t                    realtime_clock;       /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct tb_desc {
	target_ulong               pc;                   /*     0     8 */
	target_ulong               cs_base;              /*     8     8 */
	struct CPUX86State *       env;                  /*    16     8 */
	tb_page_addr_t             phys_page1;           /*    24     8 */
	uint32_t                   flags;                /*    32     4 */

	/* size: 40, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct TCGRelocation {
	struct TCGRelocation *     next;                 /*     0     8 */
	int                        type;                 /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	tcg_insn_unit *            ptr;                  /*    16     8 */
	intptr_t                   addend;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct TCGLabel {
	unsigned int               has_value:1;          /*     0: 0  4 */
	unsigned int               id:31;                /*     0: 1  4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		uintptr_t          value;                /*     8     8 */
		tcg_insn_unit *    value_ptr;            /*     8     8 */
		TCGRelocation *    first_reloc;          /*     8     8 */
	} u;                                             /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* sum members: 8, holes: 1, sum holes: 4 */
	/* sum bitfield members: 32 bits (4 bytes) */
	/* last cacheline: 16 bytes */
};
struct TCGBackendData {
	TCGLabelQemuLdst *         labels;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct TCGArgConstraint {
	uint16_t                   ct;                   /*     0     2 */
	uint8_t                    alias_index;          /*     2     1 */

	/* XXX 1 byte hole, try to pack */

	union {
		TCGRegSet          regs;                 /*     4     4 */
	} u;                                             /*     4     4 */

	/* size: 8, cachelines: 1, members: 3 */
	/* sum members: 7, holes: 1, sum holes: 1 */
	/* last cacheline: 8 bytes */
};
struct TCGOpDef {
	const char  *              name;                 /*     0     8 */
	uint8_t                    nb_oargs;             /*     8     1 */
	uint8_t                    nb_iargs;             /*     9     1 */
	uint8_t                    nb_cargs;             /*    10     1 */
	uint8_t                    nb_args;              /*    11     1 */
	uint8_t                    flags;                /*    12     1 */

	/* XXX 3 bytes hole, try to pack */

	TCGArgConstraint *         args_ct;              /*    16     8 */
	int *                      sorted_args;          /*    24     8 */

	/* size: 32, cachelines: 1, members: 8 */
	/* sum members: 29, holes: 1, sum holes: 3 */
	/* last cacheline: 32 bytes */
};
struct TCGTargetOpDef {
	TCGOpcode                  op;                   /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              args_ct_str[16];      /*     8   128 */

	/* size: 136, cachelines: 3, members: 2 */
	/* sum members: 132, holes: 1, sum holes: 4 */
	/* last cacheline: 8 bytes */
};
struct elf64_sym {
	Elf64_Word                 st_name;              /*     0     4 */
	unsigned char              st_info;              /*     4     1 */
	unsigned char              st_other;             /*     5     1 */
	Elf64_Half                 st_shndx;             /*     6     2 */
	Elf64_Addr                 st_value;             /*     8     8 */
	Elf64_Xword                st_size;              /*    16     8 */

	/* size: 24, cachelines: 1, members: 6 */
	/* last cacheline: 24 bytes */
};
struct elf64_hdr {
	unsigned char              e_ident[16];          /*     0    16 */
	Elf64_Half                 e_type;               /*    16     2 */
	Elf64_Half                 e_machine;            /*    18     2 */
	Elf64_Word                 e_version;            /*    20     4 */
	Elf64_Addr                 e_entry;              /*    24     8 */
	Elf64_Off                  e_phoff;              /*    32     8 */
	Elf64_Off                  e_shoff;              /*    40     8 */
	Elf64_Word                 e_flags;              /*    48     4 */
	Elf64_Half                 e_ehsize;             /*    52     2 */
	Elf64_Half                 e_phentsize;          /*    54     2 */
	Elf64_Half                 e_phnum;              /*    56     2 */
	Elf64_Half                 e_shentsize;          /*    58     2 */
	Elf64_Half                 e_shnum;              /*    60     2 */
	Elf64_Half                 e_shstrndx;           /*    62     2 */

	/* size: 64, cachelines: 1, members: 14 */
};
struct elf64_phdr {
	Elf64_Word                 p_type;               /*     0     4 */
	Elf64_Word                 p_flags;              /*     4     4 */
	Elf64_Off                  p_offset;             /*     8     8 */
	Elf64_Addr                 p_vaddr;              /*    16     8 */
	Elf64_Addr                 p_paddr;              /*    24     8 */
	Elf64_Xword                p_filesz;             /*    32     8 */
	Elf64_Xword                p_memsz;              /*    40     8 */
	Elf64_Xword                p_align;              /*    48     8 */

	/* size: 56, cachelines: 1, members: 8 */
	/* last cacheline: 56 bytes */
};
struct elf64_shdr {
	Elf64_Word                 sh_name;              /*     0     4 */
	Elf64_Word                 sh_type;              /*     4     4 */
	Elf64_Xword                sh_flags;             /*     8     8 */
	Elf64_Addr                 sh_addr;              /*    16     8 */
	Elf64_Off                  sh_offset;            /*    24     8 */
	Elf64_Xword                sh_size;              /*    32     8 */
	Elf64_Word                 sh_link;              /*    40     4 */
	Elf64_Word                 sh_info;              /*    44     4 */
	Elf64_Xword                sh_addralign;         /*    48     8 */
	Elf64_Xword                sh_entsize;           /*    56     8 */

	/* size: 64, cachelines: 1, members: 10 */
};
struct TCGLabelQemuLdst {
	_Bool                      is_ld;                /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	TCGMemOpIdx                oi;                   /*     4     4 */
	TCGType                    type;                 /*     8     4 */
	TCGReg                     addrlo_reg;           /*    12     4 */
	TCGReg                     addrhi_reg;           /*    16     4 */
	TCGReg                     datalo_reg;           /*    20     4 */
	TCGReg                     datahi_reg;           /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	tcg_insn_unit *            raddr;                /*    32     8 */
	tcg_insn_unit *            label_ptr[2];         /*    40    16 */
	struct TCGLabelQemuLdst *  next;                 /*    56     8 */

	/* size: 64, cachelines: 1, members: 10 */
	/* sum members: 57, holes: 2, sum holes: 7 */
};
struct TCGHelperInfo {
	void *                     func;                 /*     0     8 */
	const char  *              name;                 /*     8     8 */
	unsigned int               flags;                /*    16     4 */
	unsigned int               sizemask;             /*    20     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct jit_code_entry {
	struct jit_code_entry *    next_entry;           /*     0     8 */
	struct jit_code_entry *    prev_entry;           /*     8     8 */
	const void  *              symfile_addr;         /*    16     8 */
	uint64_t                   symfile_size;         /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct jit_descriptor {
	uint32_t                   version;              /*     0     4 */
	uint32_t                   action_flag;          /*     4     4 */
	struct jit_code_entry *    relevant_entry;       /*     8     8 */
	struct jit_code_entry *    first_entry;          /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct tcg_temp_info {
	_Bool                      is_const;             /*     0     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   prev_copy;            /*     2     2 */
	uint16_t                   next_copy;            /*     4     2 */

	/* XXX 2 bytes hole, try to pack */

	tcg_target_ulong           val;                  /*     8     8 */
	tcg_target_ulong           mask;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 5 */
	/* sum members: 21, holes: 2, sum holes: 3 */
	/* last cacheline: 24 bytes */
};
struct elf32_sym {
	Elf32_Word                 st_name;              /*     0     4 */
	Elf32_Addr                 st_value;             /*     4     4 */
	Elf32_Word                 st_size;              /*     8     4 */
	unsigned char              st_info;              /*    12     1 */
	unsigned char              st_other;             /*    13     1 */
	Elf32_Half                 st_shndx;             /*    14     2 */

	/* size: 16, cachelines: 1, members: 6 */
	/* last cacheline: 16 bytes */
};
struct syminfo {
	lookup_symbol_t            lookup_symbol;        /*     0     8 */
	unsigned int               disas_num_syms;       /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		struct elf32_sym * elf32;                /*    16     8 */
		struct elf64_sym * elf64;                /*    16     8 */
	} disas_symtab;                                  /*    16     8 */
	const char  *              disas_strtab;         /*    24     8 */
	struct syminfo *           next;                 /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct CPUDebug {
	struct disassemble_info    info;                 /*     0   184 */
	/* --- cacheline 2 boundary (128 bytes) was 56 bytes ago --- */
	CPUState *                 cpu;                  /*   184     8 */

	/* size: 192, cachelines: 3, members: 2 */
};
struct ISABus {
	BusState                   parent_obj;           /*     0   104 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	MemoryRegion *             address_space;        /*   104     8 */
	MemoryRegion *             address_space_io;     /*   112     8 */
	qemu_irq *                 irqs;                 /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	IsaDma *                   dma[2];               /*   128    16 */

	/* size: 144, cachelines: 3, members: 5 */
	/* last cacheline: 16 bytes */
};
struct IsaDma {
	Object                     parent;               /*     0    40 */

	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
struct TargetInfo {
	char *                     arch;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct defconfig_file {
	const char  *              filename;             /*     0     8 */
	_Bool                      userconfig;           /*     8     1 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct soundhw {
	const char  *              name;                 /*     0     8 */
	const char  *              descr;                /*     8     8 */
	int                        enabled;              /*    16     4 */
	int                        isa;                  /*    20     4 */
	union {
		int                (*init_isa)(ISABus *); /*    24     8 */
		int                (*init_pci)(PCIBus *); /*    24     8 */
	} init;                                          /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
union sigval {
	int                        sival_int;          /*     0     4 */
	void *                     sival_ptr;          /*     0     8 */
};
struct sigaction {
	union {
		__sighandler_t     sa_handler;           /*     0     8 */
		void               (*sa_sigaction)(int, siginfo_t *, void *); /*     0     8 */
	} __sigaction_handler;                           /*     0     8 */
	__sigset_t                 sa_mask;              /*     8   128 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	int                        sa_flags;             /*   136     4 */

	/* XXX 4 bytes hole, try to pack */

	void                       (*sa_restorer)(void); /*   144     8 */

	/* size: 152, cachelines: 3, members: 4 */
	/* sum members: 148, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct _GSource {
	gpointer                   callback_data;        /*     0     8 */
	GSourceCallbackFuncs *     callback_funcs;       /*     8     8 */
	const GSourceFuncs  *      source_funcs;         /*    16     8 */
	guint                      ref_count;            /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	GMainContext *             context;              /*    32     8 */
	gint                       priority;             /*    40     4 */
	guint                      flags;                /*    44     4 */
	guint                      source_id;            /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	GSList *                   poll_fds;             /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	GSource *                  prev;                 /*    64     8 */
	GSource *                  next;                 /*    72     8 */
	char *                     name;                 /*    80     8 */
	GSourcePrivate *           priv;                 /*    88     8 */

	/* size: 96, cachelines: 2, members: 13 */
	/* sum members: 88, holes: 2, sum holes: 8 */
	/* last cacheline: 32 bytes */
};
struct _GSourceCallbackFuncs {
	void                       (*ref)(gpointer);     /*     0     8 */
	void                       (*unref)(gpointer);   /*     8     8 */
	void                       (*get)(gpointer, GSource *, GSourceFunc *, gpointer *); /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct _GSourceFuncs {
	gboolean                   (*prepare)(GSource *, gint *); /*     0     8 */
	gboolean                   (*check)(GSource *);  /*     8     8 */
	gboolean                   (*dispatch)(GSource *, GSourceFunc, gpointer); /*    16     8 */
	void                       (*finalize)(GSource *); /*    24     8 */
	GSourceFunc                closure_callback;     /*    32     8 */
	GSourceDummyMarshal        closure_marshal;      /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct AioContext {
	GSource                    source;               /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	QemuRecMutex               lock;                 /*    96    40 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	struct {
		struct AioHandler * lh_first;            /*   136     8 */
	} aio_handlers;                                  /*   136     8 */
	int                        walking_handlers;     /*   144     4 */
	uint32_t                   notify_me;            /*   148     4 */
	QemuMutex                  bh_lock;              /*   152    40 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	struct QEMUBH *            first_bh;             /*   192     8 */
	int                        walking_bh;           /*   200     4 */
	_Bool                      notified;             /*   204     1 */

	/* XXX 3 bytes hole, try to pack */

	EventNotifier              notifier;             /*   208     8 */
	struct ThreadPool *        thread_pool;          /*   216     8 */
	QEMUTimerListGroup         tlg;                  /*   224    32 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	int                        external_disable_cnt; /*   256     4 */
	int                        epollfd;              /*   260     4 */
	_Bool                      epoll_enabled;        /*   264     1 */
	_Bool                      epoll_available;      /*   265     1 */

	/* size: 272, cachelines: 5, members: 16 */
	/* sum members: 263, holes: 1, sum holes: 3 */
	/* padding: 6 */
	/* last cacheline: 16 bytes */
};
struct QEMUTimer {
	int64_t                    expire_time;          /*     0     8 */
	QEMUTimerList *            timer_list;           /*     8     8 */
	QEMUTimerCB *              cb;                   /*    16     8 */
	void *                     opaque;               /*    24     8 */
	QEMUTimer *                next;                 /*    32     8 */
	int                        scale;                /*    40     4 */

	/* size: 48, cachelines: 1, members: 6 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct CpuInfo {
	int64_t                    CPU;                  /*     0     8 */
	_Bool                      current;              /*     8     1 */
	_Bool                      halted;               /*     9     1 */

	/* XXX 6 bytes hole, try to pack */

	char *                     qom_path;             /*    16     8 */
	int64_t                    thread_id;            /*    24     8 */
	CpuInfoArch                arch;                 /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		CpuInfoX86         x86;                  /*    40     8 */
		CpuInfoSPARC       q_sparc;              /*    40    16 */
		CpuInfoPPC         ppc;                  /*    40     8 */
		CpuInfoMIPS        q_mips;               /*    40     8 */
		CpuInfoTricore     tricore;              /*    40     8 */
		CpuInfoOther       other;                /*    40     1 */
	} u;                                             /*    40    16 */

	/* size: 56, cachelines: 1, members: 7 */
	/* sum members: 46, holes: 2, sum holes: 10 */
	/* last cacheline: 56 bytes */
};
struct CpuInfoList {
	CpuInfoList *              next;                 /*     0     8 */
	CpuInfo *                  value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct CpuInfoMIPS {
	int64_t                    PC;                   /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct CpuInfoOther {
	char                       qapi_dummy_for_empty_struct; /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
};
struct CpuInfoPPC {
	int64_t                    nip;                  /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct CpuInfoSPARC {
	int64_t                    pc;                   /*     0     8 */
	int64_t                    npc;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct CpuInfoTricore {
	int64_t                    PC;                   /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct CpuInfoX86 {
	int64_t                    pc;                   /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct kvm_msrs {
	__u32                      nmsrs;                /*     0     4 */
	__u32                      pad;                  /*     4     4 */
	struct kvm_msr_entry       entries[];            /*     8     0 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct kvm_msr_entry {
	__u32                      index;                /*     0     4 */
	__u32                      reserved;             /*     4     4 */
	__u64                      data;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct QemuSeqLock {
	unsigned int               sequence;             /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct qemu_signalfd_siginfo {
	uint32_t                   ssi_signo;            /*     0     4 */
	int32_t                    ssi_errno;            /*     4     4 */
	int32_t                    ssi_code;             /*     8     4 */
	uint32_t                   ssi_pid;              /*    12     4 */
	uint32_t                   ssi_uid;              /*    16     4 */
	int32_t                    ssi_fd;               /*    20     4 */
	uint32_t                   ssi_tid;              /*    24     4 */
	uint32_t                   ssi_band;             /*    28     4 */
	uint32_t                   ssi_overrun;          /*    32     4 */
	uint32_t                   ssi_trapno;           /*    36     4 */
	int32_t                    ssi_status;           /*    40     4 */
	int32_t                    ssi_int;              /*    44     4 */
	uint64_t                   ssi_ptr;              /*    48     8 */
	uint64_t                   ssi_utime;            /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint64_t                   ssi_stime;            /*    64     8 */
	uint64_t                   ssi_addr;             /*    72     8 */
	uint8_t                    pad[48];              /*    80    48 */

	/* size: 128, cachelines: 2, members: 17 */
};
struct TimersState {
	int64_t                    cpu_ticks_prev;       /*     0     8 */
	int64_t                    cpu_ticks_offset;     /*     8     8 */
	QemuSeqLock                vm_clock_seqlock;     /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    cpu_clock_offset;     /*    24     8 */
	int32_t                    cpu_ticks_enabled;    /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    dummy;                /*    40     8 */
	int64_t                    qemu_icount_bias;     /*    48     8 */
	int64_t                    qemu_icount;          /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
	/* sum members: 56, holes: 2, sum holes: 8 */
};
struct iovec {
	void *                     iov_base;             /*     0     8 */
	size_t                     iov_len;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct stat {
	__dev_t                    st_dev;               /*     0     8 */
	__ino_t                    st_ino;               /*     8     8 */
	__nlink_t                  st_nlink;             /*    16     8 */
	__mode_t                   st_mode;              /*    24     4 */
	__uid_t                    st_uid;               /*    28     4 */
	__gid_t                    st_gid;               /*    32     4 */
	int                        __pad0;               /*    36     4 */
	__dev_t                    st_rdev;              /*    40     8 */
	__off_t                    st_size;              /*    48     8 */
	__blksize_t                st_blksize;           /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	__blkcnt_t                 st_blocks;            /*    64     8 */
	struct timespec            st_atim;              /*    72    16 */
	struct timespec            st_mtim;              /*    88    16 */
	struct timespec            st_ctim;              /*   104    16 */
	__syscall_slong_t          __glibc_reserved[3];  /*   120    24 */

	/* size: 144, cachelines: 3, members: 15 */
	/* last cacheline: 16 bytes */
};
struct _GArray {
	gchar *                    data;                 /*     0     8 */
	guint                      len;                  /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct _GError {
	GQuark                     domain;               /*     0     4 */
	gint                       code;                 /*     4     4 */
	gchar *                    message;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct dirent {
	__ino64_t                  d_ino;                /*     0     8 */
	__off64_t                  d_off;                /*     8     8 */
	short unsigned int         d_reclen;             /*    16     2 */
	unsigned char              d_type;               /*    18     1 */
	char                       d_name[256];          /*    19   256 */

	/* size: 280, cachelines: 5, members: 5 */
	/* padding: 5 */
	/* last cacheline: 24 bytes */
};
struct _GList {
	gpointer                   data;                 /*     0     8 */
	GList *                    next;                 /*     8     8 */
	GList *                    prev;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct _GString {
	gchar *                    str;                  /*     0     8 */
	gsize                      len;                  /*     8     8 */
	gsize                      allocated_len;        /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct _GIOChannel {
	gint                       ref_count;            /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	GIOFuncs *                 funcs;                /*     8     8 */
	gchar *                    encoding;             /*    16     8 */
	GIConv                     read_cd;              /*    24     8 */
	GIConv                     write_cd;             /*    32     8 */
	gchar *                    line_term;            /*    40     8 */
	guint                      line_term_len;        /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	gsize                      buf_size;             /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	GString *                  read_buf;             /*    64     8 */
	GString *                  encoded_read_buf;     /*    72     8 */
	GString *                  write_buf;            /*    80     8 */
	gchar                      partial_write_buf[6]; /*    88     6 */

	/* Bitfield combined with next fields */

	guint                      use_buffer:1;         /*    92:16  4 */
	guint                      do_encode:1;          /*    92:17  4 */
	guint                      close_on_unref:1;     /*    92:18  4 */
	guint                      is_readable:1;        /*    92:19  4 */
	guint                      is_writeable:1;       /*    92:20  4 */
	guint                      is_seekable:1;        /*    92:21  4 */

	/* XXX 10 bits hole, try to pack */

	gpointer                   reserved1;            /*    96     8 */
	gpointer                   reserved2;            /*   104     8 */

	/* size: 112, cachelines: 2, members: 20 */
	/* sum members: 102, holes: 2, sum holes: 8 */
	/* sum bitfield members: 6 bits, bit holes: 1, sum bit holes: 10 bits */
	/* last cacheline: 48 bytes */
};
struct _GIOFuncs {
	GIOStatus                  (*io_read)(GIOChannel *, gchar *, gsize, gsize *, GError * *); /*     0     8 */
	GIOStatus                  (*io_write)(GIOChannel *, const gchar  *, gsize, gsize *, GError * *); /*     8     8 */
	GIOStatus                  (*io_seek)(GIOChannel *, gint64, GSeekType, GError * *); /*    16     8 */
	GIOStatus                  (*io_close)(GIOChannel *, GError * *); /*    24     8 */
	GSource *                  (*io_create_watch)(GIOChannel *, GIOCondition); /*    32     8 */
	void                       (*io_free)(GIOChannel *); /*    40     8 */
	GIOStatus                  (*io_set_flags)(GIOChannel *, GIOFlags, GError * *); /*    48     8 */
	GIOFlags                   (*io_get_flags)(GIOChannel *); /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
};
struct _GQueue {
	GList *                    head;                 /*     0     8 */
	GList *                    tail;                 /*     8     8 */
	guint                      length;               /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct BlockDriverState {
	int64_t                    total_sectors;        /*     0     8 */
	int                        open_flags;           /*     8     4 */
	_Bool                      read_only;            /*    12     1 */
	_Bool                      encrypted;            /*    13     1 */
	_Bool                      valid_key;            /*    14     1 */
	_Bool                      sg;                   /*    15     1 */
	_Bool                      probed;               /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        copy_on_read;         /*    20     4 */
	CoQueue                    flush_queue;          /*    24    16 */
	_Bool                      active_flush_req;     /*    40     1 */

	/* XXX 3 bytes hole, try to pack */

	unsigned int               write_gen;            /*    44     4 */
	unsigned int               flushed_gen;          /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	BlockDriver *              drv;                  /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void *                     opaque;               /*    64     8 */
	AioContext *               aio_context;          /*    72     8 */
	struct {
		struct BdrvAioNotifier * lh_first;       /*    80     8 */
	} aio_notifiers;                                 /*    80     8 */
	_Bool                      walking_aio_notifiers; /*    88     1 */
	char                       filename[4096];       /*    89  4096 */
	/* --- cacheline 65 boundary (4160 bytes) was 25 bytes ago --- */
	char                       backing_file[4096];   /*  4185  4096 */
	/* --- cacheline 129 boundary (8256 bytes) was 25 bytes ago --- */
	char                       backing_format[16];   /*  8281    16 */

	/* XXX 7 bytes hole, try to pack */

	QDict *                    full_open_options;    /*  8304     8 */
	char                       exact_filename[4096]; /*  8312  4096 */
	/* --- cacheline 193 boundary (12352 bytes) was 56 bytes ago --- */
	BdrvChild *                backing;              /* 12408     8 */
	/* --- cacheline 194 boundary (12416 bytes) --- */
	BdrvChild *                file;                 /* 12416     8 */
	NotifierWithReturnList     before_write_notifiers; /* 12424     8 */
	unsigned int               in_flight;            /* 12432     4 */
	unsigned int               serialising_in_flight; /* 12436     4 */
	_Bool                      wakeup;               /* 12440     1 */

	/* XXX 7 bytes hole, try to pack */

	uint64_t                   wr_highest_offset;    /* 12448     8 */
	BlockLimits                bl;                   /* 12456    56 */
	/* --- cacheline 195 boundary (12480 bytes) was 32 bytes ago --- */
	unsigned int               supported_write_flags; /* 12512     4 */
	unsigned int               supported_zero_flags; /* 12516     4 */
	char                       node_name[32];        /* 12520    32 */
	/* --- cacheline 196 boundary (12544 bytes) was 8 bytes ago --- */
	struct {
		struct BlockDriverState * tqe_next;      /* 12552     8 */
		struct BlockDriverState * * tqe_prev;    /* 12560     8 */
	} node_list;                                     /* 12552    16 */
	struct {
		struct BlockDriverState * tqe_next;      /* 12568     8 */
		struct BlockDriverState * * tqe_prev;    /* 12576     8 */
	} bs_list;                                       /* 12568    16 */
	struct {
		struct BlockDriverState * tqe_next;      /* 12584     8 */
		struct BlockDriverState * * tqe_prev;    /* 12592     8 */
	} monitor_list;                                  /* 12584    16 */
	struct {
		struct BdrvDirtyBitmap * lh_first;       /* 12600     8 */
	} dirty_bitmaps;                                 /* 12600     8 */
	/* --- cacheline 197 boundary (12608 bytes) --- */
	int                        refcnt;               /* 12608     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct BdrvTrackedRequest * lh_first;    /* 12616     8 */
	} tracked_requests;                              /* 12616     8 */
	struct {
		struct BdrvOpBlocker * lh_first;         /* 12624     8 */
	} op_blockers[16]; /* 12624   128 */
	/* --- cacheline 199 boundary (12736 bytes) was 16 bytes ago --- */
	BlockJob *                 job;                  /* 12752     8 */
	BlockDriverState *         inherits_from;        /* 12760     8 */
	struct {
		struct BdrvChild * lh_first;             /* 12768     8 */
	} children;                                      /* 12768     8 */
	struct {
		struct BdrvChild * lh_first;             /* 12776     8 */
	} parents;                                       /* 12776     8 */
	QDict *                    options;              /* 12784     8 */
	QDict *                    explicit_options;     /* 12792     8 */
	/* --- cacheline 200 boundary (12800 bytes) --- */
	BlockdevDetectZeroesOptions detect_zeroes;       /* 12800     4 */

	/* XXX 4 bytes hole, try to pack */

	Error *                    backing_blocker;      /* 12808     8 */
	uint64_t                   write_threshold_offset; /* 12816     8 */
	NotifierWithReturn         write_threshold_notifier; /* 12824    24 */
	unsigned int               io_plugged;           /* 12848     4 */
	unsigned int               io_plug_disabled;     /* 12852     4 */
	int                        quiesce_counter;      /* 12856     4 */

	/* size: 12864, cachelines: 201, members: 53 */
	/* sum members: 12828, holes: 7, sum holes: 32 */
	/* padding: 4 */
};
struct CharDriverState {
	QemuMutex                  chr_write_lock;       /*     0    40 */
	int                        (*chr_write)(struct CharDriverState *, const uint8_t  *, int); /*    40     8 */
	int                        (*chr_sync_read)(struct CharDriverState *, const uint8_t  *, int); /*    48     8 */
	GSource *                  (*chr_add_watch)(struct CharDriverState *, GIOCondition); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*chr_update_read_handler)(struct CharDriverState *, GMainContext *); /*    64     8 */
	int                        (*chr_ioctl)(struct CharDriverState *, int, void *); /*    72     8 */
	int                        (*get_msgfds)(struct CharDriverState *, int *, int); /*    80     8 */
	int                        (*set_msgfds)(struct CharDriverState *, int *, int); /*    88     8 */
	int                        (*chr_add_client)(struct CharDriverState *, int); /*    96     8 */
	int                        (*chr_wait_connected)(struct CharDriverState *, Error * *); /*   104     8 */
	void                       (*chr_free)(struct CharDriverState *); /*   112     8 */
	void                       (*chr_disconnect)(struct CharDriverState *); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	void                       (*chr_accept_input)(struct CharDriverState *); /*   128     8 */
	void                       (*chr_set_echo)(struct CharDriverState *, _Bool); /*   136     8 */
	void                       (*chr_set_fe_open)(struct CharDriverState *, int); /*   144     8 */
	CharBackend *              be;                   /*   152     8 */
	void *                     opaque;               /*   160     8 */
	char *                     label;                /*   168     8 */
	char *                     filename;             /*   176     8 */
	int                        logfd;                /*   184     4 */
	int                        be_open;              /*   188     4 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        is_mux;               /*   192     4 */
	guint                      fd_in_tag;            /*   196     4 */
	_Bool                      replay;               /*   200     1 */

	/* XXX 7 bytes hole, try to pack */

	long unsigned int          features[1];          /*   208     8 */
	struct {
		struct CharDriverState * tqe_next;       /*   216     8 */
		struct CharDriverState * * tqe_prev;     /*   224     8 */
	} next;                                          /*   216    16 */

	/* size: 232, cachelines: 4, members: 26 */
	/* sum members: 225, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
struct MachineClass {
	ObjectClass                parent_class;         /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	const char  *              family;               /*    96     8 */
	char *                     name;                 /*   104     8 */
	const char  *              alias;                /*   112     8 */
	const char  *              desc;                 /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	void                       (*init)(MachineState *); /*   128     8 */
	void                       (*reset)(void);       /*   136     8 */
	void                       (*hot_add_cpu)(const int64_t , Error * *); /*   144     8 */
	int                        (*kvm_type)(const char  *); /*   152     8 */
	BlockInterfaceType         block_default_type;   /*   160     4 */
	int                        units_per_default_bus; /*   164     4 */
	int                        max_cpus;             /*   168     4 */
	unsigned int               no_serial:1;          /*   172: 0  4 */
	unsigned int               no_parallel:1;        /*   172: 1  4 */
	unsigned int               use_virtcon:1;        /*   172: 2  4 */
	unsigned int               use_sclp:1;           /*   172: 3  4 */
	unsigned int               no_floppy:1;          /*   172: 4  4 */
	unsigned int               no_cdrom:1;           /*   172: 5  4 */
	unsigned int               no_sdcard:1;          /*   172: 6  4 */
	unsigned int               has_dynamic_sysbus:1; /*   172: 7  4 */
	unsigned int               pci_allow_0_address:1; /*   172: 8  4 */
	unsigned int               legacy_fw_cfg_order:1; /*   172: 9  4 */

	/* XXX 22 bits hole, try to pack */

	int                        is_default;           /*   176     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              default_machine_opts; /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	const char  *              default_boot_order;   /*   192     8 */
	const char  *              default_display;      /*   200     8 */
	GArray *                   compat_props;         /*   208     8 */
	const char  *              hw_version;           /*   216     8 */
	ram_addr_t                 default_ram_size;     /*   224     8 */
	_Bool                      option_rom_has_mr;    /*   232     1 */
	_Bool                      rom_file_has_mr;      /*   233     1 */

	/* XXX 2 bytes hole, try to pack */

	int                        minimum_page_bits;    /*   236     4 */
	HotplugHandler *           (*get_hotplug_handler)(MachineState *, DeviceState *); /*   240     8 */
	unsigned int               (*cpu_index_to_socket_id)(unsigned int); /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	CPUArchIdList *            (*possible_cpu_arch_ids)(MachineState *); /*   256     8 */
	HotpluggableCPUList *      (*query_hotpluggable_cpus)(MachineState *); /*   264     8 */

	/* size: 272, cachelines: 5, members: 36 */
	/* sum members: 262, holes: 2, sum holes: 6 */
	/* sum bitfield members: 10 bits, bit holes: 1, sum bit holes: 22 bits */
	/* last cacheline: 16 bytes */
};
struct Monitor {
	CharBackend                chr;                  /*     0    48 */
	int                        reset_seen;           /*    48     4 */
	int                        flags;                /*    52     4 */
	int                        suspend_cnt;          /*    56     4 */
	_Bool                      skip_flush;           /*    60     1 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	QemuMutex                  out_lock;             /*    64    40 */
	QString *                  outbuf;               /*   104     8 */
	guint                      out_watch;            /*   112     4 */
	int                        mux_out;              /*   116     4 */
	ReadLineState *            rs;                   /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	MonitorQMP                 qmp;                  /*   128    72 */
	/* --- cacheline 3 boundary (192 bytes) was 8 bytes ago --- */
	CPUState *                 mon_cpu;              /*   200     8 */
	BlockCompletionFunc *      password_completion_cb; /*   208     8 */
	void *                     password_opaque;      /*   216     8 */
	mon_cmd_t *                cmd_table;            /*   224     8 */
	struct {
		struct mon_fd_t *  lh_first;             /*   232     8 */
	} fds;                                           /*   232     8 */
	struct {
		struct Monitor *   le_next;              /*   240     8 */
		struct Monitor * * le_prev;              /*   248     8 */
	} entry;                                         /*   240    16 */

	/* size: 256, cachelines: 4, members: 17 */
	/* sum members: 253, holes: 1, sum holes: 3 */
};
struct MonitorDef {
	const char  *              name;                 /*     0     8 */
	int                        offset;               /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	target_long                (*get_value)(const struct MonitorDef  *, int); /*    16     8 */
	int                        type;                 /*    24     4 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 24, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct NetClientState {
	NetClientInfo *            info;                 /*     0     8 */
	int                        link_down;            /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct NetClientState * tqe_next;        /*    16     8 */
		struct NetClientState * * tqe_prev;      /*    24     8 */
	} next;                                          /*    16    16 */
	NetClientState *           peer;                 /*    32     8 */
	NetQueue *                 incoming_queue;       /*    40     8 */
	char *                     model;                /*    48     8 */
	char *                     name;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char                       info_str[256];        /*    64   256 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	unsigned int               receive_disabled:1;   /*   320: 0  4 */

	/* XXX 31 bits hole, try to pack */
	/* XXX 4 bytes hole, try to pack */

	NetClientDestructor *      destructor;           /*   328     8 */
	unsigned int               queue_index;          /*   336     4 */
	unsigned int               rxfilter_notify_enabled:1; /*   340: 0  4 */

	/* XXX 31 bits hole, try to pack */

	int                        vring_enable;         /*   344     4 */

	/* XXX 4 bytes hole, try to pack */

	struct NetFilterHead       filters;              /*   352    16 */

	/* size: 368, cachelines: 6, members: 14 */
	/* sum members: 348, holes: 3, sum holes: 12 */
	/* sum bitfield members: 2 bits, bit holes: 2, sum bit holes: 62 bits */
	/* last cacheline: 48 bytes */
};
struct QemuOptsList {
	const char  *              name;                 /*     0     8 */
	const char  *              implied_opt_name;     /*     8     8 */
	_Bool                      merge_lists;          /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	struct {
		struct QemuOpts *  tqh_first;            /*    24     8 */
		struct QemuOpts * * tqh_last;            /*    32     8 */
	} head;                                          /*    24    16 */
	QemuOptDesc                desc[];               /*    40     0 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 33, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
struct intList {
	intList *                  next;                 /*     0     8 */
	int64_t                    value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct strList {
	strList *                  next;                 /*     0     8 */
	char *                     value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct AddfdInfo {
	int64_t                    fdset_id;             /*     0     8 */
	int64_t                    fd;                   /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct ChardevBackendInfo {
	char *                     name;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct ChardevBackendInfoList {
	ChardevBackendInfoList *   next;                 /*     0     8 */
	ChardevBackendInfo *       value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct ChardevInfo {
	char *                     label;                /*     0     8 */
	char *                     filename;             /*     8     8 */
	_Bool                      frontend_open;        /*    16     1 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct ChardevInfoList {
	ChardevInfoList *          next;                 /*     0     8 */
	ChardevInfo *              value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct CommandInfo {
	char *                     name;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct CommandInfoList {
	CommandInfoList *          next;                 /*     0     8 */
	CommandInfo *              value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct CpuInstanceProperties {
	_Bool                      has_node_id;          /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    node_id;              /*     8     8 */
	_Bool                      has_socket_id;        /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    socket_id;            /*    24     8 */
	_Bool                      has_core_id;          /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    core_id;              /*    40     8 */
	_Bool                      has_thread_id;        /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    thread_id;            /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
	/* sum members: 36, holes: 4, sum holes: 28 */
};
struct EventInfo {
	char *                     name;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct EventInfoList {
	EventInfoList *            next;                 /*     0     8 */
	EventInfo *                value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct FdsetFdInfo {
	int64_t                    fd;                   /*     0     8 */
	_Bool                      has_opaque;           /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     opaque;               /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct FdsetFdInfoList {
	FdsetFdInfoList *          next;                 /*     0     8 */
	FdsetFdInfo *              value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct FdsetInfo {
	int64_t                    fdset_id;             /*     0     8 */
	FdsetFdInfoList *          fds;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct FdsetInfoList {
	FdsetInfoList *            next;                 /*     0     8 */
	FdsetInfo *                value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct GICCapability {
	int64_t                    version;              /*     0     8 */
	_Bool                      emulated;             /*     8     1 */
	_Bool                      kernel;               /*     9     1 */

	/* size: 16, cachelines: 1, members: 3 */
	/* padding: 6 */
	/* last cacheline: 16 bytes */
};
struct GICCapabilityList {
	GICCapabilityList *        next;                 /*     0     8 */
	GICCapability *            value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct HotpluggableCPU {
	char *                     type;                 /*     0     8 */
	int64_t                    vcpus_count;          /*     8     8 */
	CpuInstanceProperties *    props;                /*    16     8 */
	_Bool                      has_qom_path;         /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     qom_path;             /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 33, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
struct HotpluggableCPUList {
	HotpluggableCPUList *      next;                 /*     0     8 */
	HotpluggableCPU *          value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct ImageInfo {
	char *                     filename;             /*     0     8 */
	char *                     format;               /*     8     8 */
	_Bool                      has_dirty_flag;       /*    16     1 */
	_Bool                      dirty_flag;           /*    17     1 */
	_Bool                      has_actual_size;      /*    18     1 */

	/* XXX 5 bytes hole, try to pack */

	int64_t                    actual_size;          /*    24     8 */
	int64_t                    virtual_size;         /*    32     8 */
	_Bool                      has_cluster_size;     /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    cluster_size;         /*    48     8 */
	_Bool                      has_encrypted;        /*    56     1 */
	_Bool                      encrypted;            /*    57     1 */
	_Bool                      has_compressed;       /*    58     1 */
	_Bool                      compressed;           /*    59     1 */
	_Bool                      has_backing_filename; /*    60     1 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     backing_filename;     /*    64     8 */
	_Bool                      has_full_backing_filename; /*    72     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     full_backing_filename; /*    80     8 */
	_Bool                      has_backing_filename_format; /*    88     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     backing_filename_format; /*    96     8 */
	_Bool                      has_snapshots;        /*   104     1 */

	/* XXX 7 bytes hole, try to pack */

	SnapshotInfoList *         snapshots;            /*   112     8 */
	_Bool                      has_backing_image;    /*   120     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 2 boundary (128 bytes) --- */
	ImageInfo *                backing_image;        /*   128     8 */
	_Bool                      has_format_specific;  /*   136     1 */

	/* XXX 7 bytes hole, try to pack */

	ImageInfoSpecific *        format_specific;      /*   144     8 */

	/* size: 152, cachelines: 3, members: 25 */
	/* sum members: 102, holes: 8, sum holes: 50 */
	/* last cacheline: 24 bytes */
};
struct ImageInfoList {
	ImageInfoList *            next;                 /*     0     8 */
	ImageInfo *                value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct ImageInfoSpecific {
	ImageInfoSpecificKind      type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		q_obj_ImageInfoSpecificQCow2_wrapper qcow2; /*     8     8 */
		q_obj_ImageInfoSpecificVmdk_wrapper vmdk; /*     8     8 */
		q_obj_QCryptoBlockInfoLUKS_wrapper luks; /*     8     8 */
	} u;                                             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct ImageInfoSpecificQCow2 {
	char *                     compat;               /*     0     8 */
	_Bool                      has_lazy_refcounts;   /*     8     1 */
	_Bool                      lazy_refcounts;       /*     9     1 */
	_Bool                      has_corrupt;          /*    10     1 */
	_Bool                      corrupt;              /*    11     1 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    refcount_bits;        /*    16     8 */

	/* size: 24, cachelines: 1, members: 6 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct ImageInfoSpecificVmdk {
	char *                     create_type;          /*     0     8 */
	int64_t                    cid;                  /*     8     8 */
	int64_t                    parent_cid;           /*    16     8 */
	ImageInfoList *            extents;              /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct ObjectPropertyInfo {
	char *                     name;                 /*     0     8 */
	char *                     type;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct ObjectPropertyInfoList {
	ObjectPropertyInfoList *   next;                 /*     0     8 */
	ObjectPropertyInfo *       value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct QCryptoBlockInfoLUKS {
	QCryptoCipherAlgorithm     cipher_alg;           /*     0     4 */
	QCryptoCipherMode          cipher_mode;          /*     4     4 */
	QCryptoIVGenAlgorithm      ivgen_alg;            /*     8     4 */
	_Bool                      has_ivgen_hash_alg;   /*    12     1 */

	/* XXX 3 bytes hole, try to pack */

	QCryptoHashAlgorithm       ivgen_hash_alg;       /*    16     4 */
	QCryptoHashAlgorithm       hash_alg;             /*    20     4 */
	int64_t                    payload_offset;       /*    24     8 */
	int64_t                    master_key_iters;     /*    32     8 */
	char *                     uuid;                 /*    40     8 */
	QCryptoBlockInfoLUKSSlotList * slots;            /*    48     8 */

	/* size: 56, cachelines: 1, members: 10 */
	/* sum members: 53, holes: 1, sum holes: 3 */
	/* last cacheline: 56 bytes */
};
struct QCryptoBlockInfoLUKSSlot {
	_Bool                      active;               /*     0     1 */
	_Bool                      has_iters;            /*     1     1 */

	/* XXX 6 bytes hole, try to pack */

	int64_t                    iters;                /*     8     8 */
	_Bool                      has_stripes;          /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    stripes;              /*    24     8 */
	int64_t                    key_offset;           /*    32     8 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 27, holes: 2, sum holes: 13 */
	/* last cacheline: 40 bytes */
};
struct QCryptoBlockInfoLUKSSlotList {
	QCryptoBlockInfoLUKSSlotList * next;             /*     0     8 */
	QCryptoBlockInfoLUKSSlot * value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct RxFilterInfo {
	char *                     name;                 /*     0     8 */
	_Bool                      promiscuous;          /*     8     1 */

	/* XXX 3 bytes hole, try to pack */

	RxState                    multicast;            /*    12     4 */
	RxState                    unicast;              /*    16     4 */
	RxState                    vlan;                 /*    20     4 */
	_Bool                      broadcast_allowed;    /*    24     1 */
	_Bool                      multicast_overflow;   /*    25     1 */
	_Bool                      unicast_overflow;     /*    26     1 */

	/* XXX 5 bytes hole, try to pack */

	char *                     main_mac;             /*    32     8 */
	intList *                  vlan_table;           /*    40     8 */
	strList *                  unicast_table;        /*    48     8 */
	strList *                  multicast_table;      /*    56     8 */

	/* size: 64, cachelines: 1, members: 12 */
	/* sum members: 56, holes: 2, sum holes: 8 */
};
struct SnapshotInfo {
	char *                     id;                   /*     0     8 */
	char *                     name;                 /*     8     8 */
	int64_t                    vm_state_size;        /*    16     8 */
	int64_t                    date_sec;             /*    24     8 */
	int64_t                    date_nsec;            /*    32     8 */
	int64_t                    vm_clock_sec;         /*    40     8 */
	int64_t                    vm_clock_nsec;        /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* last cacheline: 56 bytes */
};
struct SnapshotInfoList {
	SnapshotInfoList *         next;                 /*     0     8 */
	SnapshotInfo *             value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct TraceEventInfo {
	char *                     name;                 /*     0     8 */
	TraceEventState            state;                /*     8     4 */
	_Bool                      vcpu;                 /*    12     1 */

	/* size: 16, cachelines: 1, members: 3 */
	/* padding: 3 */
	/* last cacheline: 16 bytes */
};
struct TraceEventInfoList {
	TraceEventInfoList *       next;                 /*     0     8 */
	TraceEventInfo *           value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_ImageInfoSpecificQCow2_wrapper {
	ImageInfoSpecificQCow2 *   data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_ImageInfoSpecificVmdk_wrapper {
	ImageInfoSpecificVmdk *    data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_QCryptoBlockInfoLUKS_wrapper {
	QCryptoBlockInfoLUKS *     data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct QDictEntry {
	char *                     key;                  /*     0     8 */
	QObject *                  value;                /*     8     8 */
	struct {
		struct QDictEntry * le_next;             /*    16     8 */
		struct QDictEntry * * le_prev;           /*    24     8 */
	} next;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct QDict {
	QObject                    base;                 /*     0    16 */
	size_t                     size;                 /*    16     8 */
	struct {
		struct QDictEntry * lh_first;            /*    24     8 */
	} table[512]; /*    24  4096 */

	/* size: 4120, cachelines: 65, members: 3 */
	/* last cacheline: 24 bytes */
};
struct QemuOptDesc {
	const char  *              name;                 /*     0     8 */
	enum QemuOptType           type;                 /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              help;                 /*    16     8 */
	const char  *              def_value_str;        /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct NotifierWithReturn {
	int                        (*notify)(NotifierWithReturn *, void *); /*     0     8 */
	struct {
		struct NotifierWithReturn * le_next;     /*     8     8 */
		struct NotifierWithReturn * * le_prev;   /*    16     8 */
	} node;                                          /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
struct NotifierWithReturnList {
	struct {
		struct NotifierWithReturn * lh_first;    /*     0     8 */
	} notifiers;                                     /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct QEMUIOVector {
	struct iovec *             iov;                  /*     0     8 */
	int                        niov;                 /*     8     4 */
	int                        nalloc;               /*    12     4 */
	size_t                     size;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct BlockAIOCB {
	const AIOCBInfo  *         aiocb_info;           /*     0     8 */
	BlockDriverState *         bs;                   /*     8     8 */
	BlockCompletionFunc *      cb;                   /*    16     8 */
	void *                     opaque;               /*    24     8 */
	int                        refcnt;               /*    32     4 */

	/* size: 40, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct AIOCBInfo {
	void                       (*cancel_async)(BlockAIOCB *); /*     0     8 */
	AioContext *               (*get_aio_context)(BlockAIOCB *); /*     8     8 */
	size_t                     aiocb_size;           /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct Coroutine {
	CoroutineEntry *           entry;                /*     0     8 */
	void *                     entry_arg;            /*     8     8 */
	Coroutine *                caller;               /*    16     8 */
	struct {
		struct Coroutine * sle_next;             /*    24     8 */
	} pool_next;                                     /*    24     8 */
	size_t                     locks_held;           /*    32     8 */
	struct {
		struct Coroutine * sqh_first;            /*    40     8 */
		struct Coroutine * * sqh_last;           /*    48     8 */
	} co_queue_wakeup;                               /*    40    16 */
	struct {
		struct Coroutine * sqe_next;             /*    56     8 */
	} co_queue_next;                                 /*    56     8 */

	/* size: 64, cachelines: 1, members: 7 */
};
struct CoQueue {
	struct {
		struct Coroutine * sqh_first;            /*     0     8 */
		struct Coroutine * * sqh_last;           /*     8     8 */
	} entries;                                       /*     0    16 */

	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */
};
struct BlockJob {
	const BlockJobDriver  *    driver;               /*     0     8 */
	BlockBackend *             blk;                  /*     8     8 */
	char *                     id;                   /*    16     8 */
	Coroutine *                co;                   /*    24     8 */
	_Bool                      cancelled;            /*    32     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        pause_count;          /*    36     4 */
	_Bool                      user_paused;          /*    40     1 */
	_Bool                      busy;                 /*    41     1 */
	_Bool                      paused;               /*    42     1 */
	_Bool                      ready;                /*    43     1 */
	_Bool                      deferred_to_main_loop; /*    44     1 */

	/* XXX 3 bytes hole, try to pack */

	struct {
		struct BlockJob *  le_next;              /*    48     8 */
		struct BlockJob * * le_prev;             /*    56     8 */
	} job_list;                                      /*    48    16 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	BlockDeviceIoStatus        iostatus;             /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    offset;               /*    72     8 */
	int64_t                    len;                  /*    80     8 */
	int64_t                    speed;                /*    88     8 */
	BlockCompletionFunc *      cb;                   /*    96     8 */
	Error *                    blocker;              /*   104     8 */
	GSList *                   nodes;                /*   112     8 */
	void *                     opaque;               /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int                        refcnt;               /*   128     4 */
	_Bool                      completed;            /*   132     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        ret;                  /*   136     4 */

	/* XXX 4 bytes hole, try to pack */

	BlockJobTxn *              txn;                  /*   144     8 */
	struct {
		struct BlockJob *  le_next;              /*   152     8 */
		struct BlockJob * * le_prev;             /*   160     8 */
	} txn_list;                                      /*   152    16 */

	/* size: 168, cachelines: 3, members: 25 */
	/* sum members: 151, holes: 5, sum holes: 17 */
	/* last cacheline: 40 bytes */
};
struct BlockDriver {
	const char  *              format_name;          /*     0     8 */
	int                        instance_size;        /*     8     4 */
	_Bool                      is_filter;            /*    12     1 */

	/* XXX 3 bytes hole, try to pack */

	_Bool                      (*bdrv_recurse_is_first_non_filter)(BlockDriverState *, BlockDriverState *); /*    16     8 */
	int                        (*bdrv_probe)(const uint8_t  *, int, const char  *); /*    24     8 */
	int                        (*bdrv_probe_device)(const char  *); /*    32     8 */
	void                       (*bdrv_parse_filename)(const char  *, QDict *, Error * *); /*    40     8 */
	_Bool                      bdrv_needs_filename;  /*    48     1 */
	_Bool                      supports_backing;     /*    49     1 */

	/* XXX 6 bytes hole, try to pack */

	int                        (*bdrv_reopen_prepare)(BDRVReopenState *, BlockReopenQueue *, Error * *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*bdrv_reopen_commit)(BDRVReopenState *); /*    64     8 */
	void                       (*bdrv_reopen_abort)(BDRVReopenState *); /*    72     8 */
	void                       (*bdrv_join_options)(QDict *, QDict *); /*    80     8 */
	int                        (*bdrv_open)(BlockDriverState *, QDict *, int, Error * *); /*    88     8 */
	int                        (*bdrv_file_open)(BlockDriverState *, QDict *, int, Error * *); /*    96     8 */
	void                       (*bdrv_close)(BlockDriverState *); /*   104     8 */
	int                        (*bdrv_create)(const char  *, QemuOpts *, Error * *); /*   112     8 */
	int                        (*bdrv_set_key)(BlockDriverState *, const char  *); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int                        (*bdrv_make_empty)(BlockDriverState *); /*   128     8 */
	void                       (*bdrv_refresh_filename)(BlockDriverState *, QDict *); /*   136     8 */
	BlockAIOCB *               (*bdrv_aio_readv)(BlockDriverState *, int64_t, QEMUIOVector *, int, BlockCompletionFunc *, void *); /*   144     8 */
	BlockAIOCB *               (*bdrv_aio_writev)(BlockDriverState *, int64_t, QEMUIOVector *, int, BlockCompletionFunc *, void *); /*   152     8 */
	BlockAIOCB *               (*bdrv_aio_flush)(BlockDriverState *, BlockCompletionFunc *, void *); /*   160     8 */
	BlockAIOCB *               (*bdrv_aio_pdiscard)(BlockDriverState *, int64_t, int, BlockCompletionFunc *, void *); /*   168     8 */
	int                        (*bdrv_co_readv)(BlockDriverState *, int64_t, int, QEMUIOVector *); /*   176     8 */
	int                        (*bdrv_co_preadv)(BlockDriverState *, uint64_t, uint64_t, QEMUIOVector *, int); /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        (*bdrv_co_writev)(BlockDriverState *, int64_t, int, QEMUIOVector *); /*   192     8 */
	int                        (*bdrv_co_writev_flags)(BlockDriverState *, int64_t, int, QEMUIOVector *, int); /*   200     8 */
	int                        (*bdrv_co_pwritev)(BlockDriverState *, uint64_t, uint64_t, QEMUIOVector *, int); /*   208     8 */
	int                        (*bdrv_co_pwrite_zeroes)(BlockDriverState *, int64_t, int, BdrvRequestFlags); /*   216     8 */
	int                        (*bdrv_co_pdiscard)(BlockDriverState *, int64_t, int); /*   224     8 */
	int64_t                    (*bdrv_co_get_block_status)(BlockDriverState *, int64_t, int, int *, BlockDriverState * *); /*   232     8 */
	void                       (*bdrv_invalidate_cache)(BlockDriverState *, Error * *); /*   240     8 */
	int                        (*bdrv_inactivate)(BlockDriverState *); /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	int                        (*bdrv_co_flush)(BlockDriverState *); /*   256     8 */
	int                        (*bdrv_co_flush_to_disk)(BlockDriverState *); /*   264     8 */
	int                        (*bdrv_co_flush_to_os)(BlockDriverState *); /*   272     8 */
	const char  *              protocol_name;        /*   280     8 */
	int                        (*bdrv_truncate)(BlockDriverState *, int64_t); /*   288     8 */
	int64_t                    (*bdrv_getlength)(BlockDriverState *); /*   296     8 */
	_Bool                      has_variable_length;  /*   304     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    (*bdrv_get_allocated_file_size)(BlockDriverState *); /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	int                        (*bdrv_co_pwritev_compressed)(BlockDriverState *, uint64_t, uint64_t, QEMUIOVector *); /*   320     8 */
	int                        (*bdrv_snapshot_create)(BlockDriverState *, QEMUSnapshotInfo *); /*   328     8 */
	int                        (*bdrv_snapshot_goto)(BlockDriverState *, const char  *); /*   336     8 */
	int                        (*bdrv_snapshot_delete)(BlockDriverState *, const char  *, const char  *, Error * *); /*   344     8 */
	int                        (*bdrv_snapshot_list)(BlockDriverState *, QEMUSnapshotInfo * *); /*   352     8 */
	int                        (*bdrv_snapshot_load_tmp)(BlockDriverState *, const char  *, const char  *, Error * *); /*   360     8 */
	int                        (*bdrv_get_info)(BlockDriverState *, BlockDriverInfo *); /*   368     8 */
	ImageInfoSpecific *        (*bdrv_get_specific_info)(BlockDriverState *); /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	int                        (*bdrv_save_vmstate)(BlockDriverState *, QEMUIOVector *, int64_t); /*   384     8 */
	int                        (*bdrv_load_vmstate)(BlockDriverState *, QEMUIOVector *, int64_t); /*   392     8 */
	int                        (*bdrv_change_backing_file)(BlockDriverState *, const char  *, const char  *); /*   400     8 */
	_Bool                      (*bdrv_is_inserted)(BlockDriverState *); /*   408     8 */
	int                        (*bdrv_media_changed)(BlockDriverState *); /*   416     8 */
	void                       (*bdrv_eject)(BlockDriverState *, _Bool); /*   424     8 */
	void                       (*bdrv_lock_medium)(BlockDriverState *, _Bool); /*   432     8 */
	BlockAIOCB *               (*bdrv_aio_ioctl)(BlockDriverState *, long unsigned int, void *, BlockCompletionFunc *, void *); /*   440     8 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	int                        (*bdrv_co_ioctl)(BlockDriverState *, long unsigned int, void *); /*   448     8 */
	QemuOptsList *             create_opts;          /*   456     8 */
	int                        (*bdrv_check)(BlockDriverState *, BdrvCheckResult *, BdrvCheckMode); /*   464     8 */
	int                        (*bdrv_amend_options)(BlockDriverState *, QemuOpts *, BlockDriverAmendStatusCB *, void *); /*   472     8 */
	void                       (*bdrv_debug_event)(BlockDriverState *, BlkdebugEvent); /*   480     8 */
	int                        (*bdrv_debug_breakpoint)(BlockDriverState *, const char  *, const char  *); /*   488     8 */
	int                        (*bdrv_debug_remove_breakpoint)(BlockDriverState *, const char  *); /*   496     8 */
	int                        (*bdrv_debug_resume)(BlockDriverState *, const char  *); /*   504     8 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	_Bool                      (*bdrv_debug_is_suspended)(BlockDriverState *, const char  *); /*   512     8 */
	void                       (*bdrv_refresh_limits)(BlockDriverState *, Error * *); /*   520     8 */
	int                        (*bdrv_has_zero_init)(BlockDriverState *); /*   528     8 */
	void                       (*bdrv_detach_aio_context)(BlockDriverState *); /*   536     8 */
	void                       (*bdrv_attach_aio_context)(BlockDriverState *, AioContext *); /*   544     8 */
	void                       (*bdrv_io_plug)(BlockDriverState *); /*   552     8 */
	void                       (*bdrv_io_unplug)(BlockDriverState *); /*   560     8 */
	int                        (*bdrv_probe_blocksizes)(BlockDriverState *, BlockSizes *); /*   568     8 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	int                        (*bdrv_probe_geometry)(BlockDriverState *, HDGeometry *); /*   576     8 */
	void                       (*bdrv_drain)(BlockDriverState *); /*   584     8 */
	void                       (*bdrv_add_child)(BlockDriverState *, BlockDriverState *, Error * *); /*   592     8 */
	void                       (*bdrv_del_child)(BlockDriverState *, BdrvChild *, Error * *); /*   600     8 */
	struct {
		struct BlockDriver * le_next;            /*   608     8 */
		struct BlockDriver * * le_prev;          /*   616     8 */
	} list;                                          /*   608    16 */

	/* size: 624, cachelines: 10, members: 79 */
	/* sum members: 608, holes: 3, sum holes: 16 */
	/* last cacheline: 48 bytes */
};
struct BdrvChild {
	BlockDriverState *         bs;                   /*     0     8 */
	char *                     name;                 /*     8     8 */
	const BdrvChildRole  *     role;                 /*    16     8 */
	void *                     opaque;               /*    24     8 */
	struct {
		struct BdrvChild * le_next;              /*    32     8 */
		struct BdrvChild * * le_prev;            /*    40     8 */
	} next;                                          /*    32    16 */
	struct {
		struct BdrvChild * le_next;              /*    48     8 */
		struct BdrvChild * * le_prev;            /*    56     8 */
	} next_parent;                                   /*    48    16 */

	/* size: 64, cachelines: 1, members: 6 */
};
struct BdrvChildRole {
	void                       (*inherit_options)(int *, QDict *, int, QDict *); /*     0     8 */
	void                       (*change_media)(BdrvChild *, _Bool); /*     8     8 */
	void                       (*resize)(BdrvChild *); /*    16     8 */
	const char  *              (*get_name)(BdrvChild *); /*    24     8 */
	void                       (*drained_begin)(BdrvChild *); /*    32     8 */
	void                       (*drained_end)(BdrvChild *); /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct BlockDriverInfo {
	int                        cluster_size;         /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    vm_state_offset;      /*     8     8 */
	_Bool                      is_dirty;             /*    16     1 */
	_Bool                      unallocated_blocks_are_zero; /*    17     1 */
	_Bool                      can_write_zeroes_with_unmap; /*    18     1 */
	_Bool                      needs_compressed_writes; /*    19     1 */

	/* size: 24, cachelines: 1, members: 6 */
	/* sum members: 16, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct BlockFragInfo {
	uint64_t                   allocated_clusters;   /*     0     8 */
	uint64_t                   total_clusters;       /*     8     8 */
	uint64_t                   fragmented_clusters;  /*    16     8 */
	uint64_t                   compressed_clusters;  /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct BlockSizes {
	uint32_t                   phys;                 /*     0     4 */
	uint32_t                   log;                  /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct HDGeometry {
	uint32_t                   heads;                /*     0     4 */
	uint32_t                   sectors;              /*     4     4 */
	uint32_t                   cylinders;            /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
struct BlockReopenQueue {
	struct BlockReopenQueueEntry * sqh_first;        /*     0     8 */
	struct BlockReopenQueueEntry * * sqh_last;       /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BDRVReopenState {
	BlockDriverState *         bs;                   /*     0     8 */
	int                        flags;                /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	QDict *                    options;              /*    16     8 */
	QDict *                    explicit_options;     /*    24     8 */
	void *                     opaque;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct BdrvCheckResult {
	int                        corruptions;          /*     0     4 */
	int                        leaks;                /*     4     4 */
	int                        check_errors;         /*     8     4 */
	int                        corruptions_fixed;    /*    12     4 */
	int                        leaks_fixed;          /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    image_end_offset;     /*    24     8 */
	BlockFragInfo              bfi;                  /*    32    32 */

	/* size: 64, cachelines: 1, members: 7 */
	/* sum members: 60, holes: 1, sum holes: 4 */
};
struct BdrvNextIterator {
	enum {
		BDRV_NEXT_BACKEND_ROOTS = 0,
		BDRV_NEXT_MONITOR_OWNED = 1,
	} phase;                                         /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	BlockBackend *             blk;                  /*     8     8 */
	BlockDriverState *         bs;                   /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct NetClientInfo {
	NetClientDriver            type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     size;                 /*     8     8 */
	NetReceive *               receive;              /*    16     8 */
	NetReceive *               receive_raw;          /*    24     8 */
	NetReceiveIOV *            receive_iov;          /*    32     8 */
	NetCanReceive *            can_receive;          /*    40     8 */
	NetCleanup *               cleanup;              /*    48     8 */
	LinkStatusChanged *        link_status_changed;  /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	QueryRxFilter *            query_rx_filter;      /*    64     8 */
	NetPoll *                  poll;                 /*    72     8 */
	HasUfo *                   has_ufo;              /*    80     8 */
	HasVnetHdr *               has_vnet_hdr;         /*    88     8 */
	HasVnetHdrLen *            has_vnet_hdr_len;     /*    96     8 */
	UsingVnetHdr *             using_vnet_hdr;       /*   104     8 */
	SetOffload *               set_offload;          /*   112     8 */
	SetVnetHdrLen *            set_vnet_hdr_len;     /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	SetVnetLE *                set_vnet_le;          /*   128     8 */
	SetVnetBE *                set_vnet_be;          /*   136     8 */

	/* size: 144, cachelines: 3, members: 18 */
	/* sum members: 140, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct NetFilterHead {
	struct NetFilterState *    tqh_first;            /*     0     8 */
	struct NetFilterState * *  tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct QString {
	QObject                    base;                 /*     0    16 */
	char *                     string;               /*    16     8 */
	size_t                     length;               /*    24     8 */
	size_t                     capacity;             /*    32     8 */

	/* size: 40, cachelines: 1, members: 4 */
	/* last cacheline: 40 bytes */
};
struct CharBackend {
	CharDriverState *          chr;                  /*     0     8 */
	IOEventHandler *           chr_event;            /*     8     8 */
	IOCanReadHandler *         chr_can_read;         /*    16     8 */
	IOReadHandler *            chr_read;             /*    24     8 */
	void *                     opaque;               /*    32     8 */
	int                        tag;                  /*    40     4 */
	int                        fe_open;              /*    44     4 */

	/* size: 48, cachelines: 1, members: 7 */
	/* last cacheline: 48 bytes */
};
struct ReadLineState {
	char                       cmd_buf[4096];        /*     0  4096 */
	/* --- cacheline 64 boundary (4096 bytes) --- */
	int                        cmd_buf_index;        /*  4096     4 */
	int                        cmd_buf_size;         /*  4100     4 */
	char                       last_cmd_buf[4096];   /*  4104  4096 */
	/* --- cacheline 128 boundary (8192 bytes) was 8 bytes ago --- */
	int                        last_cmd_buf_index;   /*  8200     4 */
	int                        last_cmd_buf_size;    /*  8204     4 */
	int                        esc_state;            /*  8208     4 */
	int                        esc_param;            /*  8212     4 */
	char *                     history[64];          /*  8216   512 */
	/* --- cacheline 136 boundary (8704 bytes) was 24 bytes ago --- */
	int                        hist_entry;           /*  8728     4 */

	/* XXX 4 bytes hole, try to pack */

	ReadLineCompletionFunc *   completion_finder;    /*  8736     8 */
	char *                     completions[256];     /*  8744  2048 */
	/* --- cacheline 168 boundary (10752 bytes) was 40 bytes ago --- */
	int                        nb_completions;       /* 10792     4 */
	int                        completion_index;     /* 10796     4 */
	ReadLineFunc *             readline_func;        /* 10800     8 */
	void *                     readline_opaque;      /* 10808     8 */
	/* --- cacheline 169 boundary (10816 bytes) --- */
	int                        read_password;        /* 10816     4 */
	char                       prompt[256];          /* 10820   256 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 173 boundary (11072 bytes) was 8 bytes ago --- */
	ReadLinePrintfFunc *       printf_func;          /* 11080     8 */
	ReadLineFlushFunc *        flush_func;           /* 11088     8 */
	void *                     opaque;               /* 11096     8 */

	/* size: 11104, cachelines: 174, members: 21 */
	/* sum members: 11096, holes: 2, sum holes: 8 */
	/* last cacheline: 32 bytes */
};
struct QEMUSnapshotInfo {
	char                       id_str[128];          /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	char                       name[256];            /*   128   256 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	uint64_t                   vm_state_size;        /*   384     8 */
	uint32_t                   date_sec;             /*   392     4 */
	uint32_t                   date_nsec;            /*   396     4 */
	uint64_t                   vm_clock_nsec;        /*   400     8 */

	/* size: 408, cachelines: 7, members: 6 */
	/* last cacheline: 24 bytes */
};
struct BdrvTrackedRequest {
	BlockDriverState *         bs;                   /*     0     8 */
	int64_t                    offset;               /*     8     8 */
	unsigned int               bytes;                /*    16     4 */
	enum BdrvTrackedRequestType type;                /*    20     4 */
	_Bool                      serialising;          /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    overlap_offset;       /*    32     8 */
	unsigned int               overlap_bytes;        /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct BdrvTrackedRequest * le_next;     /*    48     8 */
		struct BdrvTrackedRequest * * le_prev;   /*    56     8 */
	} list;                                          /*    48    16 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	Coroutine *                co;                   /*    64     8 */
	CoQueue                    wait_queue;           /*    72    16 */
	struct BdrvTrackedRequest * waiting_for;         /*    88     8 */

	/* size: 96, cachelines: 2, members: 11 */
	/* sum members: 85, holes: 2, sum holes: 11 */
	/* last cacheline: 32 bytes */
};
struct BlockLimits {
	uint32_t                   request_alignment;    /*     0     4 */
	int32_t                    max_pdiscard;         /*     4     4 */
	uint32_t                   pdiscard_alignment;   /*     8     4 */
	int32_t                    max_pwrite_zeroes;    /*    12     4 */
	uint32_t                   pwrite_zeroes_alignment; /*    16     4 */
	uint32_t                   opt_transfer;         /*    20     4 */
	uint32_t                   max_transfer;         /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     min_mem_alignment;    /*    32     8 */
	size_t                     opt_mem_alignment;    /*    40     8 */
	int                        max_iov;              /*    48     4 */

	/* size: 56, cachelines: 1, members: 10 */
	/* sum members: 48, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct BdrvAioNotifier {
	void                       (*attached_aio_context)(AioContext *, void *); /*     0     8 */
	void                       (*detach_aio_context)(void *); /*     8     8 */
	void *                     opaque;               /*    16     8 */
	_Bool                      deleted;              /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	struct {
		struct BdrvAioNotifier * le_next;        /*    32     8 */
		struct BdrvAioNotifier * * le_prev;      /*    40     8 */
	} list;                                          /*    32    16 */

	/* size: 48, cachelines: 1, members: 5 */
	/* sum members: 41, holes: 1, sum holes: 7 */
	/* last cacheline: 48 bytes */
};
struct capture_ops {
	void                       (*info)(void *);      /*     0     8 */
	void                       (*destroy)(void *);   /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct CaptureState {
	void *                     opaque;               /*     0     8 */
	struct capture_ops         ops;                  /*     8    16 */
	struct {
		struct CaptureState * le_next;           /*    24     8 */
		struct CaptureState * * le_prev;         /*    32     8 */
	} entries;                                       /*    24    16 */

	/* size: 40, cachelines: 1, members: 3 */
	/* last cacheline: 40 bytes */
};
struct qemu_acl_entry {
	char *                     match;                /*     0     8 */
	int                        deny;                 /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct qemu_acl_entry * tqe_next;        /*    16     8 */
		struct qemu_acl_entry * * tqe_prev;      /*    24     8 */
	} next;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct qemu_acl {
	char *                     aclname;              /*     0     8 */
	unsigned int               nentries;             /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct qemu_acl_entry * tqh_first;       /*    16     8 */
		struct qemu_acl_entry * * tqh_last;      /*    24     8 */
	} entries;                                       /*    16    16 */
	int                        defaultDeny;          /*    32     4 */

	/* size: 40, cachelines: 1, members: 4 */
	/* sum members: 32, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct QInt {
	QObject                    base;                 /*     0    16 */
	int64_t                    value;                /*    16     8 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
struct QFloat {
	QObject                    base;                 /*     0    16 */
	double                     value;                /*    16     8 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
struct QBool {
	QObject                    base;                 /*     0    16 */
	_Bool                      value;                /*    16     1 */

	/* size: 24, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct JSONLexer {
	JSONLexerEmitter *         emit;                 /*     0     8 */
	int                        state;                /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	GString *                  token;                /*    16     8 */
	int                        x;                    /*    24     4 */
	int                        y;                    /*    28     4 */

	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct JSONMessageParser {
	void                       (*emit)(struct JSONMessageParser *, GQueue *); /*     0     8 */
	JSONLexer                  lexer;                /*     8    32 */
	int                        brace_count;          /*    40     4 */
	int                        bracket_count;        /*    44     4 */
	GQueue *                   tokens;               /*    48     8 */
	uint64_t                   token_size;           /*    56     8 */

	/* size: 64, cachelines: 1, members: 6 */
};
struct TraceEventIter {
	size_t                     event;                /*     0     8 */
	size_t                     group;                /*     8     8 */
	const char  *              pattern;              /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct QEMULogItem {
	int                        mask;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              name;                 /*     8     8 */
	const char  *              help;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct QmpCommand {
	const char  *              name;                 /*     0     8 */
	QmpCommandFunc *           fn;                   /*     8     8 */
	QmpCommandOptions          options;              /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct QmpCommand * tqe_next;            /*    24     8 */
		struct QmpCommand * * tqe_prev;          /*    32     8 */
	} node;                                          /*    24    16 */
	_Bool                      enabled;              /*    40     1 */

	/* size: 48, cachelines: 1, members: 5 */
	/* sum members: 37, holes: 1, sum holes: 4 */
	/* padding: 7 */
	/* last cacheline: 48 bytes */
};
struct mon_cmd_t {
	const char  *              name;                 /*     0     8 */
	const char  *              args_type;            /*     8     8 */
	const char  *              params;               /*    16     8 */
	const char  *              help;                 /*    24     8 */
	void                       (*cmd)(Monitor *, const QDict  *); /*    32     8 */
	struct mon_cmd_t *         sub_table;            /*    40     8 */
	void                       (*command_completion)(ReadLineState *, int, const char  *); /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* last cacheline: 56 bytes */
};
struct mon_fd_t {
	char *                     name;                 /*     0     8 */
	int                        fd;                   /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct mon_fd_t *  le_next;              /*    16     8 */
		struct mon_fd_t * * le_prev;             /*    24     8 */
	} next;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct MonFdsetFd {
	int                        fd;                   /*     0     4 */
	_Bool                      removed;              /*     4     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     opaque;               /*     8     8 */
	struct {
		struct MonFdsetFd * le_next;             /*    16     8 */
		struct MonFdsetFd * * le_prev;           /*    24     8 */
	} next;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 29, holes: 1, sum holes: 3 */
	/* last cacheline: 32 bytes */
};
struct MonFdset {
	int64_t                    id;                   /*     0     8 */
	struct {
		struct MonFdsetFd * lh_first;            /*     8     8 */
	} fds;                                           /*     8     8 */
	struct {
		struct MonFdsetFd * lh_first;            /*    16     8 */
	} dup_fds;                                       /*    16     8 */
	struct {
		struct MonFdset *  le_next;              /*    24     8 */
		struct MonFdset * * le_prev;             /*    32     8 */
	} next;                                          /*    24    16 */

	/* size: 40, cachelines: 1, members: 4 */
	/* last cacheline: 40 bytes */
};
struct MonitorQAPIEventState {
	QAPIEvent                  event;                /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	QDict *                    data;                 /*     8     8 */
	QEMUTimer *                timer;                /*    16     8 */
	QDict *                    qdict;                /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct mon_list {
	struct Monitor *           lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct mon_fdsets {
	struct MonFdset *          lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct capture_list_head {
	struct CaptureState *      lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct ChardevCommon {
	_Bool                      has_logfile;          /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     logfile;              /*     8     8 */
	_Bool                      has_logappend;        /*    16     1 */
	_Bool                      logappend;            /*    17     1 */

	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 11, holes: 1, sum holes: 7 */
	/* padding: 6 */
	/* last cacheline: 24 bytes */
};
struct GDBRegisterState {
	int                        base_reg;             /*     0     4 */
	int                        num_regs;             /*     4     4 */
	gdb_reg_cb                 get_reg;              /*     8     8 */
	gdb_reg_cb                 set_reg;              /*    16     8 */
	const char  *              xml;                  /*    24     8 */
	struct GDBRegisterState *  next;                 /*    32     8 */

	/* size: 40, cachelines: 1, members: 6 */
	/* last cacheline: 40 bytes */
};
struct GDBState {
	CPUState *                 c_cpu;                /*     0     8 */
	CPUState *                 g_cpu;                /*     8     8 */
	CPUState *                 query_cpu;            /*    16     8 */
	enum RSState               state;                /*    24     4 */
	char                       line_buf[4096];       /*    28  4096 */
	/* --- cacheline 64 boundary (4096 bytes) was 28 bytes ago --- */
	int                        line_buf_index;       /*  4124     4 */
	int                        line_csum;            /*  4128     4 */
	uint8_t                    last_packet[4100];    /*  4132  4100 */
	/* --- cacheline 128 boundary (8192 bytes) was 40 bytes ago --- */
	int                        last_packet_len;      /*  8232     4 */
	int                        signal;               /*  8236     4 */
	CharBackend                chr;                  /*  8240    48 */
	/* --- cacheline 129 boundary (8256 bytes) was 32 bytes ago --- */
	CharDriverState *          mon_chr;              /*  8288     8 */
	char                       syscall_buf[256];     /*  8296   256 */
	/* --- cacheline 133 boundary (8512 bytes) was 40 bytes ago --- */
	gdb_syscall_complete_cb    current_syscall_cb;   /*  8552     8 */

	/* size: 8560, cachelines: 134, members: 14 */
	/* last cacheline: 48 bytes */
};
struct BalloonInfo {
	int64_t                    actual;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct MemoryRegionPortio {
	uint32_t                   offset;               /*     0     4 */
	uint32_t                   len;                  /*     4     4 */
	unsigned int               size;                 /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	uint32_t                   (*read)(void *, uint32_t); /*    16     8 */
	void                       (*write)(void *, uint32_t, uint32_t); /*    24     8 */
	uint32_t                   base;                 /*    32     4 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 32, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct PortioList {
	const struct MemoryRegionPortio  * ports;        /*     0     8 */
	Object *                   owner;                /*     8     8 */
	struct MemoryRegion *      address_space;        /*    16     8 */
	unsigned int               nr;                   /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	struct MemoryRegion * *    regions;              /*    32     8 */
	void *                     opaque;               /*    40     8 */
	const char  *              name;                 /*    48     8 */
	_Bool                      flush_coalesced_mmio; /*    56     1 */

	/* size: 64, cachelines: 1, members: 8 */
	/* sum members: 53, holes: 1, sum holes: 4 */
	/* padding: 7 */
};
struct MemoryRegionPortioList {
	MemoryRegion               mr;                   /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	void *                     portio_opaque;        /*   256     8 */
	MemoryRegionPortio         ports[];              /*   264     0 */

	/* size: 272, cachelines: 5, members: 3 */
	/* padding: 8 */
	/* last cacheline: 16 bytes */
};
struct uint16List {
	uint16List *               next;                 /*     0     8 */
	uint16_t                   value;                /*     8     2 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 6 */
	/* last cacheline: 16 bytes */
};
struct Memdev {
	uint64_t                   size;                 /*     0     8 */
	_Bool                      merge;                /*     8     1 */
	_Bool                      dump;                 /*     9     1 */
	_Bool                      prealloc;             /*    10     1 */

	/* XXX 5 bytes hole, try to pack */

	uint16List *               host_nodes;           /*    16     8 */
	HostMemPolicy              policy;               /*    24     4 */

	/* size: 32, cachelines: 1, members: 6 */
	/* sum members: 23, holes: 1, sum holes: 5 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct MemdevList {
	MemdevList *               next;                 /*     0     8 */
	Memdev *                   value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct MemoryDeviceInfo {
	MemoryDeviceInfoKind       type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		q_obj_PCDIMMDeviceInfo_wrapper dimm;     /*     8     8 */
	} u;                                             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct MemoryDeviceInfoList {
	MemoryDeviceInfoList *     next;                 /*     0     8 */
	MemoryDeviceInfo *         value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct NumaNodeOptions {
	_Bool                      has_nodeid;           /*     0     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   nodeid;               /*     2     2 */
	_Bool                      has_cpus;             /*     4     1 */

	/* XXX 3 bytes hole, try to pack */

	uint16List *               cpus;                 /*     8     8 */
	_Bool                      has_mem;              /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	uint64_t                   mem;                  /*    24     8 */
	_Bool                      has_memdev;           /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     memdev;               /*    40     8 */

	/* size: 48, cachelines: 1, members: 8 */
	/* sum members: 30, holes: 4, sum holes: 18 */
	/* last cacheline: 48 bytes */
};
struct NumaOptions {
	NumaOptionsKind            type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		q_obj_NumaNodeOptions_wrapper node;      /*     8     8 */
	} u;                                             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct PCDIMMDeviceInfo {
	_Bool                      has_id;               /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     id;                   /*     8     8 */
	int64_t                    addr;                 /*    16     8 */
	int64_t                    size;                 /*    24     8 */
	int64_t                    slot;                 /*    32     8 */
	int64_t                    node;                 /*    40     8 */
	char *                     memdev;               /*    48     8 */
	_Bool                      hotplugged;           /*    56     1 */
	_Bool                      hotpluggable;         /*    57     1 */

	/* size: 64, cachelines: 1, members: 9 */
	/* sum members: 51, holes: 1, sum holes: 7 */
	/* padding: 6 */
};
struct q_obj_NumaNodeOptions_wrapper {
	NumaNodeOptions *          data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_PCDIMMDeviceInfo_wrapper {
	PCDIMMDeviceInfo *         data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct HostMemoryBackend {
	Object                     parent;               /*     0    40 */
	uint64_t                   size;                 /*    40     8 */
	_Bool                      merge;                /*    48     1 */
	_Bool                      dump;                 /*    49     1 */
	_Bool                      prealloc;             /*    50     1 */
	_Bool                      force_prealloc;       /*    51     1 */
	_Bool                      is_mapped;            /*    52     1 */

	/* XXX 3 bytes hole, try to pack */

	long unsigned int          host_nodes[3];        /*    56    24 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	HostMemPolicy              policy;               /*    80     4 */

	/* XXX 12 bytes hole, try to pack */

	MemoryRegion               mr;                   /*    96   256 */

	/* size: 352, cachelines: 6, members: 10 */
	/* sum members: 337, holes: 2, sum holes: 15 */
	/* last cacheline: 32 bytes */
};
struct numa_addr_range {
	ram_addr_t                 mem_start;            /*     0     8 */
	ram_addr_t                 mem_end;              /*     8     8 */
	struct {
		struct numa_addr_range * le_next;        /*    16     8 */
		struct numa_addr_range * * le_prev;      /*    24     8 */
	} entry;                                         /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct node_info {
	uint64_t                   node_mem;             /*     0     8 */
	long unsigned int          node_cpu[5];          /*     8    40 */
	struct HostMemoryBackend * node_memdev;          /*    48     8 */
	_Bool                      present;              /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	struct {
		struct numa_addr_range * lh_first;       /*    64     8 */
	} addr;                                          /*    64     8 */

	/* size: 72, cachelines: 2, members: 5 */
	/* sum members: 65, holes: 1, sum holes: 7 */
	/* last cacheline: 8 bytes */
};
struct TypeInfo {
	const char  *              name;                 /*     0     8 */
	const char  *              parent;               /*     8     8 */
	size_t                     instance_size;        /*    16     8 */
	void                       (*instance_init)(Object *); /*    24     8 */
	void                       (*instance_post_init)(Object *); /*    32     8 */
	void                       (*instance_finalize)(Object *); /*    40     8 */
	_Bool                      abstract;             /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	size_t                     class_size;           /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*class_init)(ObjectClass *, void *); /*    64     8 */
	void                       (*class_base_init)(ObjectClass *, void *); /*    72     8 */
	void                       (*class_finalize)(ObjectClass *, void *); /*    80     8 */
	void *                     class_data;           /*    88     8 */
	InterfaceInfo *            interfaces;           /*    96     8 */

	/* size: 104, cachelines: 2, members: 13 */
	/* sum members: 97, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
struct InterfaceInfo {
	const char  *              type;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct AccelClass {
	ObjectClass                parent_class;         /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	const char  *              opt_name;             /*    96     8 */
	const char  *              name;                 /*   104     8 */
	int                        (*available)(void);   /*   112     8 */
	int                        (*init_machine)(MachineState *); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	_Bool *                    allowed;              /*   128     8 */

	/* size: 136, cachelines: 3, members: 6 */
	/* last cacheline: 8 bytes */
};
struct ObjectProperty {
	gchar *                    name;                 /*     0     8 */
	gchar *                    type;                 /*     8     8 */
	gchar *                    description;          /*    16     8 */
	ObjectPropertyAccessor *   get;                  /*    24     8 */
	ObjectPropertyAccessor *   set;                  /*    32     8 */
	ObjectPropertyResolve *    resolve;              /*    40     8 */
	ObjectPropertyRelease *    release;              /*    48     8 */
	void *                     opaque;               /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
};
struct FWBootEntry {
	struct {
		struct FWBootEntry * tqe_next;           /*     0     8 */
		struct FWBootEntry * * tqe_prev;         /*     8     8 */
	} link;                                          /*     0    16 */
	int32_t                    bootindex;            /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	DeviceState *              dev;                  /*    24     8 */
	char *                     suffix;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 4 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct AdapterInfo {
	uint64_t                   ind_addr;             /*     0     8 */
	uint64_t                   summary_addr;         /*     8     8 */
	uint64_t                   ind_offset;           /*    16     8 */
	uint32_t                   summary_offset;       /*    24     4 */
	uint32_t                   adapter_id;           /*    28     4 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct MSIMessage {
	uint64_t                   address;              /*     0     8 */
	uint32_t                   data;                 /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct PCIDevice {
	DeviceState                qdev;                 /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	uint8_t *                  config;               /*   112     8 */
	uint8_t *                  cmask;                /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint8_t *                  wmask;                /*   128     8 */
	uint8_t *                  w1cmask;              /*   136     8 */
	uint8_t *                  used;                 /*   144     8 */
	PCIBus *                   bus;                  /*   152     8 */
	int32_t                    devfn;                /*   160     4 */

	/* XXX 4 bytes hole, try to pack */

	PCIReqIDCache              requester_id_cache;   /*   168    16 */
	char                       name[64];             /*   184    64 */
	/* --- cacheline 3 boundary (192 bytes) was 56 bytes ago --- */
	PCIIORegion                io_regions[7];        /*   248   280 */
	/* --- cacheline 8 boundary (512 bytes) was 16 bytes ago --- */
	AddressSpace               bus_master_as;        /*   528   272 */
	/* --- cacheline 12 boundary (768 bytes) was 32 bytes ago --- */
	MemoryRegion               bus_master_enable_region; /*   800   256 */
	/* --- cacheline 16 boundary (1024 bytes) was 32 bytes ago --- */
	PCIConfigReadFunc *        config_read;          /*  1056     8 */
	PCIConfigWriteFunc *       config_write;         /*  1064     8 */
	MemoryRegion *             vga_regions[3];       /*  1072    24 */
	/* --- cacheline 17 boundary (1088 bytes) was 8 bytes ago --- */
	_Bool                      has_vga;              /*  1096     1 */
	uint8_t                    irq_state;            /*  1097     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   cap_present;          /*  1100     4 */
	uint8_t                    msix_cap;             /*  1104     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        msix_entries_nr;      /*  1108     4 */
	uint8_t *                  msix_table;           /*  1112     8 */
	uint8_t *                  msix_pba;             /*  1120     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               msix_exclusive_bar;   /*  1136   256 */
	/* --- cacheline 21 boundary (1344 bytes) was 48 bytes ago --- */
	MemoryRegion               msix_table_mmio;      /*  1392   256 */
	/* --- cacheline 25 boundary (1600 bytes) was 48 bytes ago --- */
	MemoryRegion               msix_pba_mmio;        /*  1648   256 */
	/* --- cacheline 29 boundary (1856 bytes) was 48 bytes ago --- */
	unsigned int *             msix_entry_used;      /*  1904     8 */
	_Bool                      msix_function_masked; /*  1912     1 */

	/* XXX 3 bytes hole, try to pack */

	int32_t                    version_id;           /*  1916     4 */
	/* --- cacheline 30 boundary (1920 bytes) --- */
	uint8_t                    msi_cap;              /*  1920     1 */

	/* XXX 7 bytes hole, try to pack */

	PCIExpressDevice           exp;                  /*  1928    24 */
	SHPCDevice *               shpc;                 /*  1952     8 */
	char *                     romfile;              /*  1960     8 */
	_Bool                      has_rom;              /*  1968     1 */

	/* XXX 15 bytes hole, try to pack */

	/* --- cacheline 31 boundary (1984 bytes) --- */
	MemoryRegion               rom;                  /*  1984   256 */
	/* --- cacheline 35 boundary (2240 bytes) --- */
	uint32_t                   rom_bar;              /*  2240     4 */

	/* XXX 4 bytes hole, try to pack */

	PCIINTxRoutingNotifier     intx_routing_notifier; /*  2248     8 */
	MSIVectorUseNotifier       msix_vector_use_notifier; /*  2256     8 */
	MSIVectorReleaseNotifier   msix_vector_release_notifier; /*  2264     8 */
	MSIVectorPollNotifier      msix_vector_poll_notifier; /*  2272     8 */

	/* size: 2288, cachelines: 36, members: 40 */
	/* sum members: 2234, holes: 8, sum holes: 46 */
	/* padding: 8 */
	/* last cacheline: 48 bytes */
};
struct PCIEAERErr {
	uint32_t                   status;               /*     0     4 */
	uint16_t                   source_id;            /*     4     2 */
	uint16_t                   flags;                /*     6     2 */
	uint32_t                   header[4];            /*     8    16 */
	uint32_t                   prefix[4];            /*    24    16 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct PCIEAERLog {
	uint16_t                   log_num;              /*     0     2 */
	uint16_t                   log_max;              /*     2     2 */

	/* XXX 4 bytes hole, try to pack */

	PCIEAERErr *               log;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct PCIExpressDevice {
	uint8_t                    exp_cap;              /*     0     1 */
	_Bool                      hpev_notified;        /*     1     1 */
	uint16_t                   aer_cap;              /*     2     2 */

	/* XXX 4 bytes hole, try to pack */

	PCIEAERLog                 aer_log;              /*     8    16 */

	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct kvm_guest_debug_arch {
	__u64                      debugreg[8];          /*     0    64 */

	/* size: 64, cachelines: 1, members: 1 */
};
struct kvm_userspace_memory_region {
	__u32                      slot;                 /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u64                      guest_phys_addr;      /*     8     8 */
	__u64                      memory_size;          /*    16     8 */
	__u64                      userspace_addr;       /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct kvm_irq_level {
	union {
		__u32              irq;                  /*     0     4 */
		__s32              status;               /*     0     4 */
	};                                               /*     0     4 */
	__u32                      level;                /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct kvm_coalesced_mmio_zone {
	__u64                      addr;                 /*     0     8 */
	__u32                      size;                 /*     8     4 */
	__u32                      pad;                  /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct kvm_coalesced_mmio {
	__u64                      phys_addr;            /*     0     8 */
	__u32                      len;                  /*     8     4 */
	__u32                      pad;                  /*    12     4 */
	__u8                       data[8];              /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct kvm_coalesced_mmio_ring {
	__u32                      first;                /*     0     4 */
	__u32                      last;                 /*     4     4 */
	struct kvm_coalesced_mmio  coalesced_mmio[];     /*     8     0 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct kvm_dirty_log {
	__u32                      slot;                 /*     0     4 */
	__u32                      padding1;             /*     4     4 */
	union {
		void *             dirty_bitmap;         /*     8     8 */
		__u64              padding2;             /*     8     8 */
	};                                               /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct kvm_signal_mask {
	__u32                      len;                  /*     0     4 */
	__u8                       sigset[];             /*     4     0 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
struct kvm_guest_debug {
	__u32                      control;              /*     0     4 */
	__u32                      pad;                  /*     4     4 */
	struct kvm_guest_debug_arch arch;                /*     8    64 */

	/* size: 72, cachelines: 2, members: 3 */
	/* last cacheline: 8 bytes */
};
struct kvm_ioeventfd {
	__u64                      datamatch;            /*     0     8 */
	__u64                      addr;                 /*     8     8 */
	__u32                      len;                  /*    16     4 */
	__s32                      fd;                   /*    20     4 */
	__u32                      flags;                /*    24     4 */
	__u8                       pad[36];              /*    28    36 */

	/* size: 64, cachelines: 1, members: 6 */
};
struct kvm_enable_cap {
	__u32                      cap;                  /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u64                      args[4];              /*     8    32 */
	__u8                       pad[64];              /*    40    64 */

	/* size: 104, cachelines: 2, members: 4 */
	/* last cacheline: 40 bytes */
};
struct kvm_irq_routing_irqchip {
	__u32                      irqchip;              /*     0     4 */
	__u32                      pin;                  /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct kvm_irq_routing_msi {
	__u32                      address_lo;           /*     0     4 */
	__u32                      address_hi;           /*     4     4 */
	__u32                      data;                 /*     8     4 */
	union {
		__u32              pad;                  /*    12     4 */
		__u32              devid;                /*    12     4 */
	};                                               /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct kvm_irq_routing_s390_adapter {
	__u64                      ind_addr;             /*     0     8 */
	__u64                      summary_addr;         /*     8     8 */
	__u64                      ind_offset;           /*    16     8 */
	__u32                      summary_offset;       /*    24     4 */
	__u32                      adapter_id;           /*    28     4 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct kvm_irq_routing_hv_sint {
	__u32                      vcpu;                 /*     0     4 */
	__u32                      sint;                 /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct kvm_irq_routing_entry {
	__u32                      gsi;                  /*     0     4 */
	__u32                      type;                 /*     4     4 */
	__u32                      flags;                /*     8     4 */
	__u32                      pad;                  /*    12     4 */
	union {
		struct kvm_irq_routing_irqchip irqchip;  /*    16     8 */
		struct kvm_irq_routing_msi msi;          /*    16    16 */
		struct kvm_irq_routing_s390_adapter adapter; /*    16    32 */
		struct kvm_irq_routing_hv_sint hv_sint;  /*    16     8 */
		__u32              pad[8];               /*    16    32 */
	} u;                                             /*    16    32 */

	/* size: 48, cachelines: 1, members: 5 */
	/* last cacheline: 48 bytes */
};
struct kvm_irq_routing {
	__u32                      nr;                   /*     0     4 */
	__u32                      flags;                /*     4     4 */
	struct kvm_irq_routing_entry entries[];          /*     8     0 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct kvm_irqfd {
	__u32                      fd;                   /*     0     4 */
	__u32                      gsi;                  /*     4     4 */
	__u32                      flags;                /*     8     4 */
	__u32                      resamplefd;           /*    12     4 */
	__u8                       pad[16];              /*    16    16 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct kvm_one_reg {
	__u64                      id;                   /*     0     8 */
	__u64                      addr;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct kvm_msi {
	__u32                      address_lo;           /*     0     4 */
	__u32                      address_hi;           /*     4     4 */
	__u32                      data;                 /*     8     4 */
	__u32                      flags;                /*    12     4 */
	__u32                      devid;                /*    16     4 */
	__u8                       pad[12];              /*    20    12 */

	/* size: 32, cachelines: 1, members: 6 */
	/* last cacheline: 32 bytes */
};
struct kvm_create_device {
	__u32                      type;                 /*     0     4 */
	__u32                      fd;                   /*     4     4 */
	__u32                      flags;                /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
struct kvm_device_attr {
	__u32                      flags;                /*     0     4 */
	__u32                      group;                /*     4     4 */
	__u64                      attr;                 /*     8     8 */
	__u64                      addr;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct PCIIORegion {
	pcibus_t                   addr;                 /*     0     8 */
	pcibus_t                   size;                 /*     8     8 */
	uint8_t                    type;                 /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	MemoryRegion *             memory;               /*    24     8 */
	MemoryRegion *             address_space;        /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 33, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
struct PCIReqIDCache {
	PCIDevice *                dev;                  /*     0     8 */
	PCIReqIDType               type;                 /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct KVMState {
	AccelState                 parent_obj;           /*     0    40 */
	int                        nr_slots;             /*    40     4 */
	int                        fd;                   /*    44     4 */
	int                        vmfd;                 /*    48     4 */
	int                        coalesced_mmio;       /*    52     4 */
	struct kvm_coalesced_mmio_ring * coalesced_mmio_ring; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      coalesced_flush_in_progress; /*    64     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        broken_set_mem_region; /*    68     4 */
	int                        vcpu_events;          /*    72     4 */
	int                        robust_singlestep;    /*    76     4 */
	int                        debugregs;            /*    80     4 */

	/* XXX 4 bytes hole, try to pack */

	struct kvm_sw_breakpoint_head kvm_sw_breakpoints; /*    88    16 */
	int                        many_ioeventfds;      /*   104     4 */
	int                        intx_set_mask;        /*   108     4 */
	unsigned int               irq_set_ioctl;        /*   112     4 */
	unsigned int               sigmask_len;          /*   116     4 */
	GHashTable *               gsimap;               /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	struct kvm_irq_routing *   irq_routes;           /*   128     8 */
	int                        nr_allocated_irq_routes; /*   136     4 */

	/* XXX 4 bytes hole, try to pack */

	long unsigned int *        used_gsi_bitmap;      /*   144     8 */
	unsigned int               gsi_count;            /*   152     4 */

	/* XXX 4 bytes hole, try to pack */

	struct msi_hashtab         msi_hashtab[256];     /*   160  4096 */
	/* --- cacheline 66 boundary (4224 bytes) was 32 bytes ago --- */
	KVMMemoryListener          memory_listener;      /*  4256   176 */
	/* --- cacheline 69 boundary (4416 bytes) was 16 bytes ago --- */
	struct {
		struct KVMParkedVcpu * lh_first;         /*  4432     8 */
	} kvm_parked_vcpus;                              /*  4432     8 */

	/* size: 4440, cachelines: 70, members: 24 */
	/* sum members: 4425, holes: 4, sum holes: 15 */
	/* last cacheline: 24 bytes */
};
struct KVMCapabilityInfo {
	const char  *              name;                 /*     0     8 */
	int                        value;                /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct kvm_sw_breakpoint {
	target_ulong               pc;                   /*     0     8 */
	target_ulong               saved_insn;           /*     8     8 */
	int                        use_count;            /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct kvm_sw_breakpoint * tqe_next;     /*    24     8 */
		struct kvm_sw_breakpoint * * tqe_prev;   /*    32     8 */
	} entry;                                         /*    24    16 */

	/* size: 40, cachelines: 1, members: 4 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct kvm_sw_breakpoint_head {
	struct kvm_sw_breakpoint * tqh_first;            /*     0     8 */
	struct kvm_sw_breakpoint * * tqh_last;           /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct KVMSlot {
	hwaddr                     start_addr;           /*     0     8 */
	ram_addr_t                 memory_size;          /*     8     8 */
	void *                     ram;                  /*    16     8 */
	int                        slot;                 /*    24     4 */
	int                        flags;                /*    28     4 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct KVMMemoryListener {
	MemoryListener             listener;             /*     0   160 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	KVMSlot *                  slots;                /*   160     8 */
	int                        as_id;                /*   168     4 */

	/* size: 176, cachelines: 3, members: 3 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct KVMParkedVcpu {
	long unsigned int          vcpu_id;              /*     0     8 */
	int                        kvm_fd;               /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct KVMParkedVcpu * le_next;          /*    16     8 */
		struct KVMParkedVcpu * * le_prev;        /*    24     8 */
	} node;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct msi_hashtab {
	struct KVMMSIRoute *       tqh_first;            /*     0     8 */
	struct KVMMSIRoute * *     tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct KVMMSIRoute {
	struct kvm_irq_routing_entry kroute;             /*     0    48 */
	struct {
		struct KVMMSIRoute * tqe_next;           /*    48     8 */
		struct KVMMSIRoute * * tqe_prev;         /*    56     8 */
	} entry;                                         /*    48    16 */

	/* size: 64, cachelines: 1, members: 2 */
};
struct kvm_set_guest_debug_data {
	struct kvm_guest_debug     dbg;                  /*     0    72 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	int                        err;                  /*    72     4 */

	/* size: 80, cachelines: 2, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct CoalescedMemoryRange {
	AddrRange                  addr;                 /*     0    32 */
	struct {
		struct CoalescedMemoryRange * tqe_next;  /*    32     8 */
		struct CoalescedMemoryRange * * tqe_prev; /*    40     8 */
	} link;                                          /*    32    16 */

	/* size: 48, cachelines: 1, members: 2 */
	/* last cacheline: 48 bytes */
};
struct MemoryRegionIoeventfd {
	AddrRange                  addr;                 /*     0    32 */
	_Bool                      match_data;           /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	uint64_t                   data;                 /*    40     8 */
	EventNotifier *            e;                    /*    48     8 */

	/* size: 64, cachelines: 1, members: 4 */
	/* sum members: 49, holes: 1, sum holes: 7 */
	/* padding: 8 */
};
struct FlatView {
	struct rcu_head            rcu;                  /*     0    16 */
	unsigned int               ref;                  /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	FlatRange *                ranges;               /*    24     8 */
	unsigned int               nr;                   /*    32     4 */
	unsigned int               nr_allocated;         /*    36     4 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct memory_listeners {
	struct MemoryListener *    tqh_first;            /*     0     8 */
	struct MemoryListener * *  tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct AddrRange {
	Int128                     start;                /*     0    16 */
	Int128                     size;                 /*    16    16 */

	/* size: 32, cachelines: 1, members: 2 */
	/* last cacheline: 32 bytes */
};
struct FlatRange {
	MemoryRegion *             mr;                   /*     0     8 */
	hwaddr                     offset_in_region;     /*     8     8 */
	AddrRange                  addr;                 /*    16    32 */
	uint8_t                    dirty_log_mask;       /*    48     1 */
	_Bool                      romd_mode;            /*    49     1 */
	_Bool                      readonly;             /*    50     1 */

	/* Force padding: */
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;

	/* size: 64, cachelines: 1, members: 6 */
	/* padding: 13 */
};
struct MemoryRegionList {
	const MemoryRegion  *      mr;                   /*     0     8 */
	struct {
		struct MemoryRegionList * tqe_next;      /*     8     8 */
		struct MemoryRegionList * * tqe_prev;    /*    16     8 */
	} queue;                                         /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
struct queue {
	struct MemoryRegionList *  tqh_first;            /*     0     8 */
	struct MemoryRegionList * * tqh_last;            /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct MemoryMappingList {
	unsigned int               num;                  /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	MemoryMapping *            last_mapping;         /*     8     8 */
	struct {
		struct MemoryMapping * tqh_first;        /*    16     8 */
		struct MemoryMapping * * tqh_last;       /*    24     8 */
	} head;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct GuestPhysBlock {
	hwaddr                     target_start;         /*     0     8 */
	hwaddr                     target_end;           /*     8     8 */
	uint8_t *                  host_addr;            /*    16     8 */
	MemoryRegion *             mr;                   /*    24     8 */
	struct {
		struct GuestPhysBlock * tqe_next;        /*    32     8 */
		struct GuestPhysBlock * * tqe_prev;      /*    40     8 */
	} next;                                          /*    32    16 */

	/* size: 48, cachelines: 1, members: 5 */
	/* last cacheline: 48 bytes */
};
struct GuestPhysBlockHead {
	struct GuestPhysBlock *    tqh_first;            /*     0     8 */
	struct GuestPhysBlock * *  tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct GuestPhysBlockList {
	unsigned int               num;                  /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	struct GuestPhysBlockHead  head;                 /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct MemoryMapping {
	hwaddr                     phys_addr;            /*     0     8 */
	target_ulong               virt_addr;            /*     8     8 */
	ram_addr_t                 length;               /*    16     8 */
	struct {
		struct MemoryMapping * tqe_next;         /*    24     8 */
		struct MemoryMapping * * tqe_prev;       /*    32     8 */
	} next;                                          /*    24    16 */

	/* size: 40, cachelines: 1, members: 4 */
	/* last cacheline: 40 bytes */
};
struct GuestPhysListener {
	GuestPhysBlockList *       list;                 /*     0     8 */
	MemoryListener             listener;             /*     8   160 */

	/* size: 168, cachelines: 3, members: 2 */
	/* last cacheline: 40 bytes */
};
struct elf32_hdr {
	unsigned char              e_ident[16];          /*     0    16 */
	Elf32_Half                 e_type;               /*    16     2 */
	Elf32_Half                 e_machine;            /*    18     2 */
	Elf32_Word                 e_version;            /*    20     4 */
	Elf32_Addr                 e_entry;              /*    24     4 */
	Elf32_Off                  e_phoff;              /*    28     4 */
	Elf32_Off                  e_shoff;              /*    32     4 */
	Elf32_Word                 e_flags;              /*    36     4 */
	Elf32_Half                 e_ehsize;             /*    40     2 */
	Elf32_Half                 e_phentsize;          /*    42     2 */
	Elf32_Half                 e_phnum;              /*    44     2 */
	Elf32_Half                 e_shentsize;          /*    46     2 */
	Elf32_Half                 e_shnum;              /*    48     2 */
	Elf32_Half                 e_shstrndx;           /*    50     2 */

	/* size: 52, cachelines: 1, members: 14 */
	/* last cacheline: 52 bytes */
};
struct elf32_phdr {
	Elf32_Word                 p_type;               /*     0     4 */
	Elf32_Off                  p_offset;             /*     4     4 */
	Elf32_Addr                 p_vaddr;              /*     8     4 */
	Elf32_Addr                 p_paddr;              /*    12     4 */
	Elf32_Word                 p_filesz;             /*    16     4 */
	Elf32_Word                 p_memsz;              /*    20     4 */
	Elf32_Word                 p_flags;              /*    24     4 */
	Elf32_Word                 p_align;              /*    28     4 */

	/* size: 32, cachelines: 1, members: 8 */
	/* last cacheline: 32 bytes */
};
struct elf32_shdr {
	Elf32_Word                 sh_name;              /*     0     4 */
	Elf32_Word                 sh_type;              /*     4     4 */
	Elf32_Word                 sh_flags;             /*     8     4 */
	Elf32_Addr                 sh_addr;              /*    12     4 */
	Elf32_Off                  sh_offset;            /*    16     4 */
	Elf32_Word                 sh_size;              /*    20     4 */
	Elf32_Word                 sh_link;              /*    24     4 */
	Elf32_Word                 sh_info;              /*    28     4 */
	Elf32_Word                 sh_addralign;         /*    32     4 */
	Elf32_Word                 sh_entsize;           /*    36     4 */

	/* size: 40, cachelines: 1, members: 10 */
	/* last cacheline: 40 bytes */
};
struct DumpGuestMemoryCapability {
	DumpGuestMemoryFormatList * formats;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct DumpGuestMemoryFormatList {
	DumpGuestMemoryFormatList * next;                /*     0     8 */
	DumpGuestMemoryFormat      value;                /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct DumpQueryResult {
	DumpStatus                 status;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    completed;            /*     8     8 */
	int64_t                    total;                /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct ArchDumpInfo {
	int                        d_machine;            /*     0     4 */
	int                        d_endian;             /*     4     4 */
	int                        d_class;              /*     8     4 */
	uint32_t                   page_size;            /*    12     4 */
	uint64_t                   phys_base;            /*    16     8 */

	/* size: 24, cachelines: 1, members: 5 */
	/* last cacheline: 24 bytes */
};
struct MakedumpfileHeader {
	char                       signature[16];        /*     0    16 */
	int64_t                    type;                 /*    16     8 */
	int64_t                    version;              /*    24     8 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct MakedumpfileDataHeader {
	int64_t                    offset;               /*     0     8 */
	int64_t                    buf_size;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct NewUtsname {
	char                       sysname[65];          /*     0    65 */
	/* --- cacheline 1 boundary (64 bytes) was 1 bytes ago --- */
	char                       nodename[65];         /*    65    65 */
	/* --- cacheline 2 boundary (128 bytes) was 2 bytes ago --- */
	char                       release[65];          /*   130    65 */
	/* --- cacheline 3 boundary (192 bytes) was 3 bytes ago --- */
	char                       version[65];          /*   195    65 */
	/* --- cacheline 4 boundary (256 bytes) was 4 bytes ago --- */
	char                       machine[65];          /*   260    65 */
	/* --- cacheline 5 boundary (320 bytes) was 5 bytes ago --- */
	char                       domainname[65];       /*   325    65 */

	/* size: 390, cachelines: 7, members: 6 */
	/* last cacheline: 6 bytes */
};
struct DiskDumpHeader32 {
	char                       signature[8];         /*     0     8 */
	uint32_t                   header_version;       /*     8     4 */
	NewUtsname                 utsname;              /*    12   390 */
	/* --- cacheline 6 boundary (384 bytes) was 18 bytes ago --- */
	char                       timestamp[10];        /*   402    10 */
	uint32_t                   status;               /*   412     4 */
	uint32_t                   block_size;           /*   416     4 */
	uint32_t                   sub_hdr_size;         /*   420     4 */
	uint32_t                   bitmap_blocks;        /*   424     4 */
	uint32_t                   max_mapnr;            /*   428     4 */
	uint32_t                   total_ram_blocks;     /*   432     4 */
	uint32_t                   device_blocks;        /*   436     4 */
	uint32_t                   written_blocks;       /*   440     4 */
	uint32_t                   current_cpu;          /*   444     4 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	uint32_t                   nr_cpus;              /*   448     4 */

	/* size: 452, cachelines: 8, members: 14 */
	/* last cacheline: 4 bytes */
};
struct DiskDumpHeader64 {
	char                       signature[8];         /*     0     8 */
	uint32_t                   header_version;       /*     8     4 */
	NewUtsname                 utsname;              /*    12   390 */
	/* --- cacheline 6 boundary (384 bytes) was 18 bytes ago --- */
	char                       timestamp[22];        /*   402    22 */
	uint32_t                   status;               /*   424     4 */
	uint32_t                   block_size;           /*   428     4 */
	uint32_t                   sub_hdr_size;         /*   432     4 */
	uint32_t                   bitmap_blocks;        /*   436     4 */
	uint32_t                   max_mapnr;            /*   440     4 */
	uint32_t                   total_ram_blocks;     /*   444     4 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	uint32_t                   device_blocks;        /*   448     4 */
	uint32_t                   written_blocks;       /*   452     4 */
	uint32_t                   current_cpu;          /*   456     4 */
	uint32_t                   nr_cpus;              /*   460     4 */

	/* size: 464, cachelines: 8, members: 14 */
	/* last cacheline: 16 bytes */
};
struct KdumpSubHeader32 {
	uint32_t                   phys_base;            /*     0     4 */
	uint32_t                   dump_level;           /*     4     4 */
	uint32_t                   split;                /*     8     4 */
	uint32_t                   start_pfn;            /*    12     4 */
	uint32_t                   end_pfn;              /*    16     4 */
	uint64_t                   offset_vmcoreinfo;    /*    20     8 */
	uint32_t                   size_vmcoreinfo;      /*    28     4 */
	uint64_t                   offset_note;          /*    32     8 */
	uint32_t                   note_size;            /*    40     4 */
	uint64_t                   offset_eraseinfo;     /*    44     8 */
	uint32_t                   size_eraseinfo;       /*    52     4 */
	uint64_t                   start_pfn_64;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint64_t                   end_pfn_64;           /*    64     8 */
	uint64_t                   max_mapnr_64;         /*    72     8 */

	/* size: 80, cachelines: 2, members: 14 */
	/* last cacheline: 16 bytes */
} __attribute__((__packed__));
struct KdumpSubHeader64 {
	uint64_t                   phys_base;            /*     0     8 */
	uint32_t                   dump_level;           /*     8     4 */
	uint32_t                   split;                /*    12     4 */
	uint64_t                   start_pfn;            /*    16     8 */
	uint64_t                   end_pfn;              /*    24     8 */
	uint64_t                   offset_vmcoreinfo;    /*    32     8 */
	uint64_t                   size_vmcoreinfo;      /*    40     8 */
	uint64_t                   offset_note;          /*    48     8 */
	uint64_t                   note_size;            /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint64_t                   offset_eraseinfo;     /*    64     8 */
	uint64_t                   size_eraseinfo;       /*    72     8 */
	uint64_t                   start_pfn_64;         /*    80     8 */
	uint64_t                   end_pfn_64;           /*    88     8 */
	uint64_t                   max_mapnr_64;         /*    96     8 */

	/* size: 104, cachelines: 2, members: 14 */
	/* last cacheline: 40 bytes */
};
struct DataCache {
	int                        fd;                   /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  buf;                  /*     8     8 */
	size_t                     buf_size;             /*    16     8 */
	size_t                     data_size;            /*    24     8 */
	off_t                      offset;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct PageDescriptor {
	uint64_t                   offset;               /*     0     8 */
	uint32_t                   size;                 /*     8     4 */
	uint32_t                   flags;                /*    12     4 */
	uint64_t                   page_flags;           /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct DumpState {
	GuestPhysBlockList         guest_phys_blocks;    /*     0    24 */
	ArchDumpInfo               dump_info;            /*    24    24 */
	MemoryMappingList          list;                 /*    48    32 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	uint16_t                   phdr_num;             /*    80     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   sh_info;              /*    84     4 */
	_Bool                      have_section;         /*    88     1 */
	_Bool                      resume;               /*    89     1 */

	/* XXX 6 bytes hole, try to pack */

	ssize_t                    note_size;            /*    96     8 */
	hwaddr                     memory_offset;        /*   104     8 */
	int                        fd;                   /*   112     4 */

	/* XXX 4 bytes hole, try to pack */

	GuestPhysBlock *           next_block;           /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	ram_addr_t                 start;                /*   128     8 */
	_Bool                      has_filter;           /*   136     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    begin;                /*   144     8 */
	int64_t                    length;               /*   152     8 */
	uint8_t *                  note_buf;             /*   160     8 */
	size_t                     note_buf_offset;      /*   168     8 */
	uint32_t                   nr_cpus;              /*   176     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   max_mapnr;            /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	size_t                     len_dump_bitmap;      /*   192     8 */
	off_t                      offset_dump_bitmap;   /*   200     8 */
	off_t                      offset_page;          /*   208     8 */
	size_t                     num_dumpable;         /*   216     8 */
	uint32_t                   flag_compress;        /*   224     4 */
	DumpStatus                 status;               /*   228     4 */
	_Bool                      has_format;           /*   232     1 */

	/* XXX 3 bytes hole, try to pack */

	DumpGuestMemoryFormat      format;               /*   236     4 */
	QemuThread                 dump_thread;          /*   240     8 */
	int64_t                    total_size;           /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	int64_t                    written_size;         /*   256     8 */

	/* size: 264, cachelines: 5, members: 30 */
	/* sum members: 238, holes: 6, sum holes: 26 */
	/* last cacheline: 8 bytes */
};
struct MigrationIncomingState {
	QEMUFile *                 from_src_file;        /*     0     8 */
	QemuEvent                  main_thread_load_event; /*     8     4 */
	_Bool                      have_fault_thread;    /*    12     1 */

	/* XXX 3 bytes hole, try to pack */

	QemuThread                 fault_thread;         /*    16     8 */
	QemuSemaphore              fault_thread_sem;     /*    24    32 */
	_Bool                      have_listen_thread;   /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	QemuThread                 listen_thread;        /*    64     8 */
	QemuSemaphore              listen_thread_sem;    /*    72    32 */
	int                        userfault_fd;         /*   104     4 */
	int                        userfault_quit_fd;    /*   108     4 */
	QEMUFile *                 to_src_file;          /*   112     8 */
	QemuMutex                  rp_mutex;             /*   120    40 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	void *                     postcopy_tmp_page;    /*   160     8 */
	QEMUBH *                   bh;                   /*   168     8 */
	int                        state;                /*   176     4 */
	_Bool                      have_colo_incoming_thread; /*   180     1 */

	/* XXX 3 bytes hole, try to pack */

	QemuThread                 colo_incoming_thread; /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	Coroutine *                migration_incoming_co; /*   192     8 */
	LoadStateEntry_Head        loadvm_handlers;      /*   200     8 */

	/* size: 208, cachelines: 4, members: 19 */
	/* sum members: 195, holes: 3, sum holes: 13 */
	/* last cacheline: 16 bytes */
};
struct MigrationParams {
	_Bool                      blk;                  /*     0     1 */
	_Bool                      shared;               /*     1     1 */

	/* size: 2, cachelines: 1, members: 2 */
	/* last cacheline: 2 bytes */
};
struct MigrationState {
	size_t                     bytes_xfer;           /*     0     8 */
	size_t                     xfer_limit;           /*     8     8 */
	QemuThread                 thread;               /*    16     8 */
	QEMUBH *                   cleanup_bh;           /*    24     8 */
	QEMUFile *                 to_dst_file;          /*    32     8 */
	MigrationParameters        parameters;           /*    40   160 */
	/* --- cacheline 3 boundary (192 bytes) was 8 bytes ago --- */
	int                        state;                /*   200     4 */
	MigrationParams            params;               /*   204     2 */

	/* XXX 2 bytes hole, try to pack */

	struct {
		QEMUFile *         from_dst_file;        /*   208     8 */
		QemuThread         rp_thread;            /*   216     8 */
		_Bool              error;                /*   224     1 */
	} rp_state;                                      /*   208    24 */

	/* XXX last struct has 7 bytes of padding */

	double                     mbps;                 /*   232     8 */
	int64_t                    total_time;           /*   240     8 */
	int64_t                    downtime;             /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	int64_t                    expected_downtime;    /*   256     8 */
	int64_t                    dirty_pages_rate;     /*   264     8 */
	int64_t                    dirty_bytes_rate;     /*   272     8 */
	_Bool                      enabled_capabilities[8]; /*   280     8 */
	int64_t                    xbzrle_cache_size;    /*   288     8 */
	int64_t                    setup_time;           /*   296     8 */
	int64_t                    dirty_sync_count;     /*   304     8 */
	int64_t                    postcopy_requests;    /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	_Bool                      start_postcopy;       /*   320     1 */
	_Bool                      postcopy_after_devices; /*   321     1 */
	_Bool                      migration_thread_running; /*   322     1 */

	/* XXX 5 bytes hole, try to pack */

	QemuMutex                  src_page_req_mutex;   /*   328    40 */
	struct src_page_requests   src_page_requests;    /*   368    16 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	RAMBlock *                 last_req_rb;          /*   384     8 */
	Error *                    error;                /*   392     8 */

	/* size: 400, cachelines: 7, members: 27 */
	/* sum members: 393, holes: 2, sum holes: 7 */
	/* paddings: 1, sum paddings: 7 */
	/* last cacheline: 16 bytes */
};
struct MigrationParameters {
	_Bool                      has_compress_level;   /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    compress_level;       /*     8     8 */
	_Bool                      has_compress_threads; /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    compress_threads;     /*    24     8 */
	_Bool                      has_decompress_threads; /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    decompress_threads;   /*    40     8 */
	_Bool                      has_cpu_throttle_initial; /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    cpu_throttle_initial; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_cpu_throttle_increment; /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    cpu_throttle_increment; /*    72     8 */
	_Bool                      has_tls_creds;        /*    80     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     tls_creds;            /*    88     8 */
	_Bool                      has_tls_hostname;     /*    96     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     tls_hostname;         /*   104     8 */
	_Bool                      has_max_bandwidth;    /*   112     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    max_bandwidth;        /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	_Bool                      has_downtime_limit;   /*   128     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    downtime_limit;       /*   136     8 */
	_Bool                      has_x_checkpoint_delay; /*   144     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    x_checkpoint_delay;   /*   152     8 */

	/* size: 160, cachelines: 3, members: 20 */
	/* sum members: 90, holes: 10, sum holes: 70 */
	/* last cacheline: 32 bytes */
};
struct QemuSemaphore {
	sem_t                      sem;                  /*     0    32 */

	/* size: 32, cachelines: 1, members: 1 */
	/* last cacheline: 32 bytes */
};
struct QEMUFileOps {
	QEMUFileGetBufferFunc *    get_buffer;           /*     0     8 */
	QEMUFileCloseFunc *        close;                /*     8     8 */
	QEMUFileSetBlocking *      set_blocking;         /*    16     8 */
	QEMUFileWritevBufferFunc * writev_buffer;        /*    24     8 */
	QEMURetPathFunc *          get_return_path;      /*    32     8 */
	QEMUFileShutdownFunc *     shut_down;            /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct SaveVMHandlers {
	void                       (*set_params)(const MigrationParams  *, void *); /*     0     8 */
	SaveStateHandler *         save_state;           /*     8     8 */
	void                       (*cleanup)(void *);   /*    16     8 */
	int                        (*save_live_complete_postcopy)(QEMUFile *, void *); /*    24     8 */
	int                        (*save_live_complete_precopy)(QEMUFile *, void *); /*    32     8 */
	_Bool                      (*is_active)(void *); /*    40     8 */
	int                        (*save_live_iterate)(QEMUFile *, void *); /*    48     8 */
	int                        (*save_live_setup)(QEMUFile *, void *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*save_live_pending)(QEMUFile *, void *, uint64_t, uint64_t *, uint64_t *); /*    64     8 */
	LoadStateHandler *         load_state;           /*    72     8 */

	/* size: 80, cachelines: 2, members: 10 */
	/* last cacheline: 16 bytes */
};
struct MigrationSrcPageRequest {
	RAMBlock *                 rb;                   /*     0     8 */
	hwaddr                     offset;               /*     8     8 */
	hwaddr                     len;                  /*    16     8 */
	struct {
		struct MigrationSrcPageRequest * sqe_next; /*    24     8 */
	} next_req;                                      /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct src_page_requests {
	struct MigrationSrcPageRequest * sqh_first;      /*     0     8 */
	struct MigrationSrcPageRequest * * sqh_last;     /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct AccountingInfo {
	uint64_t                   dup_pages;            /*     0     8 */
	uint64_t                   skipped_pages;        /*     8     8 */
	uint64_t                   norm_pages;           /*    16     8 */
	uint64_t                   iterations;           /*    24     8 */
	uint64_t                   xbzrle_bytes;         /*    32     8 */
	uint64_t                   xbzrle_pages;         /*    40     8 */
	uint64_t                   xbzrle_cache_miss;    /*    48     8 */
	double                     xbzrle_cache_miss_rate; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint64_t                   xbzrle_overflows;     /*    64     8 */

	/* size: 72, cachelines: 2, members: 9 */
	/* last cacheline: 8 bytes */
};
struct PageSearchStatus {
	RAMBlock *                 block;                /*     0     8 */
	ram_addr_t                 offset;               /*     8     8 */
	_Bool                      complete_round;       /*    16     1 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct BitmapRcu {
	struct rcu_head            rcu;                  /*     0    16 */
	long unsigned int *        bmap;                 /*    16     8 */
	long unsigned int *        unsentmap;            /*    24     8 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct CompressParam {
	_Bool                      done;                 /*     0     1 */
	_Bool                      quit;                 /*     1     1 */

	/* XXX 6 bytes hole, try to pack */

	QEMUFile *                 file;                 /*     8     8 */
	QemuMutex                  mutex;                /*    16    40 */
	QemuCond                   cond;                 /*    56    48 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	RAMBlock *                 block;                /*   104     8 */
	ram_addr_t                 offset;               /*   112     8 */

	/* size: 120, cachelines: 2, members: 7 */
	/* sum members: 114, holes: 1, sum holes: 6 */
	/* last cacheline: 56 bytes */
};
struct DecompressParam {
	_Bool                      done;                 /*     0     1 */
	_Bool                      quit;                 /*     1     1 */

	/* XXX 6 bytes hole, try to pack */

	QemuMutex                  mutex;                /*     8    40 */
	QemuCond                   cond;                 /*    48    48 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	void *                     des;                  /*    96     8 */
	uint8_t *                  compbuf;              /*   104     8 */
	int                        len;                  /*   112     4 */

	/* size: 120, cachelines: 2, members: 7 */
	/* sum members: 110, holes: 1, sum holes: 6 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct tm {
	int                        tm_sec;               /*     0     4 */
	int                        tm_min;               /*     4     4 */
	int                        tm_hour;              /*     8     4 */
	int                        tm_mday;              /*    12     4 */
	int                        tm_mon;               /*    16     4 */
	int                        tm_year;              /*    20     4 */
	int                        tm_wday;              /*    24     4 */
	int                        tm_yday;              /*    28     4 */
	int                        tm_isdst;             /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	long int                   tm_gmtoff;            /*    40     8 */
	const char  *              tm_zone;              /*    48     8 */

	/* size: 56, cachelines: 1, members: 11 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct LoadStateEntry {
	struct {
		struct LoadStateEntry * le_next;         /*     0     8 */
		struct LoadStateEntry * * le_prev;       /*     8     8 */
	} entry;                                         /*     0    16 */
	SaveStateEntry *           se;                   /*    16     8 */
	int                        section_id;           /*    24     4 */
	int                        version_id;           /*    28     4 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct MACAddr {
	uint8_t                    a[6];                 /*     0     6 */

	/* size: 6, cachelines: 1, members: 1 */
	/* last cacheline: 6 bytes */
};
struct QIOChannel {
	Object                     parent;               /*     0    40 */
	unsigned int               features;             /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     name;                 /*    48     8 */

	/* size: 56, cachelines: 1, members: 3 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct NICPeers {
	NetClientState *           ncs[1024];            /*     0  8192 */
	/* --- cacheline 128 boundary (8192 bytes) --- */
	int32_t                    queues;               /*  8192     4 */

	/* size: 8200, cachelines: 129, members: 2 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
struct NICConf {
	MACAddr                    macaddr;              /*     0     6 */

	/* XXX 2 bytes hole, try to pack */

	NICPeers                   peers;                /*     8  8200 */
	/* --- cacheline 128 boundary (8192 bytes) was 16 bytes ago --- */
	int32_t                    bootindex;            /*  8208     4 */

	/* size: 8216, cachelines: 129, members: 3 */
	/* sum members: 8210, holes: 1, sum holes: 2 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct NICState {
	NetClientState *           ncs;                  /*     0     8 */
	NICConf *                  conf;                 /*     8     8 */
	void *                     opaque;               /*    16     8 */
	_Bool                      peer_deleted;         /*    24     1 */

	/* size: 32, cachelines: 1, members: 4 */
	/* padding: 7 */
	/* last cacheline: 32 bytes */
};
struct QIOChannelBuffer {
	QIOChannel                 parent;               /*     0    56 */
	size_t                     capacity;             /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	size_t                     usage;                /*    64     8 */
	size_t                     offset;               /*    72     8 */
	uint8_t *                  data;                 /*    80     8 */

	/* size: 88, cachelines: 2, members: 5 */
	/* last cacheline: 24 bytes */
};
struct QIOChannelFile {
	QIOChannel                 parent;               /*     0    56 */
	int                        fd;                   /*    56     4 */

	/* size: 64, cachelines: 1, members: 2 */
	/* padding: 4 */
};
struct mig_cmd_args {
	ssize_t                    len;                  /*     0     8 */
	const char  *              name;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct CompatEntry {
	char                       idstr[256];           /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	int                        instance_id;          /*   256     4 */

	/* size: 260, cachelines: 5, members: 2 */
	/* last cacheline: 4 bytes */
};
struct SaveStateEntry {
	struct {
		struct SaveStateEntry * tqe_next;        /*     0     8 */
		struct SaveStateEntry * * tqe_prev;      /*     8     8 */
	} entry;                                         /*     0    16 */
	char                       idstr[256];           /*    16   256 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	int                        instance_id;          /*   272     4 */
	int                        alias_id;             /*   276     4 */
	int                        version_id;           /*   280     4 */
	int                        section_id;           /*   284     4 */
	SaveVMHandlers *           ops;                  /*   288     8 */
	const VMStateDescription  * vmsd;                /*   296     8 */
	void *                     opaque;               /*   304     8 */
	CompatEntry *              compat;               /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	int                        is_ram;               /*   320     4 */

	/* size: 328, cachelines: 6, members: 11 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
struct SaveState {
	struct {
		struct SaveStateEntry * tqh_first;       /*     0     8 */
		struct SaveStateEntry * * tqh_last;      /*     8     8 */
	} handlers;                                      /*     0    16 */
	int                        global_section_id;    /*    16     4 */
	_Bool                      skip_configuration;   /*    20     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   len;                  /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              name;                 /*    32     8 */
	uint32_t                   target_page_bits;     /*    40     4 */

	/* size: 48, cachelines: 1, members: 6 */
	/* sum members: 37, holes: 2, sum holes: 7 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct VirtIODevice {
	DeviceState                parent_obj;           /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	const char  *              name;                 /*   112     8 */
	uint8_t                    status;               /*   120     1 */
	uint8_t                    isr;                  /*   121     1 */
	uint16_t                   queue_sel;            /*   122     2 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 2 boundary (128 bytes) --- */
	uint64_t                   guest_features;       /*   128     8 */
	uint64_t                   host_features;        /*   136     8 */
	size_t                     config_len;           /*   144     8 */
	void *                     config;               /*   152     8 */
	uint16_t                   config_vector;        /*   160     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   generation;           /*   164     4 */
	int                        nvectors;             /*   168     4 */

	/* XXX 4 bytes hole, try to pack */

	VirtQueue *                vq;                   /*   176     8 */
	uint16_t                   device_id;            /*   184     2 */
	_Bool                      vm_running;           /*   186     1 */
	_Bool                      broken;               /*   187     1 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) --- */
	VMChangeStateEntry *       vmstate;              /*   192     8 */
	char *                     bus_name;             /*   200     8 */
	uint8_t                    device_endian;        /*   208     1 */
	_Bool                      use_guest_notifier_mask; /*   209     1 */

	/* XXX 6 bytes hole, try to pack */

	struct {
		struct VirtQueue * lh_first;     /*     0     8 */
	} * vector_queues; /*   216     8 */

	/* size: 224, cachelines: 4, members: 21 */
	/* sum members: 204, holes: 5, sum holes: 20 */
	/* last cacheline: 32 bytes */
};
struct BlockConf {
	BlockBackend *             blk;                  /*     0     8 */
	uint16_t                   physical_block_size;  /*     8     2 */
	uint16_t                   logical_block_size;   /*    10     2 */
	uint16_t                   min_io_size;          /*    12     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   opt_io_size;          /*    16     4 */
	int32_t                    bootindex;            /*    20     4 */
	uint32_t                   discard_granularity;  /*    24     4 */
	uint32_t                   cyls;                 /*    28     4 */
	uint32_t                   heads;                /*    32     4 */
	uint32_t                   secs;                 /*    36     4 */
	OnOffAuto                  wce;                  /*    40     4 */
	BlockdevOnError            rerror;               /*    44     4 */
	BlockdevOnError            werror;               /*    48     4 */

	/* size: 56, cachelines: 1, members: 13 */
	/* sum members: 50, holes: 1, sum holes: 2 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct TimedAverageWindow {
	uint64_t                   min;                  /*     0     8 */
	uint64_t                   max;                  /*     8     8 */
	uint64_t                   sum;                  /*    16     8 */
	uint64_t                   count;                /*    24     8 */
	int64_t                    expiration;           /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct TimedAverage {
	uint64_t                   period;               /*     0     8 */
	TimedAverageWindow         windows[2];           /*     8    80 */
	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	unsigned int               current;              /*    88     4 */
	QEMUClockType              clock_type;           /*    92     4 */

	/* size: 96, cachelines: 2, members: 4 */
	/* last cacheline: 32 bytes */
};
struct BlockAcctTimedStats {
	TimedAverage               latency[3];           /*     0   288 */
	/* --- cacheline 4 boundary (256 bytes) was 32 bytes ago --- */
	unsigned int               interval_length;      /*   288     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct BlockAcctTimedStats * sle_next;   /*   296     8 */
	} entries;                                       /*   296     8 */

	/* size: 304, cachelines: 5, members: 3 */
	/* sum members: 300, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct BlockAcctStats {
	uint64_t                   nr_bytes[3];          /*     0    24 */
	uint64_t                   nr_ops[3];            /*    24    24 */
	uint64_t                   invalid_ops[3];       /*    48    24 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	uint64_t                   failed_ops[3];        /*    72    24 */
	uint64_t                   total_time_ns[3];     /*    96    24 */
	uint64_t                   merged[3];            /*   120    24 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	int64_t                    last_access_time_ns;  /*   144     8 */
	struct {
		struct BlockAcctTimedStats * slh_first;  /*   152     8 */
	} intervals;                                     /*   152     8 */
	_Bool                      account_invalid;      /*   160     1 */
	_Bool                      account_failed;       /*   161     1 */

	/* size: 168, cachelines: 3, members: 10 */
	/* padding: 6 */
	/* last cacheline: 40 bytes */
};
struct BlockAcctCookie {
	int64_t                    bytes;                /*     0     8 */
	int64_t                    start_time_ns;        /*     8     8 */
	enum BlockAcctType         type;                 /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct BlockDevOps {
	void                       (*change_media_cb)(void *, _Bool); /*     0     8 */
	void                       (*eject_request_cb)(void *, _Bool); /*     8     8 */
	_Bool                      (*is_tray_open)(void *); /*    16     8 */
	_Bool                      (*is_medium_locked)(void *); /*    24     8 */
	void                       (*resize_cb)(void *); /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct virtio_blk_geometry {
	uint16_t                   cylinders;            /*     0     2 */
	uint8_t                    heads;                /*     2     1 */
	uint8_t                    sectors;              /*     3     1 */

	/* size: 4, cachelines: 1, members: 3 */
	/* last cacheline: 4 bytes */
};
struct virtio_blk_config {
	uint64_t                   capacity;             /*     0     8 */
	uint32_t                   size_max;             /*     8     4 */
	uint32_t                   seg_max;              /*    12     4 */
	struct virtio_blk_geometry geometry;             /*    16     4 */
	uint32_t                   blk_size;             /*    20     4 */
	uint8_t                    physical_block_exp;   /*    24     1 */
	uint8_t                    alignment_offset;     /*    25     1 */
	uint16_t                   min_io_size;          /*    26     2 */
	uint32_t                   opt_io_size;          /*    28     4 */
	uint8_t                    wce;                  /*    32     1 */
	uint8_t                    unused;               /*    33     1 */
	uint16_t                   num_queues;           /*    34     2 */

	/* size: 36, cachelines: 1, members: 12 */
	/* last cacheline: 36 bytes */
} __attribute__((__packed__));
struct virtio_blk_outhdr {
	__virtio32                 type;                 /*     0     4 */
	__virtio32                 ioprio;               /*     4     4 */
	__virtio64                 sector;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct virtio_scsi_inhdr {
	__virtio32                 errors;               /*     0     4 */
	__virtio32                 data_len;             /*     4     4 */
	__virtio32                 sense_len;            /*     8     4 */
	__virtio32                 residual;             /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct VirtQueueElement {
	unsigned int               index;                /*     0     4 */
	unsigned int               out_num;              /*     4     4 */
	unsigned int               in_num;               /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	hwaddr *                   in_addr;              /*    16     8 */
	hwaddr *                   out_addr;             /*    24     8 */
	struct iovec *             in_sg;                /*    32     8 */
	struct iovec *             out_sg;               /*    40     8 */

	/* size: 48, cachelines: 1, members: 7 */
	/* sum members: 44, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct VirtioDeviceClass {
	DeviceClass                parent;               /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	DeviceRealize              realize;              /*   192     8 */
	DeviceUnrealize            unrealize;            /*   200     8 */
	uint64_t                   (*get_features)(VirtIODevice *, uint64_t, Error * *); /*   208     8 */
	uint64_t                   (*bad_features)(VirtIODevice *); /*   216     8 */
	void                       (*set_features)(VirtIODevice *, uint64_t); /*   224     8 */
	int                        (*validate_features)(VirtIODevice *); /*   232     8 */
	void                       (*get_config)(VirtIODevice *, uint8_t *); /*   240     8 */
	void                       (*set_config)(VirtIODevice *, const uint8_t  *); /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	void                       (*reset)(VirtIODevice *); /*   256     8 */
	void                       (*set_status)(VirtIODevice *, uint8_t); /*   264     8 */
	uint64_t                   legacy_features;      /*   272     8 */
	_Bool                      (*guest_notifier_pending)(VirtIODevice *, int); /*   280     8 */
	void                       (*guest_notifier_mask)(VirtIODevice *, int, _Bool); /*   288     8 */
	int                        (*start_ioeventfd)(VirtIODevice *); /*   296     8 */
	void                       (*stop_ioeventfd)(VirtIODevice *); /*   304     8 */
	void                       (*save)(VirtIODevice *, QEMUFile *); /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	int                        (*load)(VirtIODevice *, QEMUFile *, int); /*   320     8 */
	const VMStateDescription  * vmsd;                /*   328     8 */

	/* size: 336, cachelines: 6, members: 19 */
	/* last cacheline: 16 bytes */
};
struct VirtIOBlkConf {
	BlockConf                  conf;                 /*     0    56 */
	IOThread *                 iothread;             /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     serial;               /*    64     8 */
	uint32_t                   scsi;                 /*    72     4 */
	uint32_t                   config_wce;           /*    76     4 */
	uint32_t                   request_merging;      /*    80     4 */
	uint16_t                   num_queues;           /*    84     2 */

	/* size: 88, cachelines: 2, members: 7 */
	/* padding: 2 */
	/* last cacheline: 24 bytes */
};
struct virtio_blk_inhdr {
	unsigned char              status;               /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
};
struct VirtIOBlock {
	VirtIODevice               parent_obj;           /*     0   224 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	BlockBackend *             blk;                  /*   224     8 */
	void *                     rq;                   /*   232     8 */
	QEMUBH *                   bh;                   /*   240     8 */
	VirtIOBlkConf              conf;                 /*   248    88 */
	/* --- cacheline 5 boundary (320 bytes) was 16 bytes ago --- */
	short unsigned int         sector_mask;          /*   336     2 */
	_Bool                      original_wce;         /*   338     1 */

	/* XXX 5 bytes hole, try to pack */

	VMChangeStateEntry *       change;               /*   344     8 */
	_Bool                      dataplane_disabled;   /*   352     1 */
	_Bool                      dataplane_started;    /*   353     1 */

	/* XXX 6 bytes hole, try to pack */

	struct VirtIOBlockDataPlane * dataplane;         /*   360     8 */

	/* size: 368, cachelines: 6, members: 11 */
	/* sum members: 357, holes: 2, sum holes: 11 */
	/* last cacheline: 48 bytes */
};
struct VirtIOBlockReq {
	VirtQueueElement           elem;                 /*     0    48 */
	int64_t                    sector_num;           /*    48     8 */
	VirtIOBlock *              dev;                  /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	VirtQueue *                vq;                   /*    64     8 */
	struct virtio_blk_inhdr *  in;                   /*    72     8 */
	struct virtio_blk_outhdr   out;                  /*    80    16 */
	QEMUIOVector               qiov;                 /*    96    24 */
	size_t                     in_len;               /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	struct VirtIOBlockReq *    next;                 /*   128     8 */
	struct VirtIOBlockReq *    mr_next;              /*   136     8 */
	BlockAcctCookie            acct;                 /*   144    24 */

	/* size: 168, cachelines: 3, members: 11 */
	/* last cacheline: 40 bytes */
};
struct MultiReqBuffer {
	VirtIOBlockReq *           reqs[32];             /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	unsigned int               num_reqs;             /*   256     4 */
	_Bool                      is_write;             /*   260     1 */

	/* size: 264, cachelines: 5, members: 3 */
	/* padding: 3 */
	/* last cacheline: 8 bytes */
};
struct sg_io_hdr {
	int                        interface_id;         /*     0     4 */
	int                        dxfer_direction;      /*     4     4 */
	unsigned char              cmd_len;              /*     8     1 */
	unsigned char              mx_sb_len;            /*     9     1 */
	short unsigned int         iovec_count;          /*    10     2 */
	unsigned int               dxfer_len;            /*    12     4 */
	void *                     dxferp;               /*    16     8 */
	unsigned char *            cmdp;                 /*    24     8 */
	unsigned char *            sbp;                  /*    32     8 */
	unsigned int               timeout;              /*    40     4 */
	unsigned int               flags;                /*    44     4 */
	int                        pack_id;              /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     usr_ptr;              /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	unsigned char              status;               /*    64     1 */
	unsigned char              masked_status;        /*    65     1 */
	unsigned char              msg_status;           /*    66     1 */
	unsigned char              sb_len_wr;            /*    67     1 */
	short unsigned int         host_status;          /*    68     2 */
	short unsigned int         driver_status;        /*    70     2 */
	int                        resid;                /*    72     4 */
	unsigned int               duration;             /*    76     4 */
	unsigned int               info;                 /*    80     4 */

	/* size: 88, cachelines: 2, members: 22 */
	/* sum members: 80, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct BusClass {
	ObjectClass                parent_class;         /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	void                       (*print_dev)(Monitor *, DeviceState *, int); /*    96     8 */
	char *                     (*get_dev_path)(DeviceState *); /*   104     8 */
	char *                     (*get_fw_dev_path)(DeviceState *); /*   112     8 */
	void                       (*reset)(BusState *); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	BusRealize                 realize;              /*   128     8 */
	BusUnrealize               unrealize;            /*   136     8 */
	int                        max_dev;              /*   144     4 */
	int                        automatic_ids;        /*   148     4 */

	/* size: 152, cachelines: 3, members: 9 */
	/* last cacheline: 24 bytes */
};
struct VirtIOBlockDataPlane {
	_Bool                      starting;             /*     0     1 */
	_Bool                      stopping;             /*     1     1 */

	/* XXX 6 bytes hole, try to pack */

	VirtIOBlkConf *            conf;                 /*     8     8 */
	VirtIODevice *             vdev;                 /*    16     8 */
	QEMUBH *                   bh;                   /*    24     8 */
	long unsigned int *        batch_notify_vqs;     /*    32     8 */
	IOThread *                 iothread;             /*    40     8 */
	AioContext *               ctx;                  /*    48     8 */

	/* size: 56, cachelines: 1, members: 8 */
	/* sum members: 50, holes: 1, sum holes: 6 */
	/* last cacheline: 56 bytes */
};
struct VirtioBusState {
	BusState                   parent_obj;           /*     0   104 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	_Bool                      ioeventfd_started;    /*   104     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        ioeventfd_grabbed;    /*   108     4 */

	/* size: 112, cachelines: 2, members: 3 */
	/* sum members: 109, holes: 1, sum holes: 3 */
	/* last cacheline: 48 bytes */
};
struct VirtioBusClass {
	BusClass                   parent;               /*     0   152 */
	/* --- cacheline 2 boundary (128 bytes) was 24 bytes ago --- */
	void                       (*notify)(DeviceState *, uint16_t); /*   152     8 */
	void                       (*save_config)(DeviceState *, QEMUFile *); /*   160     8 */
	void                       (*save_queue)(DeviceState *, int, QEMUFile *); /*   168     8 */
	void                       (*save_extra_state)(DeviceState *, QEMUFile *); /*   176     8 */
	int                        (*load_config)(DeviceState *, QEMUFile *); /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        (*load_queue)(DeviceState *, int, QEMUFile *); /*   192     8 */
	int                        (*load_done)(DeviceState *, QEMUFile *); /*   200     8 */
	int                        (*load_extra_state)(DeviceState *, QEMUFile *); /*   208     8 */
	_Bool                      (*has_extra_state)(DeviceState *); /*   216     8 */
	_Bool                      (*query_guest_notifiers)(DeviceState *); /*   224     8 */
	int                        (*set_guest_notifiers)(DeviceState *, int, _Bool); /*   232     8 */
	void                       (*vmstate_change)(DeviceState *, _Bool); /*   240     8 */
	void                       (*pre_plugged)(DeviceState *, Error * *); /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	void                       (*device_plugged)(DeviceState *, Error * *); /*   256     8 */
	void                       (*device_unplugged)(DeviceState *); /*   264     8 */
	int                        (*query_nvectors)(DeviceState *); /*   272     8 */
	_Bool                      (*ioeventfd_enabled)(DeviceState *); /*   280     8 */
	int                        (*ioeventfd_assign)(DeviceState *, EventNotifier *, int, _Bool); /*   288     8 */
	_Bool                      has_variable_vring_alignment; /*   296     1 */

	/* size: 304, cachelines: 5, members: 20 */
	/* padding: 7 */
	/* last cacheline: 48 bytes */
};
struct InterfaceClass {
	ObjectClass                parent_class;         /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	ObjectClass *              concrete_class;       /*    96     8 */
	Type                       interface_type;       /*   104     8 */

	/* size: 112, cachelines: 2, members: 3 */
	/* last cacheline: 48 bytes */
};
struct HotplugHandlerClass {
	InterfaceClass             parent;               /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	hotplug_fn                 pre_plug;             /*   112     8 */
	hotplug_fn                 plug;                 /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	hotplug_fn                 unplug_request;       /*   128     8 */
	hotplug_fn                 unplug;               /*   136     8 */

	/* size: 144, cachelines: 3, members: 5 */
	/* last cacheline: 16 bytes */
};
struct virtio_console_config {
	uint16_t                   cols;                 /*     0     2 */
	uint16_t                   rows;                 /*     2     2 */
	uint32_t                   max_nr_ports;         /*     4     4 */
	uint32_t                   emerg_wr;             /*     8     4 */

	/* size: 12, cachelines: 1, members: 4 */
	/* last cacheline: 12 bytes */
};
struct virtio_console_control {
	__virtio32                 id;                   /*     0     4 */
	__virtio16                 event;                /*     4     2 */
	__virtio16                 value;                /*     6     2 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct virtio_serial_conf {
	uint32_t                   max_virtserial_ports; /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct VirtIOSerial {
	VirtIODevice               parent_obj;           /*     0   224 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	VirtQueue *                c_ivq;                /*   224     8 */
	VirtQueue *                c_ovq;                /*   232     8 */
	VirtQueue * *              ivqs;                 /*   240     8 */
	VirtQueue * *              ovqs;                 /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	VirtIOSerialBus            bus;                  /*   256   120 */
	/* --- cacheline 5 boundary (320 bytes) was 56 bytes ago --- */
	struct {
		struct VirtIOSerialPort * tqh_first;     /*   376     8 */
		/* --- cacheline 6 boundary (384 bytes) --- */
		struct VirtIOSerialPort * * tqh_last;    /*   384     8 */
	} ports;                                         /*   376    16 */
	struct {
		struct VirtIOSerial * le_next;           /*   392     8 */
		struct VirtIOSerial * * le_prev;         /*   400     8 */
	} next;                                          /*   392    16 */
	uint32_t *                 ports_map;            /*   408     8 */
	struct VirtIOSerialPostLoad * post_load;         /*   416     8 */
	virtio_serial_conf         serial;               /*   424     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   host_features;        /*   432     8 */

	/* size: 440, cachelines: 7, members: 12 */
	/* sum members: 436, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct VirtIOSerialBus {
	BusState                   qbus;                 /*     0   104 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	VirtIOSerial *             vser;                 /*   104     8 */
	uint32_t                   max_nr_ports;         /*   112     4 */

	/* size: 120, cachelines: 2, members: 3 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct VirtIOSerialPort {
	DeviceState                dev;                  /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	struct {
		struct VirtIOSerialPort * tqe_next;      /*   112     8 */
		struct VirtIOSerialPort * * tqe_prev;    /*   120     8 */
	} next;                                          /*   112    16 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	VirtIOSerial *             vser;                 /*   128     8 */
	VirtQueue *                ivq;                  /*   136     8 */
	VirtQueue *                ovq;                  /*   144     8 */
	char *                     name;                 /*   152     8 */
	uint32_t                   id;                   /*   160     4 */

	/* XXX 4 bytes hole, try to pack */

	VirtQueueElement *         elem;                 /*   168     8 */
	uint32_t                   iov_idx;              /*   176     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   iov_offset;           /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	QEMUBH *                   bh;                   /*   192     8 */
	_Bool                      guest_connected;      /*   200     1 */
	_Bool                      host_connected;       /*   201     1 */
	_Bool                      throttled;            /*   202     1 */

	/* size: 208, cachelines: 4, members: 14 */
	/* sum members: 195, holes: 2, sum holes: 8 */
	/* padding: 5 */
	/* last cacheline: 16 bytes */
};
struct VirtIOSerialPortClass {
	DeviceClass                parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	_Bool                      is_console;           /*   192     1 */

	/* XXX 7 bytes hole, try to pack */

	DeviceRealize              realize;              /*   200     8 */
	DeviceUnrealize            unrealize;            /*   208     8 */
	void                       (*set_guest_connected)(VirtIOSerialPort *, int); /*   216     8 */
	void                       (*guest_ready)(VirtIOSerialPort *); /*   224     8 */
	void                       (*guest_writable)(VirtIOSerialPort *); /*   232     8 */
	ssize_t                    (*have_data)(VirtIOSerialPort *, const uint8_t  *, ssize_t); /*   240     8 */

	/* size: 248, cachelines: 4, members: 8 */
	/* sum members: 241, holes: 1, sum holes: 7 */
	/* last cacheline: 56 bytes */
};
struct VirtIOSerialPostLoad {
	QEMUTimer *                timer;                /*     0     8 */
	uint32_t                   nr_active_ports;      /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		VirtIOSerialPort * port;         /*     0     8 */
		uint8_t    host_connected;       /*     8     1 */
	} * connected; /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct VirtIOSerialDevices {
	struct {
		struct VirtIOSerial * lh_first;          /*     0     8 */
	} devices;                                       /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct NMIState {
	Object                     parent_obj;           /*     0    40 */

	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
struct NMIClass {
	InterfaceClass             parent_class;         /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	void                       (*nmi_monitor_handler)(NMIState *, int, Error * *); /*   112     8 */

	/* size: 120, cachelines: 2, members: 2 */
	/* last cacheline: 56 bytes */
};
struct do_nmi_s {
	int                        cpu_index;            /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	Error *                    err;                  /*     8     8 */
	_Bool                      handled;              /*    16     1 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 13, holes: 1, sum holes: 4 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct GenericLoaderState {
	DeviceState                parent_obj;           /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	CPUState *                 cpu;                  /*   112     8 */
	uint64_t                   addr;                 /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint64_t                   data;                 /*   128     8 */
	uint8_t                    data_len;             /*   136     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   cpu_num;              /*   140     4 */
	char *                     file;                 /*   144     8 */
	_Bool                      force_raw;            /*   152     1 */
	_Bool                      data_be;              /*   153     1 */
	_Bool                      set_pc;               /*   154     1 */

	/* size: 160, cachelines: 3, members: 10 */
	/* sum members: 152, holes: 1, sum holes: 3 */
	/* padding: 5 */
	/* last cacheline: 32 bytes */
};
struct CPUCore {
	DeviceState                parent_obj;           /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	int                        core_id;              /*   112     4 */
	int                        nr_threads;           /*   116     4 */

	/* size: 120, cachelines: 2, members: 3 */
	/* last cacheline: 56 bytes */
};
struct DisplaySurface {
	pixman_format_code_t       format;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	pixman_image_t *           image;                /*     8     8 */
	uint8_t                    flags;                /*    16     1 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 13, holes: 1, sum holes: 4 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct QemuUIInfo {
	int                        xoff;                 /*     0     4 */
	int                        yoff;                 /*     4     4 */
	uint32_t                   width;                /*     8     4 */
	uint32_t                   height;               /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct GraphicHwOps {
	void                       (*invalidate)(void *); /*     0     8 */
	void                       (*gfx_update)(void *); /*     8     8 */
	void                       (*text_update)(void *, console_ch_t *); /*    16     8 */
	void                       (*update_interval)(void *, uint64_t); /*    24     8 */
	int                        (*ui_info)(void *, uint32_t, QemuUIInfo *); /*    32     8 */
	void                       (*gl_block)(void *, _Bool); /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct vga_precise_retrace {
	int64_t                    ticks_per_char;       /*     0     8 */
	int64_t                    total_chars;          /*     8     8 */
	int                        htotal;               /*    16     4 */
	int                        hstart;               /*    20     4 */
	int                        hend;                 /*    24     4 */
	int                        vstart;               /*    28     4 */
	int                        vend;                 /*    32     4 */
	int                        freq;                 /*    36     4 */

	/* size: 40, cachelines: 1, members: 8 */
	/* last cacheline: 40 bytes */
};
union vga_retrace {
	struct vga_precise_retrace precise;            /*     0    40 */
};
struct VGACommonState {
	MemoryRegion *             legacy_address_space; /*     0     8 */
	uint8_t *                  vram_ptr;             /*     8     8 */
	MemoryRegion               vram;                 /*    16   256 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	MemoryRegion               vram_vbe;             /*   272   256 */
	/* --- cacheline 8 boundary (512 bytes) was 16 bytes ago --- */
	uint32_t                   vram_size;            /*   528     4 */
	uint32_t                   vram_size_mb;         /*   532     4 */
	uint32_t                   vbe_size;             /*   536     4 */
	uint32_t                   latch;                /*   540     4 */
	_Bool                      has_chain4_alias;     /*   544     1 */

	/* XXX 15 bytes hole, try to pack */

	MemoryRegion               chain4_alias;         /*   560   256 */
	/* --- cacheline 12 boundary (768 bytes) was 48 bytes ago --- */
	uint8_t                    sr_index;             /*   816     1 */
	uint8_t                    sr[256];              /*   817   256 */
	/* --- cacheline 16 boundary (1024 bytes) was 49 bytes ago --- */
	uint8_t                    sr_vbe[256];          /*  1073   256 */
	/* --- cacheline 20 boundary (1280 bytes) was 49 bytes ago --- */
	uint8_t                    gr_index;             /*  1329     1 */
	uint8_t                    gr[256];              /*  1330   256 */
	/* --- cacheline 24 boundary (1536 bytes) was 50 bytes ago --- */
	uint8_t                    ar_index;             /*  1586     1 */
	uint8_t                    ar[21];               /*  1587    21 */
	/* --- cacheline 25 boundary (1600 bytes) was 8 bytes ago --- */
	int                        ar_flip_flop;         /*  1608     4 */
	uint8_t                    cr_index;             /*  1612     1 */
	uint8_t                    cr[256];              /*  1613   256 */
	/* --- cacheline 29 boundary (1856 bytes) was 13 bytes ago --- */
	uint8_t                    msr;                  /*  1869     1 */
	uint8_t                    fcr;                  /*  1870     1 */
	uint8_t                    st00;                 /*  1871     1 */
	uint8_t                    st01;                 /*  1872     1 */
	uint8_t                    dac_state;            /*  1873     1 */
	uint8_t                    dac_sub_index;        /*  1874     1 */
	uint8_t                    dac_read_index;       /*  1875     1 */
	uint8_t                    dac_write_index;      /*  1876     1 */
	uint8_t                    dac_cache[3];         /*  1877     3 */
	int                        dac_8bit;             /*  1880     4 */
	uint8_t                    palette[768];         /*  1884   768 */
	/* --- cacheline 41 boundary (2624 bytes) was 28 bytes ago --- */
	int32_t                    bank_offset;          /*  2652     4 */
	int                        (*get_bpp)(struct VGACommonState *); /*  2656     8 */
	void                       (*get_offsets)(struct VGACommonState *, uint32_t *, uint32_t *, uint32_t *); /*  2664     8 */
	void                       (*get_resolution)(struct VGACommonState *, int *, int *); /*  2672     8 */
	PortioList                 vga_port_list;        /*  2680    64 */
	/* --- cacheline 42 boundary (2688 bytes) was 56 bytes ago --- */
	PortioList                 vbe_port_list;        /*  2744    64 */
	/* --- cacheline 43 boundary (2752 bytes) was 56 bytes ago --- */
	uint16_t                   vbe_index;            /*  2808     2 */
	uint16_t                   vbe_regs[10];         /*  2810    20 */

	/* XXX 2 bytes hole, try to pack */

	/* --- cacheline 44 boundary (2816 bytes) was 16 bytes ago --- */
	uint32_t                   vbe_start_addr;       /*  2832     4 */
	uint32_t                   vbe_line_offset;      /*  2836     4 */
	uint32_t                   vbe_bank_mask;        /*  2840     4 */
	int                        vbe_mapped;           /*  2844     4 */
	QemuConsole *              con;                  /*  2848     8 */
	uint32_t                   font_offsets[2];      /*  2856     8 */
	int                        graphic_mode;         /*  2864     4 */
	uint8_t                    shift_control;        /*  2868     1 */
	uint8_t                    double_scan;          /*  2869     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   line_offset;          /*  2872     4 */
	uint32_t                   line_compare;         /*  2876     4 */
	/* --- cacheline 45 boundary (2880 bytes) --- */
	uint32_t                   start_addr;           /*  2880     4 */
	uint32_t                   plane_updated;        /*  2884     4 */
	uint32_t                   last_line_offset;     /*  2888     4 */
	uint8_t                    last_cw;              /*  2892     1 */
	uint8_t                    last_ch;              /*  2893     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   last_width;           /*  2896     4 */
	uint32_t                   last_height;          /*  2900     4 */
	uint32_t                   last_scr_width;       /*  2904     4 */
	uint32_t                   last_scr_height;      /*  2908     4 */
	uint32_t                   last_depth;           /*  2912     4 */
	_Bool                      last_byteswap;        /*  2916     1 */
	_Bool                      force_shadow;         /*  2917     1 */
	uint8_t                    cursor_start;         /*  2918     1 */
	uint8_t                    cursor_end;           /*  2919     1 */
	_Bool                      cursor_visible_phase; /*  2920     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    cursor_blink_time;    /*  2928     8 */
	uint32_t                   cursor_offset;        /*  2936     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 46 boundary (2944 bytes) --- */
	const GraphicHwOps  *      hw_ops;               /*  2944     8 */
	_Bool                      full_update_text;     /*  2952     1 */
	_Bool                      full_update_gfx;      /*  2953     1 */
	_Bool                      big_endian_fb;        /*  2954     1 */
	_Bool                      default_endian_fb;    /*  2955     1 */
	uint32_t                   invalidated_y_table[64]; /*  2956   256 */
	/* --- cacheline 50 boundary (3200 bytes) was 12 bytes ago --- */
	uint32_t                   hw_cursor_x;          /*  3212     4 */
	uint32_t                   hw_cursor_y;          /*  3216     4 */

	/* XXX 4 bytes hole, try to pack */

	void                       (*cursor_invalidate)(struct VGACommonState *); /*  3224     8 */
	void                       (*cursor_draw_line)(struct VGACommonState *, uint8_t *, int); /*  3232     8 */
	uint32_t                   last_palette[256];    /*  3240  1024 */
	/* --- cacheline 66 boundary (4224 bytes) was 40 bytes ago --- */
	uint32_t                   last_ch_attr[16000];  /*  4264 64000 */
	/* --- cacheline 1066 boundary (68224 bytes) was 40 bytes ago --- */
	vga_retrace_fn             retrace;              /* 68264     8 */
	vga_update_retrace_info_fn update_retrace_info;  /* 68272     8 */
	union vga_retrace          retrace_info;         /* 68280    40 */
	/* --- cacheline 1067 boundary (68288 bytes) was 32 bytes ago --- */
	uint8_t                    is_vbe_vmstate;       /* 68320     1 */

	/* Force padding: */
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;

	/* size: 68336, cachelines: 1068, members: 83 */
	/* sum members: 68285, holes: 7, sum holes: 36 */
	/* padding: 15 */
	/* last cacheline: 48 bytes */
};
struct pixman_region16_data {
	long int                   size;                 /*     0     8 */
	long int                   numRects;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct pixman_box16 {
	int16_t                    x1;                   /*     0     2 */
	int16_t                    y1;                   /*     2     2 */
	int16_t                    x2;                   /*     4     2 */
	int16_t                    y2;                   /*     6     2 */

	/* size: 8, cachelines: 1, members: 4 */
	/* last cacheline: 8 bytes */
};
struct pixman_region16 {
	pixman_box16_t             extents;              /*     0     8 */
	pixman_region16_data_t *   data;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct QEMUCursor {
	int                        width;                /*     0     4 */
	int                        height;               /*     4     4 */
	int                        hot_x;                /*     8     4 */
	int                        hot_y;                /*    12     4 */
	int                        refcount;             /*    16     4 */
	uint32_t                   data[];               /*    20     0 */

	/* size: 20, cachelines: 1, members: 6 */
	/* last cacheline: 20 bytes */
};
struct virtio_gpu_ctrl_hdr {
	uint32_t                   type;                 /*     0     4 */
	uint32_t                   flags;                /*     4     4 */
	uint64_t                   fence_id;             /*     8     8 */
	uint32_t                   ctx_id;               /*    16     4 */
	uint32_t                   padding;              /*    20     4 */

	/* size: 24, cachelines: 1, members: 5 */
	/* last cacheline: 24 bytes */
};
struct virtio_gpu_cursor_pos {
	uint32_t                   scanout_id;           /*     0     4 */
	uint32_t                   x;                    /*     4     4 */
	uint32_t                   y;                    /*     8     4 */
	uint32_t                   padding;              /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct virtio_gpu_update_cursor {
	struct virtio_gpu_ctrl_hdr hdr;                  /*     0    24 */
	struct virtio_gpu_cursor_pos pos;                /*    24    16 */
	uint32_t                   resource_id;          /*    40     4 */
	uint32_t                   hot_x;                /*    44     4 */
	uint32_t                   hot_y;                /*    48     4 */
	uint32_t                   padding;              /*    52     4 */

	/* size: 56, cachelines: 1, members: 6 */
	/* last cacheline: 56 bytes */
};
struct virtio_gpu_rect {
	uint32_t                   x;                    /*     0     4 */
	uint32_t                   y;                    /*     4     4 */
	uint32_t                   width;                /*     8     4 */
	uint32_t                   height;               /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct virtio_gpu_resource_unref {
	struct virtio_gpu_ctrl_hdr hdr;                  /*     0    24 */
	uint32_t                   resource_id;          /*    24     4 */
	uint32_t                   padding;              /*    28     4 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct virtio_gpu_resource_create_2d {
	struct virtio_gpu_ctrl_hdr hdr;                  /*     0    24 */
	uint32_t                   resource_id;          /*    24     4 */
	uint32_t                   format;               /*    28     4 */
	uint32_t                   width;                /*    32     4 */
	uint32_t                   height;               /*    36     4 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct virtio_gpu_set_scanout {
	struct virtio_gpu_ctrl_hdr hdr;                  /*     0    24 */
	struct virtio_gpu_rect     r;                    /*    24    16 */
	uint32_t                   scanout_id;           /*    40     4 */
	uint32_t                   resource_id;          /*    44     4 */

	/* size: 48, cachelines: 1, members: 4 */
	/* last cacheline: 48 bytes */
};
struct virtio_gpu_resource_flush {
	struct virtio_gpu_ctrl_hdr hdr;                  /*     0    24 */
	struct virtio_gpu_rect     r;                    /*    24    16 */
	uint32_t                   resource_id;          /*    40     4 */
	uint32_t                   padding;              /*    44     4 */

	/* size: 48, cachelines: 1, members: 4 */
	/* last cacheline: 48 bytes */
};
struct virtio_gpu_transfer_to_host_2d {
	struct virtio_gpu_ctrl_hdr hdr;                  /*     0    24 */
	struct virtio_gpu_rect     r;                    /*    24    16 */
	uint64_t                   offset;               /*    40     8 */
	uint32_t                   resource_id;          /*    48     4 */
	uint32_t                   padding;              /*    52     4 */

	/* size: 56, cachelines: 1, members: 5 */
	/* last cacheline: 56 bytes */
};
struct virtio_gpu_mem_entry {
	uint64_t                   addr;                 /*     0     8 */
	uint32_t                   length;               /*     8     4 */
	uint32_t                   padding;              /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct virtio_gpu_resource_attach_backing {
	struct virtio_gpu_ctrl_hdr hdr;                  /*     0    24 */
	uint32_t                   resource_id;          /*    24     4 */
	uint32_t                   nr_entries;           /*    28     4 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct virtio_gpu_resource_detach_backing {
	struct virtio_gpu_ctrl_hdr hdr;                  /*     0    24 */
	uint32_t                   resource_id;          /*    24     4 */
	uint32_t                   padding;              /*    28     4 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct virtio_gpu_display_one {
	struct virtio_gpu_rect     r;                    /*     0    16 */
	uint32_t                   enabled;              /*    16     4 */
	uint32_t                   flags;                /*    20     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct virtio_gpu_resp_display_info {
	struct virtio_gpu_ctrl_hdr hdr;                  /*     0    24 */
	struct virtio_gpu_display_one pmodes[16];        /*    24   384 */

	/* size: 408, cachelines: 7, members: 2 */
	/* last cacheline: 24 bytes */
};
struct virtio_gpu_config {
	uint32_t                   events_read;          /*     0     4 */
	uint32_t                   events_clear;         /*     4     4 */
	uint32_t                   num_scanouts;         /*     8     4 */
	uint32_t                   num_capsets;          /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct virtio_gpu_simple_resource {
	uint32_t                   resource_id;          /*     0     4 */
	uint32_t                   width;                /*     4     4 */
	uint32_t                   height;               /*     8     4 */
	uint32_t                   format;               /*    12     4 */
	uint64_t *                 addrs;                /*    16     8 */
	struct iovec *             iov;                  /*    24     8 */
	unsigned int               iov_cnt;              /*    32     4 */
	uint32_t                   scanout_bitmask;      /*    36     4 */
	pixman_image_t *           image;                /*    40     8 */
	struct {
		struct virtio_gpu_simple_resource * tqe_next; /*    48     8 */
		struct virtio_gpu_simple_resource * * tqe_prev; /*    56     8 */
	} next;                                          /*    48    16 */

	/* size: 64, cachelines: 1, members: 10 */
};
struct virtio_gpu_scanout {
	QemuConsole *              con;                  /*     0     8 */
	DisplaySurface *           ds;                   /*     8     8 */
	uint32_t                   width;                /*    16     4 */
	uint32_t                   height;               /*    20     4 */
	int                        x;                    /*    24     4 */
	int                        y;                    /*    28     4 */
	int                        invalidate;           /*    32     4 */
	uint32_t                   resource_id;          /*    36     4 */
	struct virtio_gpu_update_cursor cursor;          /*    40    56 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	QEMUCursor *               current_cursor;       /*    96     8 */

	/* size: 104, cachelines: 2, members: 10 */
	/* last cacheline: 40 bytes */
};
struct virtio_gpu_requested_state {
	uint32_t                   width;                /*     0     4 */
	uint32_t                   height;               /*     4     4 */
	int                        x;                    /*     8     4 */
	int                        y;                    /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct virtio_gpu_conf {
	uint32_t                   max_outputs;          /*     0     4 */
	uint32_t                   flags;                /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct virtio_gpu_ctrl_command {
	VirtQueueElement           elem;                 /*     0    48 */
	VirtQueue *                vq;                   /*    48     8 */
	struct virtio_gpu_ctrl_hdr cmd_hdr;              /*    56    24 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	uint32_t                   error;                /*    80     4 */
	_Bool                      waiting;              /*    84     1 */
	_Bool                      finished;             /*    85     1 */

	/* XXX 2 bytes hole, try to pack */

	struct {
		struct virtio_gpu_ctrl_command * tqe_next; /*    88     8 */
		struct virtio_gpu_ctrl_command * * tqe_prev; /*    96     8 */
	} next;                                          /*    88    16 */

	/* size: 104, cachelines: 2, members: 7 */
	/* sum members: 102, holes: 1, sum holes: 2 */
	/* last cacheline: 40 bytes */
};
struct VirtIOGPU {
	VirtIODevice               parent_obj;           /*     0   224 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	QEMUBH *                   ctrl_bh;              /*   224     8 */
	QEMUBH *                   cursor_bh;            /*   232     8 */
	VirtQueue *                ctrl_vq;              /*   240     8 */
	VirtQueue *                cursor_vq;            /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	int                        enable;               /*   256     4 */
	int                        config_size;          /*   260     4 */
	DeviceState *              qdev;                 /*   264     8 */
	struct {
		struct virtio_gpu_simple_resource * tqh_first; /*   272     8 */
		struct virtio_gpu_simple_resource * * tqh_last; /*   280     8 */
	} reslist;                                       /*   272    16 */
	struct {
		struct virtio_gpu_ctrl_command * tqh_first; /*   288     8 */
		struct virtio_gpu_ctrl_command * * tqh_last; /*   296     8 */
	} cmdq;                                          /*   288    16 */
	struct {
		struct virtio_gpu_ctrl_command * tqh_first; /*   304     8 */
		struct virtio_gpu_ctrl_command * * tqh_last; /*   312     8 */
	} fenceq;                                        /*   304    16 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	struct virtio_gpu_scanout  scanout[16];          /*   320  1664 */
	/* --- cacheline 31 boundary (1984 bytes) --- */
	struct virtio_gpu_requested_state req_state[16]; /*  1984   256 */
	/* --- cacheline 35 boundary (2240 bytes) --- */
	struct virtio_gpu_conf     conf;                 /*  2240     8 */
	int                        enabled_output_bitmask; /*  2248     4 */
	struct virtio_gpu_config   virtio_config;        /*  2252    16 */
	_Bool                      use_virgl_renderer;   /*  2268     1 */
	_Bool                      renderer_inited;      /*  2269     1 */

	/* XXX 2 bytes hole, try to pack */

	int                        renderer_blocked;     /*  2272     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUTimer *                fence_poll;           /*  2280     8 */
	QEMUTimer *                print_stats;          /*  2288     8 */
	uint32_t                   inflight;             /*  2296     4 */
	struct {
		uint32_t           max_inflight;         /*  2300     4 */
		/* --- cacheline 36 boundary (2304 bytes) --- */
		uint32_t           requests;             /*  2304     4 */
		uint32_t           req_3d;               /*  2308     4 */
		uint32_t           bytes_3d;             /*  2312     4 */
	} stats;                                         /*  2300    16 */

	/* XXX 4 bytes hole, try to pack */

	Error *                    migration_blocker;    /*  2320     8 */

	/* size: 2328, cachelines: 37, members: 24 */
	/* sum members: 2318, holes: 3, sum holes: 10 */
	/* last cacheline: 24 bytes */
};
struct PCIDeviceClass {
	DeviceClass                parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	void                       (*realize)(PCIDevice *, Error * *); /*   192     8 */
	int                        (*init)(PCIDevice *); /*   200     8 */
	PCIUnregisterFunc *        exit;                 /*   208     8 */
	PCIConfigReadFunc *        config_read;          /*   216     8 */
	PCIConfigWriteFunc *       config_write;         /*   224     8 */
	uint16_t                   vendor_id;            /*   232     2 */
	uint16_t                   device_id;            /*   234     2 */
	uint8_t                    revision;             /*   236     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   class_id;             /*   238     2 */
	uint16_t                   subsystem_vendor_id;  /*   240     2 */
	uint16_t                   subsystem_id;         /*   242     2 */
	int                        is_bridge;            /*   244     4 */
	int                        is_express;           /*   248     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 4 boundary (256 bytes) --- */
	const char  *              romfile;              /*   256     8 */

	/* size: 264, cachelines: 5, members: 15 */
	/* sum members: 259, holes: 2, sum holes: 5 */
	/* last cacheline: 8 bytes */
};
struct VirtIOPCIProxy {
	PCIDevice                  pci_dev;              /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	MemoryRegion               bar;                  /*  2288   256 */
	/* --- cacheline 39 boundary (2496 bytes) was 48 bytes ago --- */
	VirtIOPCIRegion            common;               /*  2544   272 */
	/* --- cacheline 44 boundary (2816 bytes) --- */
	VirtIOPCIRegion            isr;                  /*  2816   272 */
	/* --- cacheline 48 boundary (3072 bytes) was 16 bytes ago --- */
	VirtIOPCIRegion            device;               /*  3088   272 */
	/* --- cacheline 52 boundary (3328 bytes) was 32 bytes ago --- */
	VirtIOPCIRegion            notify;               /*  3360   272 */
	/* --- cacheline 56 boundary (3584 bytes) was 48 bytes ago --- */
	VirtIOPCIRegion            notify_pio;           /*  3632   272 */
	/* --- cacheline 61 boundary (3904 bytes) --- */
	MemoryRegion               modern_bar;           /*  3904   256 */
	/* --- cacheline 65 boundary (4160 bytes) --- */
	MemoryRegion               io_bar;               /*  4160   256 */
	/* --- cacheline 69 boundary (4416 bytes) --- */
	MemoryRegion               modern_cfg;           /*  4416   256 */
	/* --- cacheline 73 boundary (4672 bytes) --- */
	AddressSpace               modern_as;            /*  4672   272 */
	/* --- cacheline 77 boundary (4928 bytes) was 16 bytes ago --- */
	uint32_t                   legacy_io_bar_idx;    /*  4944     4 */
	uint32_t                   msix_bar_idx;         /*  4948     4 */
	uint32_t                   modern_io_bar_idx;    /*  4952     4 */
	uint32_t                   modern_mem_bar_idx;   /*  4956     4 */
	int                        config_cap;           /*  4960     4 */
	uint32_t                   flags;                /*  4964     4 */
	_Bool                      disable_modern;       /*  4968     1 */
	_Bool                      ignore_backend_features; /*  4969     1 */

	/* XXX 2 bytes hole, try to pack */

	OnOffAuto                  disable_legacy;       /*  4972     4 */
	uint32_t                   class_code;           /*  4976     4 */
	uint32_t                   nvectors;             /*  4980     4 */
	uint32_t                   dfselect;             /*  4984     4 */
	uint32_t                   gfselect;             /*  4988     4 */
	/* --- cacheline 78 boundary (4992 bytes) --- */
	uint32_t                   guest_features[2];    /*  4992     8 */
	VirtIOPCIQueue             vqs[1024];            /*  5000 28672 */
	/* --- cacheline 526 boundary (33664 bytes) was 8 bytes ago --- */
	VirtIOIRQFD *              vector_irqfd;         /* 33672     8 */
	int                        nvqs_with_notifiers;  /* 33680     4 */

	/* XXX 4 bytes hole, try to pack */

	VirtioBusState             bus;                  /* 33688   112 */

	/* size: 33808, cachelines: 529, members: 29 */
	/* sum members: 33794, holes: 2, sum holes: 6 */
	/* padding: 8 */
	/* last cacheline: 16 bytes */
};
struct VirtIOGPUPCI {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VirtIOGPU                  vdev;                 /* 33808  2328 */

	/* size: 36144, cachelines: 565, members: 2 */
	/* padding: 8 */
	/* last cacheline: 48 bytes */
};
struct VirtioPCIClass {
	PCIDeviceClass             parent_class;         /*     0   264 */
	/* --- cacheline 4 boundary (256 bytes) was 8 bytes ago --- */
	DeviceRealize              parent_dc_realize;    /*   264     8 */
	void                       (*realize)(VirtIOPCIProxy *, Error * *); /*   272     8 */

	/* size: 280, cachelines: 5, members: 3 */
	/* last cacheline: 24 bytes */
};
struct VirtIOPCIRegion {
	MemoryRegion               mr;                   /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint32_t                   offset;               /*   256     4 */
	uint32_t                   size;                 /*   260     4 */
	uint32_t                   type;                 /*   264     4 */

	/* size: 272, cachelines: 5, members: 4 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct VirtIOPCIQueue {
	uint16_t                   num;                  /*     0     2 */
	_Bool                      enabled;              /*     2     1 */

	/* XXX 1 byte hole, try to pack */

	uint32_t                   desc[2];              /*     4     8 */
	uint32_t                   avail[2];             /*    12     8 */
	uint32_t                   used[2];              /*    20     8 */

	/* size: 28, cachelines: 1, members: 5 */
	/* sum members: 27, holes: 1, sum holes: 1 */
	/* last cacheline: 28 bytes */
};
struct VirtIOVGA {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VirtIOGPU                  vdev;                 /* 33808  2328 */

	/* XXX 8 bytes hole, try to pack */

	/* --- cacheline 564 boundary (36096 bytes) was 48 bytes ago --- */
	VGACommonState             vga;                  /* 36144 68336 */
	/* --- cacheline 1632 boundary (104448 bytes) was 32 bytes ago --- */
	MemoryRegion               vga_mrs[3];           /* 104480   768 */

	/* size: 105248, cachelines: 1645, members: 4 */
	/* sum members: 105240, holes: 1, sum holes: 8 */
	/* last cacheline: 32 bytes */
};
struct APICCommonState {
	DeviceState                parent_obj;           /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	MemoryRegion               io_memory;            /*   112   256 */
	/* --- cacheline 5 boundary (320 bytes) was 48 bytes ago --- */
	X86CPU *                   cpu;                  /*   368     8 */
	uint32_t                   apicbase;             /*   376     4 */
	uint8_t                    id;                   /*   380     1 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 6 boundary (384 bytes) --- */
	uint32_t                   initial_apic_id;      /*   384     4 */
	uint8_t                    version;              /*   388     1 */
	uint8_t                    arb_id;               /*   389     1 */
	uint8_t                    tpr;                  /*   390     1 */

	/* XXX 1 byte hole, try to pack */

	uint32_t                   spurious_vec;         /*   392     4 */
	uint8_t                    log_dest;             /*   396     1 */
	uint8_t                    dest_mode;            /*   397     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   isr[8];               /*   400    32 */
	uint32_t                   tmr[8];               /*   432    32 */
	/* --- cacheline 7 boundary (448 bytes) was 16 bytes ago --- */
	uint32_t                   irr[8];               /*   464    32 */
	uint32_t                   lvt[6];               /*   496    24 */
	/* --- cacheline 8 boundary (512 bytes) was 8 bytes ago --- */
	uint32_t                   esr;                  /*   520     4 */
	uint32_t                   icr[2];               /*   524     8 */
	uint32_t                   divide_conf;          /*   532     4 */
	int                        count_shift;          /*   536     4 */
	uint32_t                   initial_count;        /*   540     4 */
	int64_t                    initial_count_load_time; /*   544     8 */
	int64_t                    next_time;            /*   552     8 */
	QEMUTimer *                timer;                /*   560     8 */
	int64_t                    timer_expiry;         /*   568     8 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	int                        sipi_vector;          /*   576     4 */
	int                        wait_for_sipi;        /*   580     4 */
	uint32_t                   vapic_control;        /*   584     4 */

	/* XXX 4 bytes hole, try to pack */

	DeviceState *              vapic;                /*   592     8 */
	hwaddr                     vapic_paddr;          /*   600     8 */
	_Bool                      legacy_instance_id;   /*   608     1 */

	/* Force padding: */
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;

	/* size: 624, cachelines: 10, members: 31 */
	/* sum members: 599, holes: 4, sum holes: 10 */
	/* padding: 15 */
	/* last cacheline: 48 bytes */
};
struct APICCommonClass {
	DeviceClass                parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	DeviceRealize              realize;              /*   192     8 */
	DeviceUnrealize            unrealize;            /*   200     8 */
	void                       (*set_base)(APICCommonState *, uint64_t); /*   208     8 */
	void                       (*set_tpr)(APICCommonState *, uint8_t); /*   216     8 */
	uint8_t                    (*get_tpr)(APICCommonState *); /*   224     8 */
	void                       (*enable_tpr_reporting)(APICCommonState *, _Bool); /*   232     8 */
	void                       (*vapic_base_update)(APICCommonState *); /*   240     8 */
	void                       (*external_nmi)(APICCommonState *); /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	void                       (*pre_save)(APICCommonState *); /*   256     8 */
	void                       (*post_load)(APICCommonState *); /*   264     8 */
	void                       (*reset)(APICCommonState *); /*   272     8 */
	void                       (*send_msi)(MSIMessage *); /*   280     8 */

	/* size: 288, cachelines: 5, members: 13 */
	/* last cacheline: 32 bytes */
};
struct VAPICState {
	uint8_t                    tpr;                  /*     0     1 */
	uint8_t                    isr;                  /*     1     1 */
	uint8_t                    zero;                 /*     2     1 */
	uint8_t                    irr;                  /*     3     1 */
	uint8_t                    enabled;              /*     4     1 */

	/* size: 5, cachelines: 1, members: 5 */
	/* last cacheline: 5 bytes */
};
struct ISADevice {
	DeviceState                parent_obj;           /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	uint32_t                   isairq[2];            /*   112     8 */
	int                        nirqs;                /*   120     4 */
	int                        ioport_id;            /*   124     4 */

	/* size: 128, cachelines: 2, members: 4 */
};
struct PCMachineState {
	MachineState               parent_obj;           /*     0   208 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	MemoryHotplugState         hotplug_memory;       /*   208   272 */
	/* --- cacheline 7 boundary (448 bytes) was 32 bytes ago --- */
	Notifier                   machine_done;         /*   480    24 */
	HotplugHandler *           acpi_dev;             /*   504     8 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	ISADevice *                rtc;                  /*   512     8 */
	PCIBus *                   bus;                  /*   520     8 */
	FWCfgState *               fw_cfg;               /*   528     8 */
	qemu_irq *                 gsi;                  /*   536     8 */
	uint64_t                   max_ram_below_4g;     /*   544     8 */
	OnOffAuto                  vmport;               /*   552     4 */
	OnOffAuto                  smm;                  /*   556     4 */
	AcpiNVDIMMState            acpi_nvdimm_state;    /*   560   288 */
	/* --- cacheline 13 boundary (832 bytes) was 16 bytes ago --- */
	_Bool                      acpi_build_enabled;   /*   848     1 */

	/* XXX 7 bytes hole, try to pack */

	ram_addr_t                 below_4g_mem_size;    /*   856     8 */
	ram_addr_t                 above_4g_mem_size;    /*   864     8 */
	_Bool                      apic_xrupt_override;  /*   872     1 */

	/* XXX 3 bytes hole, try to pack */

	unsigned int               apic_id_limit;        /*   876     4 */
	CPUArchIdList *            possible_cpus;        /*   880     8 */
	uint16_t                   boot_cpus;            /*   888     2 */

	/* XXX 6 bytes hole, try to pack */

	/* --- cacheline 14 boundary (896 bytes) --- */
	uint64_t                   numa_nodes;           /*   896     8 */
	uint64_t *                 node_mem;             /*   904     8 */
	AddressSpace *             ioapic_as;            /*   912     8 */

	/* size: 928, cachelines: 15, members: 22 */
	/* sum members: 904, holes: 3, sum holes: 16 */
	/* padding: 8 */
	/* last cacheline: 32 bytes */
};
struct MemoryHotplugState {
	hwaddr                     base;                 /*     0     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               mr;                   /*    16   256 */

	/* size: 272, cachelines: 5, members: 2 */
	/* sum members: 264, holes: 1, sum holes: 8 */
	/* last cacheline: 16 bytes */
};
struct NvdimmFitBuffer {
	GArray *                   fit;                  /*     0     8 */
	_Bool                      dirty;                /*     8     1 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct AcpiNVDIMMState {
	_Bool                      is_enabled;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	GArray *                   dsm_mem;              /*     8     8 */
	NvdimmFitBuffer            fit_buf;              /*    16    16 */
	MemoryRegion               io_mr;                /*    32   256 */

	/* size: 288, cachelines: 5, members: 4 */
	/* sum members: 281, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct SysBusDevice {
	DeviceState                parent_obj;           /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	int                        num_mmio;             /*   112     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		hwaddr             addr;                 /*   120     8 */
		/* --- cacheline 2 boundary (128 bytes) --- */
		MemoryRegion *     memory;               /*   128     8 */
	} mmio[32]; /*   120   512 */
	/* --- cacheline 9 boundary (576 bytes) was 56 bytes ago --- */
	int                        num_pio;              /*   632     4 */
	uint32_t                   pio[32];              /*   636   128 */

	/* size: 768, cachelines: 12, members: 5 */
	/* sum members: 760, holes: 1, sum holes: 4 */
	/* padding: 4 */
};
struct SysBusDeviceClass {
	DeviceClass                parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        (*init)(SysBusDevice *); /*   192     8 */
	char *                     (*explicit_ofw_unit_address)(const SysBusDevice  *); /*   200     8 */
	void                       (*connect_irq_notifier)(SysBusDevice *, qemu_irq); /*   208     8 */

	/* size: 216, cachelines: 4, members: 4 */
	/* last cacheline: 24 bytes */
};
struct IOAPICCommonState {
	SysBusDevice               busdev;               /*     0   768 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	MemoryRegion               io_memory;            /*   768   256 */
	/* --- cacheline 16 boundary (1024 bytes) --- */
	uint8_t                    id;                   /*  1024     1 */
	uint8_t                    ioregsel;             /*  1025     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   irr;                  /*  1028     4 */
	uint64_t                   ioredtbl[24];         /*  1032   192 */
	/* --- cacheline 19 boundary (1216 bytes) was 8 bytes ago --- */
	Notifier                   machine_done;         /*  1224    24 */
	uint8_t                    version;              /*  1248     1 */

	/* Force padding: */
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;

	/* size: 1264, cachelines: 20, members: 8 */
	/* sum members: 1247, holes: 1, sum holes: 2 */
	/* padding: 15 */
	/* last cacheline: 48 bytes */
};
struct IOAPICCommonClass {
	SysBusDeviceClass          parent_class;         /*     0   216 */
	/* --- cacheline 3 boundary (192 bytes) was 24 bytes ago --- */
	DeviceRealize              realize;              /*   216     8 */
	void                       (*pre_save)(IOAPICCommonState *); /*   224     8 */
	void                       (*post_load)(IOAPICCommonState *); /*   232     8 */

	/* size: 240, cachelines: 4, members: 4 */
	/* last cacheline: 48 bytes */
};
struct X86IOMMUState {
	SysBusDevice               busdev;               /*     0   768 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	_Bool                      intr_supported;       /*   768     1 */

	/* XXX 3 bytes hole, try to pack */

	IommuType                  type;                 /*   772     4 */
	struct {
		struct IEC_Notifier * lh_first;          /*   776     8 */
	} iec_notifiers;                                 /*   776     8 */

	/* size: 784, cachelines: 13, members: 4 */
	/* sum members: 781, holes: 1, sum holes: 3 */
	/* last cacheline: 16 bytes */
};
struct IEC_Notifier {
	iec_notify_fn              iec_notify;           /*     0     8 */
	void *                     private;              /*     8     8 */
	struct {
		struct IEC_Notifier * le_next;           /*    16     8 */
		struct IEC_Notifier * * le_prev;         /*    24     8 */
	} list;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct ioapic_entry_info {
	uint8_t                    masked;               /*     0     1 */
	uint8_t                    trig_mode;            /*     1     1 */
	uint16_t                   dest_idx;             /*     2     2 */
	uint8_t                    dest_mode;            /*     4     1 */
	uint8_t                    delivery_mode;        /*     5     1 */
	uint8_t                    vector;               /*     6     1 */

	/* XXX 1 byte hole, try to pack */

	uint32_t                   addr;                 /*     8     4 */
	uint32_t                   data;                 /*    12     4 */

	/* size: 16, cachelines: 1, members: 8 */
	/* sum members: 15, holes: 1, sum holes: 1 */
	/* last cacheline: 16 bytes */
};
struct PCIBus {
	BusState                   qbus;                 /*     0   104 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	PCIIOMMUFunc               iommu_fn;             /*   104     8 */
	void *                     iommu_opaque;         /*   112     8 */
	uint8_t                    devfn_min;            /*   120     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 2 boundary (128 bytes) --- */
	pci_set_irq_fn             set_irq;              /*   128     8 */
	pci_map_irq_fn             map_irq;              /*   136     8 */
	pci_route_irq_fn           route_intx_to_irq;    /*   144     8 */
	void *                     irq_opaque;           /*   152     8 */
	PCIDevice *                devices[256];         /*   160  2048 */
	/* --- cacheline 34 boundary (2176 bytes) was 32 bytes ago --- */
	PCIDevice *                parent_dev;           /*  2208     8 */
	MemoryRegion *             address_space_mem;    /*  2216     8 */
	MemoryRegion *             address_space_io;     /*  2224     8 */
	struct {
		struct PCIBus *    lh_first;             /*  2232     8 */
	} child;                                         /*  2232     8 */
	/* --- cacheline 35 boundary (2240 bytes) --- */
	struct {
		struct PCIBus *    le_next;              /*  2240     8 */
		struct PCIBus * *  le_prev;              /*  2248     8 */
	} sibling;                                       /*  2240    16 */
	int                        nirq;                 /*  2256     4 */

	/* XXX 4 bytes hole, try to pack */

	int *                      irq_count;            /*  2264     8 */
	Notifier                   machine_done;         /*  2272    24 */

	/* size: 2296, cachelines: 36, members: 17 */
	/* sum members: 2285, holes: 2, sum holes: 11 */
	/* last cacheline: 56 bytes */
};
struct ACPIOSTInfo {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	char *                     slot;                 /*    16     8 */
	ACPISlotType               slot_type;            /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    source;               /*    32     8 */
	int64_t                    status;               /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* sum members: 37, holes: 2, sum holes: 11 */
	/* last cacheline: 48 bytes */
};
struct ACPIOSTInfoList {
	ACPIOSTInfoList *          next;                 /*     0     8 */
	ACPIOSTInfo *              value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PCIINTxRoute {
	enum {
		PCI_INTX_ENABLED = 0,
		PCI_INTX_INVERTED = 1,
		PCI_INTX_DISABLED = 2,
	} mode;                                          /*     0     4 */
	int                        irq;                  /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct AcpiDeviceIf {
	Object                     Parent;               /*     0    40 */

	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
struct AcpiDeviceIfClass {
	InterfaceClass             parent_class;         /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	void                       (*ospm_status)(AcpiDeviceIf *, ACPIOSTInfoList * * *); /*   112     8 */
	void                       (*send_event)(AcpiDeviceIf *, AcpiEventStatusBits); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	void                       (*madt_cpu)(AcpiDeviceIf *, int, CPUArchIdList *, GArray *); /*   128     8 */

	/* size: 136, cachelines: 3, members: 4 */
	/* last cacheline: 8 bytes */
};
struct APMState {
	uint8_t                    apmc;                 /*     0     1 */
	uint8_t                    apms;                 /*     1     1 */

	/* XXX 6 bytes hole, try to pack */

	apm_ctrl_changed_t         callback;             /*     8     8 */
	void *                     arg;                  /*    16     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               io;                   /*    32   256 */

	/* size: 288, cachelines: 5, members: 5 */
	/* sum members: 274, holes: 2, sum holes: 14 */
	/* last cacheline: 32 bytes */
};
struct ACPIPMTimer {
	QEMUTimer *                timer;                /*     0     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               io;                   /*    16   256 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	int64_t                    overflow_time;        /*   272     8 */
	acpi_update_sci_fn         update_sci;           /*   280     8 */

	/* size: 288, cachelines: 5, members: 4 */
	/* sum members: 280, holes: 1, sum holes: 8 */
	/* last cacheline: 32 bytes */
};
struct ACPIPM1EVT {
	MemoryRegion               io;                   /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint16_t                   sts;                  /*   256     2 */
	uint16_t                   en;                   /*   258     2 */

	/* XXX 4 bytes hole, try to pack */

	acpi_update_sci_fn         update_sci;           /*   264     8 */

	/* size: 272, cachelines: 5, members: 4 */
	/* sum members: 268, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct ACPIPM1CNT {
	MemoryRegion               io;                   /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint16_t                   cnt;                  /*   256     2 */
	uint8_t                    s4_val;               /*   258     1 */

	/* Force padding: */
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;

	/* size: 272, cachelines: 5, members: 3 */
	/* padding: 13 */
	/* last cacheline: 16 bytes */
};
struct ACPIGPE {
	uint8_t                    len;                  /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	uint8_t *                  sts;                  /*     8     8 */
	uint8_t *                  en;                   /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct ACPIREGS {
	ACPIPMTimer                tmr;                  /*     0   288 */
	/* --- cacheline 4 boundary (256 bytes) was 32 bytes ago --- */
	ACPIGPE                    gpe;                  /*   288    24 */

	/* XXX 8 bytes hole, try to pack */

	/* --- cacheline 5 boundary (320 bytes) --- */
	struct {
		ACPIPM1EVT         evt;                  /*   320   272 */
		/* --- cacheline 9 boundary (576 bytes) was 16 bytes ago --- */
		ACPIPM1CNT         cnt;                  /*   592   272 */
	} pm1;                                           /*   320   544 */
	/* --- cacheline 13 boundary (832 bytes) was 32 bytes ago --- */
	Notifier                   wakeup;               /*   864    24 */

	/* size: 896, cachelines: 14, members: 4 */
	/* sum members: 880, holes: 1, sum holes: 8 */
	/* padding: 8 */
};
struct AcpiCpuStatus {
	struct CPUState *          cpu;                  /*     0     8 */
	uint64_t                   arch_id;              /*     8     8 */
	_Bool                      is_inserting;         /*    16     1 */
	_Bool                      is_removing;          /*    17     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   ost_event;            /*    20     4 */
	uint32_t                   ost_status;           /*    24     4 */

	/* size: 32, cachelines: 1, members: 6 */
	/* sum members: 26, holes: 1, sum holes: 2 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct CPUHotplugState {
	MemoryRegion               ctrl_reg;             /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint32_t                   selector;             /*   256     4 */
	uint8_t                    command;              /*   260     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   dev_count;            /*   264     4 */

	/* XXX 4 bytes hole, try to pack */

	AcpiCpuStatus *            devs;                 /*   272     8 */

	/* size: 288, cachelines: 5, members: 5 */
	/* sum members: 273, holes: 2, sum holes: 7 */
	/* padding: 8 */
	/* last cacheline: 32 bytes */
};
struct AcpiCpuHotplug {
	Object *                   device;               /*     0     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               io;                   /*    16   256 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	uint8_t                    sts[32];              /*   272    32 */

	/* size: 304, cachelines: 5, members: 3 */
	/* sum members: 296, holes: 1, sum holes: 8 */
	/* last cacheline: 48 bytes */
};
struct MemStatus {
	DeviceState *              dimm;                 /*     0     8 */
	_Bool                      is_enabled;           /*     8     1 */
	_Bool                      is_inserting;         /*     9     1 */
	_Bool                      is_removing;          /*    10     1 */

	/* XXX 1 byte hole, try to pack */

	uint32_t                   ost_event;            /*    12     4 */
	uint32_t                   ost_status;           /*    16     4 */

	/* size: 24, cachelines: 1, members: 6 */
	/* sum members: 19, holes: 1, sum holes: 1 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct MemHotplugState {
	_Bool                      is_enabled;           /*     0     1 */

	/* XXX 15 bytes hole, try to pack */

	MemoryRegion               io;                   /*    16   256 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	uint32_t                   selector;             /*   272     4 */
	uint32_t                   dev_count;            /*   276     4 */
	MemStatus *                devs;                 /*   280     8 */

	/* size: 288, cachelines: 5, members: 5 */
	/* sum members: 273, holes: 1, sum holes: 15 */
	/* last cacheline: 32 bytes */
};
struct TCOIORegs {
	struct {
		uint16_t           rld;                  /*     0     2 */
		uint8_t            din;                  /*     2     1 */
		uint8_t            dout;                 /*     3     1 */
		uint16_t           sts1;                 /*     4     2 */
		uint16_t           sts2;                 /*     6     2 */
		uint16_t           cnt1;                 /*     8     2 */
		uint16_t           cnt2;                 /*    10     2 */
		uint8_t            msg1;                 /*    12     1 */
		uint8_t            msg2;                 /*    13     1 */
		uint8_t            wdcnt;                /*    14     1 */

		/* XXX 1 byte hole, try to pack */

		uint16_t           tmr;                  /*    16     2 */
	} tco;                                           /*     0    18 */
	uint8_t                    sw_irq_gen;           /*    18     1 */

	/* XXX 5 bytes hole, try to pack */

	QEMUTimer *                tco_timer;            /*    24     8 */
	int64_t                    expire_time;          /*    32     8 */
	uint8_t                    timeouts_no;          /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	MemoryRegion               io;                   /*    48   256 */

	/* size: 304, cachelines: 5, members: 6 */
	/* sum members: 292, holes: 2, sum holes: 12 */
	/* last cacheline: 48 bytes */
};
struct ICH9LPCPMRegs {
	ACPIREGS                   acpi_regs;            /*     0   896 */
	/* --- cacheline 14 boundary (896 bytes) --- */
	MemoryRegion               io;                   /*   896   256 */
	/* --- cacheline 18 boundary (1152 bytes) --- */
	MemoryRegion               io_gpe;               /*  1152   256 */
	/* --- cacheline 22 boundary (1408 bytes) --- */
	MemoryRegion               io_smi;               /*  1408   256 */
	/* --- cacheline 26 boundary (1664 bytes) --- */
	uint32_t                   smi_en;               /*  1664     4 */
	uint32_t                   smi_en_wmask;         /*  1668     4 */
	uint32_t                   smi_sts;              /*  1672     4 */

	/* XXX 4 bytes hole, try to pack */

	qemu_irq                   irq;                  /*  1680     8 */
	uint32_t                   pm_io_base;           /*  1688     4 */

	/* XXX 4 bytes hole, try to pack */

	Notifier                   powerdown_notifier;   /*  1696    24 */
	_Bool                      cpu_hotplug_legacy;   /*  1720     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 27 boundary (1728 bytes) --- */
	AcpiCpuHotplug             gpe_cpu;              /*  1728   304 */
	/* --- cacheline 31 boundary (1984 bytes) was 48 bytes ago --- */
	CPUHotplugState            cpuhp_state;          /*  2032   288 */
	/* --- cacheline 36 boundary (2304 bytes) was 16 bytes ago --- */
	MemHotplugState            acpi_memory_hotplug;  /*  2320   288 */
	/* --- cacheline 40 boundary (2560 bytes) was 48 bytes ago --- */
	uint8_t                    disable_s3;           /*  2608     1 */
	uint8_t                    disable_s4;           /*  2609     1 */
	uint8_t                    s4_val;               /*  2610     1 */
	uint8_t                    smm_enabled;          /*  2611     1 */
	_Bool                      enable_tco;           /*  2612     1 */

	/* XXX 11 bytes hole, try to pack */

	/* --- cacheline 41 boundary (2624 bytes) --- */
	TCOIORegs                  tco_regs;             /*  2624   304 */

	/* size: 2928, cachelines: 46, members: 20 */
	/* sum members: 2902, holes: 4, sum holes: 26 */
	/* last cacheline: 48 bytes */
};
struct ICH9LPCState {
	PCIDevice                  d;                    /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	uint8_t                    irr[32][4];           /*  2288   128 */
	/* --- cacheline 37 boundary (2368 bytes) was 48 bytes ago --- */
	APMState                   apm;                  /*  2416   288 */
	/* --- cacheline 42 boundary (2688 bytes) was 16 bytes ago --- */
	ICH9LPCPMRegs              pm;                   /*  2704  2928 */
	/* --- cacheline 88 boundary (5632 bytes) --- */
	uint32_t                   sci_level;            /*  5632     4 */
	uint8_t                    sci_gsi;              /*  5636     1 */
	struct {
		_Bool              spkr_hi;              /*  5637     1 */
	} pin_strap;                                     /*  5637     1 */
	uint8_t                    chip_config[16384];   /*  5638 16384 */
	/* --- cacheline 344 boundary (22016 bytes) was 6 bytes ago --- */
	uint8_t                    rst_cnt;              /* 22022     1 */

	/* XXX 9 bytes hole, try to pack */

	MemoryRegion               rst_cnt_mem;          /* 22032   256 */
	/* --- cacheline 348 boundary (22272 bytes) was 16 bytes ago --- */
	ISABus *                   isa_bus;              /* 22288     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               rcrb_mem;             /* 22304   256 */
	/* --- cacheline 352 boundary (22528 bytes) was 32 bytes ago --- */
	Notifier                   machine_ready;        /* 22560    24 */
	qemu_irq                   gsi[24];              /* 22584   192 */

	/* size: 22784, cachelines: 356, members: 14 */
	/* sum members: 22759, holes: 2, sum holes: 17 */
	/* padding: 8 */
};
struct VMPortState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	MemoryRegion               io;                   /*   128   256 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	VMPortReadFunc *           func[44];             /*   384   352 */
	/* --- cacheline 11 boundary (704 bytes) was 32 bytes ago --- */
	void *                     opaque[44];           /*   736   352 */

	/* size: 1088, cachelines: 17, members: 4 */
};
struct Peer {
	int                        nb_eventfds;          /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	EventNotifier *            eventfds;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct MSIVector {
	PCIDevice *                pdev;                 /*     0     8 */
	int                        virq;                 /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct IVShmemState {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	uint32_t                   features;             /*  2288     4 */

	/* XXX 4 bytes hole, try to pack */

	HostMemoryBackend *        hostmem;              /*  2296     8 */
	/* --- cacheline 36 boundary (2304 bytes) --- */
	CharBackend                server_chr;           /*  2304    48 */
	uint32_t                   intrmask;             /*  2352     4 */
	uint32_t                   intrstatus;           /*  2356     4 */
	int                        vm_id;                /*  2360     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 37 boundary (2368 bytes) --- */
	MemoryRegion               ivshmem_mmio;         /*  2368   256 */
	/* --- cacheline 41 boundary (2624 bytes) --- */
	MemoryRegion *             ivshmem_bar2;         /*  2624     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               server_bar2;          /*  2640   256 */
	/* --- cacheline 45 boundary (2880 bytes) was 16 bytes ago --- */
	Peer *                     peers;                /*  2896     8 */
	int                        nb_peers;             /*  2904     4 */
	uint32_t                   vectors;              /*  2908     4 */
	MSIVector *                msi_vectors;          /*  2912     8 */
	uint64_t                   msg_buf;              /*  2920     8 */
	int                        msg_buffered_bytes;   /*  2928     4 */
	OnOffAuto                  master;               /*  2932     4 */
	Error *                    migration_blocker;    /*  2936     8 */
	/* --- cacheline 46 boundary (2944 bytes) --- */
	char *                     role;                 /*  2944     8 */
	char *                     shmobj;               /*  2952     8 */
	char *                     sizearg;              /*  2960     8 */
	size_t                     legacy_size;          /*  2968     8 */
	uint32_t                   not_legacy_32bit;     /*  2976     4 */

	/* Force padding: */
	uint32_t                   :32;
	uint32_t                   :32;
	uint32_t                   :32;

	/* size: 2992, cachelines: 47, members: 23 */
	/* sum members: 2964, holes: 3, sum holes: 16 */
	/* padding: 12 */
	/* last cacheline: 48 bytes */
};
struct PVPanicState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	MemoryRegion               io;                   /*   128   256 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	uint16_t                   ioport;               /*   384     2 */

	/* Force padding: */
	uint16_t                   :16;
	uint16_t                   :16;
	uint16_t                   :16;
	uint16_t                   :16;
	uint16_t                   :16;
	uint16_t                   :16;
	uint16_t                   :16;

	/* size: 400, cachelines: 7, members: 3 */
	/* padding: 14 */
	/* last cacheline: 16 bytes */
};
struct dma_state {
	dma_addr_t                 src;                  /*     0     8 */
	dma_addr_t                 dst;                  /*     8     8 */
	dma_addr_t                 cnt;                  /*    16     8 */
	dma_addr_t                 cmd;                  /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct HvSintRoute {
	uint32_t                   sint;                 /*     0     4 */
	uint32_t                   vcpu_id;              /*     4     4 */
	int                        gsi;                  /*     8     4 */
	EventNotifier              sint_set_notifier;    /*    12     8 */
	EventNotifier              sint_ack_notifier;    /*    20     8 */

	/* XXX 4 bytes hole, try to pack */

	HvSintAckClb               sint_ack_clb;         /*    32     8 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct HypervTestDev {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	MemoryRegion               sint_control;         /*   128   256 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	HvSintRoute *              sint_route[64];       /*   384   512 */

	/* size: 896, cachelines: 14, members: 3 */
};
struct virtio_net_config {
	uint8_t                    mac[6];               /*     0     6 */
	uint16_t                   status;               /*     6     2 */
	uint16_t                   max_virtqueue_pairs;  /*     8     2 */
	uint16_t                   mtu;                  /*    10     2 */

	/* size: 12, cachelines: 1, members: 4 */
	/* last cacheline: 12 bytes */
};
struct virtio_net_hdr {
	uint8_t                    flags;                /*     0     1 */
	uint8_t                    gso_type;             /*     1     1 */
	__virtio16                 hdr_len;              /*     2     2 */
	__virtio16                 gso_size;             /*     4     2 */
	__virtio16                 csum_start;           /*     6     2 */
	__virtio16                 csum_offset;          /*     8     2 */

	/* size: 10, cachelines: 1, members: 6 */
	/* last cacheline: 10 bytes */
};
struct virtio_net_hdr_mrg_rxbuf {
	struct virtio_net_hdr      hdr;                  /*     0    10 */
	__virtio16                 num_buffers;          /*    10     2 */

	/* size: 12, cachelines: 1, members: 2 */
	/* last cacheline: 12 bytes */
};
struct virtio_net_ctrl_hdr {
	uint8_t                    class;                /*     0     1 */
	uint8_t                    cmd;                  /*     1     1 */

	/* size: 2, cachelines: 1, members: 2 */
	/* last cacheline: 2 bytes */
};
struct virtio_net_ctrl_mac {
	__virtio32                 entries;              /*     0     4 */
	uint8_t                    macs[][6];            /*     4     0 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
struct virtio_net_ctrl_mq {
	__virtio16                 virtqueue_pairs;      /*     0     2 */

	/* size: 2, cachelines: 1, members: 1 */
	/* last cacheline: 2 bytes */
};
struct virtio_net_conf {
	uint32_t                   txtimer;              /*     0     4 */
	int32_t                    txburst;              /*     4     4 */
	char *                     tx;                   /*     8     8 */
	uint16_t                   rx_queue_size;        /*    16     2 */

	/* size: 24, cachelines: 1, members: 4 */
	/* padding: 6 */
	/* last cacheline: 24 bytes */
};
struct VirtIONetQueue {
	VirtQueue *                rx_vq;                /*     0     8 */
	VirtQueue *                tx_vq;                /*     8     8 */
	QEMUTimer *                tx_timer;             /*    16     8 */
	QEMUBH *                   tx_bh;                /*    24     8 */
	int                        tx_waiting;           /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		VirtQueueElement * elem;                 /*    40     8 */
	} async_tx;                                      /*    40     8 */
	struct VirtIONet *         n;                    /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct VirtIONet {
	VirtIODevice               parent_obj;           /*     0   224 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	uint8_t                    mac[6];               /*   224     6 */
	uint16_t                   status;               /*   230     2 */
	VirtIONetQueue *           vqs;                  /*   232     8 */
	VirtQueue *                ctrl_vq;              /*   240     8 */
	NICState *                 nic;                  /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint32_t                   tx_timeout;           /*   256     4 */
	int32_t                    tx_burst;             /*   260     4 */
	uint32_t                   has_vnet_hdr;         /*   264     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     host_hdr_len;         /*   272     8 */
	size_t                     guest_hdr_len;        /*   280     8 */
	uint32_t                   host_features;        /*   288     4 */
	uint8_t                    has_ufo;              /*   292     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        mergeable_rx_bufs;    /*   296     4 */
	uint8_t                    promisc;              /*   300     1 */
	uint8_t                    allmulti;             /*   301     1 */
	uint8_t                    alluni;               /*   302     1 */
	uint8_t                    nomulti;              /*   303     1 */
	uint8_t                    nouni;                /*   304     1 */
	uint8_t                    nobcast;              /*   305     1 */
	uint8_t                    vhost_started;        /*   306     1 */

	/* XXX 5 bytes hole, try to pack */

	struct {
		uint32_t           in_use;               /*   312     4 */
		uint32_t           first_multi;          /*   316     4 */
		/* --- cacheline 5 boundary (320 bytes) --- */
		uint8_t            multi_overflow;       /*   320     1 */
		uint8_t            uni_overflow;         /*   321     1 */

		/* XXX 6 bytes hole, try to pack */

		uint8_t *          macs;                 /*   328     8 */
	} mac_table;                                     /*   312    24 */
	uint32_t *                 vlans;                /*   336     8 */
	virtio_net_conf            net_conf;             /*   344    24 */
	NICConf                    nic_conf;             /*   368  8216 */
	/* --- cacheline 134 boundary (8576 bytes) was 8 bytes ago --- */
	DeviceState *              qdev;                 /*  8584     8 */
	int                        multiqueue;           /*  8592     4 */
	uint16_t                   max_queues;           /*  8596     2 */
	uint16_t                   curr_queues;          /*  8598     2 */
	size_t                     config_size;          /*  8600     8 */
	char *                     netclient_name;       /*  8608     8 */
	char *                     netclient_type;       /*  8616     8 */
	uint64_t                   curr_guest_offloads;  /*  8624     8 */
	QEMUTimer *                announce_timer;       /*  8632     8 */
	/* --- cacheline 135 boundary (8640 bytes) --- */
	int                        announce_counter;     /*  8640     4 */
	_Bool                      needs_vnet_hdr_swap;  /*  8644     1 */

	/* size: 8648, cachelines: 136, members: 36 */
	/* sum members: 8633, holes: 3, sum holes: 12 */
	/* padding: 3 */
	/* last cacheline: 8 bytes */
};
struct VirtIOFeature {
	uint32_t                   flags;                /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     end;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct vhost_dev {
	MemoryListener             memory_listener;      /*     0   160 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	struct vhost_memory *      mem;                  /*   160     8 */
	int                        n_mem_sections;       /*   168     4 */

	/* XXX 4 bytes hole, try to pack */

	MemoryRegionSection *      mem_sections;         /*   176     8 */
	struct vhost_virtqueue *   vqs;                  /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        nvqs;                 /*   192     4 */
	int                        vq_index;             /*   196     4 */
	uint64_t                   features;             /*   200     8 */
	uint64_t                   acked_features;       /*   208     8 */
	uint64_t                   backend_features;     /*   216     8 */
	uint64_t                   protocol_features;    /*   224     8 */
	uint64_t                   max_queues;           /*   232     8 */
	_Bool                      started;              /*   240     1 */
	_Bool                      log_enabled;          /*   241     1 */

	/* XXX 6 bytes hole, try to pack */

	uint64_t                   log_size;             /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	Error *                    migration_blocker;    /*   256     8 */
	_Bool                      memory_changed;       /*   264     1 */

	/* XXX 7 bytes hole, try to pack */

	hwaddr                     mem_changed_start_addr; /*   272     8 */
	hwaddr                     mem_changed_end_addr; /*   280     8 */
	const VhostOps  *          vhost_ops;            /*   288     8 */
	void *                     opaque;               /*   296     8 */
	struct vhost_log *         log;                  /*   304     8 */
	struct {
		struct vhost_dev * le_next;              /*   312     8 */
		/* --- cacheline 5 boundary (320 bytes) --- */
		struct vhost_dev * * le_prev;            /*   320     8 */
	} entry;                                         /*   312    16 */

	/* size: 328, cachelines: 6, members: 23 */
	/* sum members: 311, holes: 3, sum holes: 17 */
	/* last cacheline: 8 bytes */
};
struct vhost_vring_file {
	unsigned int               index;                /*     0     4 */
	int                        fd;                   /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct vhost_scsi_target {
	int                        abi_version;          /*     0     4 */
	char                       vhost_wwpn[224];      /*     4   224 */
	/* --- cacheline 3 boundary (192 bytes) was 36 bytes ago --- */
	short unsigned int         vhost_tpgt;           /*   228     2 */
	short unsigned int         reserved;             /*   230     2 */

	/* size: 232, cachelines: 4, members: 4 */
	/* last cacheline: 40 bytes */
};
struct vhost_log {
	long long unsigned int     size;                 /*     0     8 */
	int                        refcnt;               /*     8     4 */
	int                        fd;                   /*    12     4 */
	vhost_log_chunk_t *        log;                  /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct vhost_memory {
	__u32                      nregions;             /*     0     4 */
	__u32                      padding;              /*     4     4 */
	struct vhost_memory_region regions[];            /*     8     0 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct vhost_vring_addr {
	unsigned int               index;                /*     0     4 */
	unsigned int               flags;                /*     4     4 */
	__u64                      desc_user_addr;       /*     8     8 */
	__u64                      used_user_addr;       /*    16     8 */
	__u64                      avail_user_addr;      /*    24     8 */
	__u64                      log_guest_addr;       /*    32     8 */

	/* size: 40, cachelines: 1, members: 6 */
	/* last cacheline: 40 bytes */
};
struct vhost_vring_state {
	unsigned int               index;                /*     0     4 */
	unsigned int               num;                  /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct VhostOps {
	VhostBackendType           backend_type;         /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	vhost_backend_init         vhost_backend_init;   /*     8     8 */
	vhost_backend_cleanup      vhost_backend_cleanup; /*    16     8 */
	vhost_backend_memslots_limit vhost_backend_memslots_limit; /*    24     8 */
	vhost_net_set_backend_op   vhost_net_set_backend; /*    32     8 */
	vhost_scsi_set_endpoint_op vhost_scsi_set_endpoint; /*    40     8 */
	vhost_scsi_clear_endpoint_op vhost_scsi_clear_endpoint; /*    48     8 */
	vhost_scsi_get_abi_version_op vhost_scsi_get_abi_version; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	vhost_set_log_base_op      vhost_set_log_base;   /*    64     8 */
	vhost_set_mem_table_op     vhost_set_mem_table;  /*    72     8 */
	vhost_set_vring_addr_op    vhost_set_vring_addr; /*    80     8 */
	vhost_set_vring_endian_op  vhost_set_vring_endian; /*    88     8 */
	vhost_set_vring_num_op     vhost_set_vring_num;  /*    96     8 */
	vhost_set_vring_base_op    vhost_set_vring_base; /*   104     8 */
	vhost_get_vring_base_op    vhost_get_vring_base; /*   112     8 */
	vhost_set_vring_kick_op    vhost_set_vring_kick; /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	vhost_set_vring_call_op    vhost_set_vring_call; /*   128     8 */
	vhost_set_vring_busyloop_timeout_op vhost_set_vring_busyloop_timeout; /*   136     8 */
	vhost_set_features_op      vhost_set_features;   /*   144     8 */
	vhost_get_features_op      vhost_get_features;   /*   152     8 */
	vhost_set_owner_op         vhost_set_owner;      /*   160     8 */
	vhost_reset_device_op      vhost_reset_device;   /*   168     8 */
	vhost_get_vq_index_op      vhost_get_vq_index;   /*   176     8 */
	vhost_set_vring_enable_op  vhost_set_vring_enable; /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	vhost_requires_shm_log_op  vhost_requires_shm_log; /*   192     8 */
	vhost_migration_done_op    vhost_migration_done; /*   200     8 */
	vhost_backend_can_merge_op vhost_backend_can_merge; /*   208     8 */
	vhost_vsock_set_guest_cid_op vhost_vsock_set_guest_cid; /*   216     8 */
	vhost_vsock_set_running_op vhost_vsock_set_running; /*   224     8 */

	/* size: 232, cachelines: 4, members: 29 */
	/* sum members: 228, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct vhost_net {
	struct vhost_dev           dev;                  /*     0   328 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	struct vhost_virtqueue     vqs[2];               /*   328   192 */
	/* --- cacheline 8 boundary (512 bytes) was 8 bytes ago --- */
	int                        backend;              /*   520     4 */

	/* XXX 4 bytes hole, try to pack */

	NetClientState *           nc;                   /*   528     8 */

	/* size: 536, cachelines: 9, members: 4 */
	/* sum members: 532, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct VhostNetOptions {
	VhostBackendType           backend_type;         /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	NetClientState *           net_backend;          /*     8     8 */
	uint32_t                   busyloop_timeout;     /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     opaque;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 24, holes: 2, sum holes: 8 */
	/* last cacheline: 32 bytes */
};
struct vhost_memory_region {
	__u64                      guest_phys_addr;      /*     0     8 */
	__u64                      memory_size;          /*     8     8 */
	__u64                      userspace_addr;       /*    16     8 */
	__u64                      flags_padding;        /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct vhost_virtqueue {
	int                        kick;                 /*     0     4 */
	int                        call;                 /*     4     4 */
	void *                     desc;                 /*     8     8 */
	void *                     avail;                /*    16     8 */
	void *                     used;                 /*    24     8 */
	int                        num;                  /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	long long unsigned int     desc_phys;            /*    40     8 */
	unsigned int               desc_size;            /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	long long unsigned int     avail_phys;           /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	unsigned int               avail_size;           /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	long long unsigned int     used_phys;            /*    72     8 */
	unsigned int               used_size;            /*    80     4 */
	EventNotifier              masked_notifier;      /*    84     8 */

	/* size: 96, cachelines: 2, members: 13 */
	/* sum members: 80, holes: 3, sum holes: 12 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct QEMUSGList {
	ScatterGatherEntry *       sg;                   /*     0     8 */
	int                        nsg;                  /*     8     4 */
	int                        nalloc;               /*    12     4 */
	size_t                     size;                 /*    16     8 */
	DeviceState *              dev;                  /*    24     8 */
	AddressSpace *             as;                   /*    32     8 */

	/* size: 40, cachelines: 1, members: 6 */
	/* last cacheline: 40 bytes */
};
struct virtio_scsi_cmd_req {
	uint8_t                    lun[8];               /*     0     8 */
	__virtio64                 tag;                  /*     8     8 */
	uint8_t                    task_attr;            /*    16     1 */
	uint8_t                    prio;                 /*    17     1 */
	uint8_t                    crn;                  /*    18     1 */
	uint8_t                    cdb[];                /*    19     0 */

	/* size: 19, cachelines: 1, members: 6 */
	/* last cacheline: 19 bytes */
} __attribute__((__packed__));
struct virtio_scsi_cmd_resp {
	__virtio32                 sense_len;            /*     0     4 */
	__virtio32                 resid;                /*     4     4 */
	__virtio16                 status_qualifier;     /*     8     2 */
	uint8_t                    status;               /*    10     1 */
	uint8_t                    response;             /*    11     1 */
	uint8_t                    sense[];              /*    12     0 */

	/* size: 12, cachelines: 1, members: 6 */
	/* last cacheline: 12 bytes */
};
struct virtio_scsi_ctrl_tmf_req {
	__virtio32                 type;                 /*     0     4 */
	__virtio32                 subtype;              /*     4     4 */
	uint8_t                    lun[8];               /*     8     8 */
	__virtio64                 tag;                  /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct virtio_scsi_ctrl_tmf_resp {
	uint8_t                    response;             /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
};
struct virtio_scsi_ctrl_an_req {
	__virtio32                 type;                 /*     0     4 */
	uint8_t                    lun[8];               /*     4     8 */
	__virtio32                 event_requested;      /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct virtio_scsi_ctrl_an_resp {
	__virtio32                 event_actual;         /*     0     4 */
	uint8_t                    response;             /*     4     1 */

	/* size: 5, cachelines: 1, members: 2 */
	/* last cacheline: 5 bytes */
} __attribute__((__packed__));
struct virtio_scsi_event {
	__virtio32                 event;                /*     0     4 */
	uint8_t                    lun[8];               /*     4     8 */
	__virtio32                 reason;               /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct virtio_scsi_config {
	uint32_t                   num_queues;           /*     0     4 */
	uint32_t                   seg_max;              /*     4     4 */
	uint32_t                   max_sectors;          /*     8     4 */
	uint32_t                   cmd_per_lun;          /*    12     4 */
	uint32_t                   event_info_size;      /*    16     4 */
	uint32_t                   sense_size;           /*    20     4 */
	uint32_t                   cdb_size;             /*    24     4 */
	uint16_t                   max_channel;          /*    28     2 */
	uint16_t                   max_target;           /*    30     2 */
	uint32_t                   max_lun;              /*    32     4 */

	/* size: 36, cachelines: 1, members: 10 */
	/* last cacheline: 36 bytes */
};
struct NotifierList {
	struct {
		struct Notifier *  lh_first;             /*     0     8 */
	} notifiers;                                     /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct VirtIOSCSIConf {
	uint32_t                   num_queues;           /*     0     4 */
	uint32_t                   max_sectors;          /*     4     4 */
	uint32_t                   cmd_per_lun;          /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     vhostfd;              /*    16     8 */
	char *                     wwpn;                 /*    24     8 */
	uint32_t                   boot_tpgt;            /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	IOThread *                 iothread;             /*    40     8 */

	/* size: 48, cachelines: 1, members: 7 */
	/* sum members: 40, holes: 2, sum holes: 8 */
	/* last cacheline: 48 bytes */
};
struct ScatterGatherEntry {
	dma_addr_t                 base;                 /*     0     8 */
	dma_addr_t                 len;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct SCSIBus {
	BusState                   qbus;                 /*     0   104 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	int                        busnr;                /*   104     4 */
	SCSISense                  unit_attention;       /*   108     3 */

	/* XXX 1 byte hole, try to pack */

	const SCSIBusInfo  *       info;                 /*   112     8 */

	/* size: 120, cachelines: 2, members: 4 */
	/* sum members: 119, holes: 1, sum holes: 1 */
	/* last cacheline: 56 bytes */
};
struct SCSIBusInfo {
	int                        tcq;                  /*     0     4 */
	int                        max_channel;          /*     4     4 */
	int                        max_target;           /*     8     4 */
	int                        max_lun;              /*    12     4 */
	int                        (*parse_cdb)(SCSIDevice *, SCSICommand *, uint8_t *, void *); /*    16     8 */
	void                       (*transfer_data)(SCSIRequest *, uint32_t); /*    24     8 */
	void                       (*complete)(SCSIRequest *, uint32_t, size_t); /*    32     8 */
	void                       (*cancel)(SCSIRequest *); /*    40     8 */
	void                       (*change)(SCSIBus *, SCSIDevice *, SCSISense); /*    48     8 */
	QEMUSGList *               (*get_sg_list)(SCSIRequest *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*save_request)(QEMUFile *, SCSIRequest *); /*    64     8 */
	void *                     (*load_request)(QEMUFile *, SCSIRequest *); /*    72     8 */
	void                       (*free_request)(SCSIBus *, void *); /*    80     8 */

	/* size: 88, cachelines: 2, members: 13 */
	/* last cacheline: 24 bytes */
};
struct SCSICommand {
	uint8_t                    buf[16];              /*     0    16 */
	int                        len;                  /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     xfer;                 /*    24     8 */
	uint64_t                   lba;                  /*    32     8 */
	enum SCSIXferMode          mode;                 /*    40     4 */

	/* size: 48, cachelines: 1, members: 5 */
	/* sum members: 40, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct SCSIDevice {
	DeviceState                qdev;                 /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	VMChangeStateEntry *       vmsentry;             /*   112     8 */
	QEMUBH *                   bh;                   /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint32_t                   id;                   /*   128     4 */

	/* XXX 4 bytes hole, try to pack */

	BlockConf                  conf;                 /*   136    56 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	SCSISense                  unit_attention;       /*   192     3 */
	_Bool                      sense_is_ua;          /*   195     1 */
	uint8_t                    sense[252];           /*   196   252 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	uint32_t                   sense_len;            /*   448     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct SCSIRequest * tqh_first;          /*   456     8 */
		struct SCSIRequest * * tqh_last;         /*   464     8 */
	} requests;                                      /*   456    16 */
	uint32_t                   channel;              /*   472     4 */
	uint32_t                   lun;                  /*   476     4 */
	int                        blocksize;            /*   480     4 */
	int                        type;                 /*   484     4 */
	uint64_t                   max_lba;              /*   488     8 */
	uint64_t                   wwn;                  /*   496     8 */
	uint64_t                   port_wwn;             /*   504     8 */

	/* size: 512, cachelines: 8, members: 17 */
	/* sum members: 504, holes: 2, sum holes: 8 */
};
struct SCSIRequest {
	SCSIBus *                  bus;                  /*     0     8 */
	SCSIDevice *               dev;                  /*     8     8 */
	const SCSIReqOps  *        ops;                  /*    16     8 */
	uint32_t                   refcount;             /*    24     4 */
	uint32_t                   tag;                  /*    28     4 */
	uint32_t                   lun;                  /*    32     4 */
	uint32_t                   status;               /*    36     4 */
	void *                     hba_private;          /*    40     8 */
	size_t                     resid;                /*    48     8 */
	SCSICommand                cmd;                  /*    56    48 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	NotifierList               cancel_notifiers;     /*   104     8 */
	uint8_t                    sense[252];           /*   112   252 */
	/* --- cacheline 5 boundary (320 bytes) was 44 bytes ago --- */
	uint32_t                   sense_len;            /*   364     4 */
	_Bool                      enqueued;             /*   368     1 */
	_Bool                      io_canceled;          /*   369     1 */
	_Bool                      retry;                /*   370     1 */
	_Bool                      dma_started;          /*   371     1 */

	/* XXX 4 bytes hole, try to pack */

	BlockAIOCB *               aiocb;                /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	QEMUSGList *               sg;                   /*   384     8 */
	struct {
		struct SCSIRequest * tqe_next;           /*   392     8 */
		struct SCSIRequest * * tqe_prev;         /*   400     8 */
	} next;                                          /*   392    16 */

	/* size: 408, cachelines: 7, members: 20 */
	/* sum members: 404, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct SCSIReqOps {
	size_t                     size;                 /*     0     8 */
	void                       (*free_req)(SCSIRequest *); /*     8     8 */
	int32_t                    (*send_command)(SCSIRequest *, uint8_t *); /*    16     8 */
	void                       (*read_data)(SCSIRequest *); /*    24     8 */
	void                       (*write_data)(SCSIRequest *); /*    32     8 */
	uint8_t *                  (*get_buf)(SCSIRequest *); /*    40     8 */
	void                       (*save_request)(QEMUFile *, SCSIRequest *); /*    48     8 */
	void                       (*load_request)(QEMUFile *, SCSIRequest *); /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
};
struct SCSISense {
	uint8_t                    key;                  /*     0     1 */
	uint8_t                    asc;                  /*     1     1 */
	uint8_t                    ascq;                 /*     2     1 */

	/* size: 3, cachelines: 1, members: 3 */
	/* last cacheline: 3 bytes */
};
struct VirtIOSCSICommon {
	VirtIODevice               parent_obj;           /*     0   224 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	VirtIOSCSIConf             conf;                 /*   224    48 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	uint32_t                   sense_size;           /*   272     4 */
	uint32_t                   cdb_size;             /*   276     4 */
	VirtQueue *                ctrl_vq;              /*   280     8 */
	VirtQueue *                event_vq;             /*   288     8 */
	VirtQueue * *              cmd_vqs;              /*   296     8 */

	/* size: 304, cachelines: 5, members: 7 */
	/* last cacheline: 48 bytes */
};
struct VirtIOSCSI {
	VirtIOSCSICommon           parent_obj;           /*     0   304 */
	/* --- cacheline 4 boundary (256 bytes) was 48 bytes ago --- */
	SCSIBus                    bus;                  /*   304   120 */
	/* --- cacheline 6 boundary (384 bytes) was 40 bytes ago --- */
	int                        resetting;            /*   424     4 */
	_Bool                      events_dropped;       /*   428     1 */

	/* XXX 3 bytes hole, try to pack */

	AioContext *               ctx;                  /*   432     8 */
	_Bool                      dataplane_started;    /*   440     1 */
	_Bool                      dataplane_starting;   /*   441     1 */
	_Bool                      dataplane_stopping;   /*   442     1 */
	_Bool                      dataplane_fenced;     /*   443     1 */
	uint32_t                   host_features;        /*   444     4 */

	/* size: 448, cachelines: 7, members: 10 */
	/* sum members: 445, holes: 1, sum holes: 3 */
};
struct VirtIOSCSIReq {
	VirtQueueElement           elem;                 /*     0    48 */
	VirtIOSCSI *               dev;                  /*    48     8 */
	VirtQueue *                vq;                   /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	QEMUSGList                 qsgl;                 /*    64    40 */
	QEMUIOVector               resp_iov;             /*   104    24 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	union {
		struct {
			struct VirtIOSCSIReq * tqe_next; /*   128     8 */
			struct VirtIOSCSIReq * * tqe_prev; /*   136     8 */
		} next;                                  /*   128    16 */
		int                remaining;            /*   128     4 */
	};                                               /*   128    16 */
	SCSIRequest *              sreq;                 /*   144     8 */
	size_t                     resp_size;            /*   152     8 */
	enum SCSIXferMode          mode;                 /*   160     4 */
	union {
		VirtIOSCSICmdResp  cmd;                  /*   164    12 */
		VirtIOSCSICtrlTMFResp tmf;               /*   164     1 */
		VirtIOSCSICtrlANResp an;                 /*   164     5 */
		VirtIOSCSIEvent    event;                /*   164    16 */
	} resp;                                          /*   164    16 */
	union {
		VirtIOSCSICmdReq   cmd;                  /*   180    19 */
		VirtIOSCSICtrlTMFReq tmf;                /*   180    24 */
		VirtIOSCSICtrlANReq an;                  /*   180    16 */
	} req;                                           /*   180    24 */

	/* size: 208, cachelines: 4, members: 11 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct VHostSCSI {
	VirtIOSCSICommon           parent_obj;           /*     0   304 */
	/* --- cacheline 4 boundary (256 bytes) was 48 bytes ago --- */
	Error *                    migration_blocker;    /*   304     8 */
	struct vhost_dev           dev;                  /*   312   328 */
	/* --- cacheline 10 boundary (640 bytes) --- */
	int32_t                    bootindex;            /*   640     4 */
	int                        channel;              /*   644     4 */
	int                        target;               /*   648     4 */
	int                        lun;                  /*   652     4 */

	/* size: 656, cachelines: 11, members: 7 */
	/* last cacheline: 16 bytes */
};
struct FWPathProvider {
	Object                     parent_obj;           /*     0    40 */

	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
struct FWPathProviderClass {
	InterfaceClass             parent_class;         /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	char *                     (*get_dev_path)(FWPathProvider *, BusState *, DeviceState *); /*   112     8 */

	/* size: 120, cachelines: 2, members: 2 */
	/* last cacheline: 56 bytes */
};
struct RTCState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	MemoryRegion               io;                   /*   128   256 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	uint8_t                    cmos_data[128];       /*   384   128 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	uint8_t                    cmos_index;           /*   512     1 */

	/* XXX 3 bytes hole, try to pack */

	int32_t                    base_year;            /*   516     4 */
	uint64_t                   base_rtc;             /*   520     8 */
	uint64_t                   last_update;          /*   528     8 */
	int64_t                    offset;               /*   536     8 */
	qemu_irq                   irq;                  /*   544     8 */
	int                        it_shift;             /*   552     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUTimer *                periodic_timer;       /*   560     8 */
	int64_t                    next_periodic_time;   /*   568     8 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	QEMUTimer *                update_timer;         /*   576     8 */
	uint64_t                   next_alarm_time;      /*   584     8 */
	uint16_t                   irq_reinject_on_ack_count; /*   592     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   irq_coalesced;        /*   596     4 */
	uint32_t                   period;               /*   600     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUTimer *                coalesced_timer;      /*   608     8 */
	Notifier                   clock_reset_notifier; /*   616    24 */
	/* --- cacheline 10 boundary (640 bytes) --- */
	LostTickPolicy             lost_tick_policy;     /*   640     4 */

	/* XXX 4 bytes hole, try to pack */

	Notifier                   suspend_notifier;     /*   648    24 */
	struct {
		struct RTCState *  le_next;              /*   672     8 */
		struct RTCState * * le_prev;             /*   680     8 */
	} link;                                          /*   672    16 */

	/* size: 688, cachelines: 11, members: 22 */
	/* sum members: 671, holes: 5, sum holes: 17 */
	/* last cacheline: 48 bytes */
};
struct vfio_info_cap_header {
	__u16                      id;                   /*     0     2 */
	__u16                      version;              /*     2     2 */
	__u32                      next;                 /*     4     4 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct vfio_group_status {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct vfio_device_info {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u32                      num_regions;          /*     8     4 */
	__u32                      num_irqs;             /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct vfio_region_info {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u32                      index;                /*     8     4 */
	__u32                      cap_offset;           /*    12     4 */
	__u64                      size;                 /*    16     8 */
	__u64                      offset;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 6 */
	/* last cacheline: 32 bytes */
};
struct vfio_region_sparse_mmap_area {
	__u64                      offset;               /*     0     8 */
	__u64                      size;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct vfio_region_info_cap_sparse_mmap {
	struct vfio_info_cap_header header;              /*     0     8 */
	__u32                      nr_areas;             /*     8     4 */
	__u32                      reserved;             /*    12     4 */
	struct vfio_region_sparse_mmap_area areas[];     /*    16     0 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct vfio_region_info_cap_type {
	struct vfio_info_cap_header header;              /*     0     8 */
	__u32                      type;                 /*     8     4 */
	__u32                      subtype;              /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct vfio_irq_set {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u32                      index;                /*     8     4 */
	__u32                      start;                /*    12     4 */
	__u32                      count;                /*    16     4 */
	__u8                       data[];               /*    20     0 */

	/* size: 20, cachelines: 1, members: 6 */
	/* last cacheline: 20 bytes */
};
struct vfio_iommu_type1_info {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u64                      iova_pgsizes;         /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct vfio_iommu_type1_dma_map {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u64                      vaddr;                /*     8     8 */
	__u64                      iova;                 /*    16     8 */
	__u64                      size;                 /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct vfio_iommu_type1_dma_unmap {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u64                      iova;                 /*     8     8 */
	__u64                      size;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct vfio_iommu_spapr_tce_ddw_info {
	__u64                      pgsizes;              /*     0     8 */
	__u32                      max_dynamic_windows_supported; /*     8     4 */
	__u32                      levels;               /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct vfio_iommu_spapr_tce_info {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u32                      dma32_window_start;   /*     8     4 */
	__u32                      dma32_window_size;    /*    12     4 */
	struct vfio_iommu_spapr_tce_ddw_info ddw;        /*    16    16 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct vfio_eeh_pe_err {
	__u32                      type;                 /*     0     4 */
	__u32                      func;                 /*     4     4 */
	__u64                      addr;                 /*     8     8 */
	__u64                      mask;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct vfio_eeh_pe_op {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u32                      op;                   /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		struct vfio_eeh_pe_err err;              /*    16    24 */
	};                                               /*    16    24 */

	/* size: 40, cachelines: 1, members: 4 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct VFIOMmap {
	MemoryRegion               mem;                  /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	void *                     mmap;                 /*   256     8 */
	off_t                      offset;               /*   264     8 */
	size_t                     size;                 /*   272     8 */

	/* size: 288, cachelines: 5, members: 4 */
	/* padding: 8 */
	/* last cacheline: 32 bytes */
};
struct VFIORegion {
	struct VFIODevice *        vbasedev;             /*     0     8 */
	off_t                      fd_offset;            /*     8     8 */
	MemoryRegion *             mem;                  /*    16     8 */
	size_t                     size;                 /*    24     8 */
	uint32_t                   flags;                /*    32     4 */
	uint32_t                   nr_mmaps;             /*    36     4 */
	VFIOMmap *                 mmaps;                /*    40     8 */
	uint8_t                    nr;                   /*    48     1 */

	/* size: 56, cachelines: 1, members: 8 */
	/* padding: 7 */
	/* last cacheline: 56 bytes */
};
struct VFIODevice {
	struct {
		struct VFIODevice * le_next;             /*     0     8 */
		struct VFIODevice * * le_prev;           /*     8     8 */
	} next;                                          /*     0    16 */
	struct VFIOGroup *         group;                /*    16     8 */
	char *                     sysfsdev;             /*    24     8 */
	char *                     name;                 /*    32     8 */
	int                        fd;                   /*    40     4 */
	int                        type;                 /*    44     4 */
	_Bool                      reset_works;          /*    48     1 */
	_Bool                      needs_reset;          /*    49     1 */
	_Bool                      no_mmap;              /*    50     1 */

	/* XXX 5 bytes hole, try to pack */

	VFIODeviceOps *            ops;                  /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	unsigned int               num_irqs;             /*    64     4 */
	unsigned int               num_regions;          /*    68     4 */
	unsigned int               flags;                /*    72     4 */

	/* size: 80, cachelines: 2, members: 13 */
	/* sum members: 71, holes: 1, sum holes: 5 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct VFIOContainer {
	VFIOAddressSpace *         space;                /*     0     8 */
	int                        fd;                   /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	MemoryListener             listener;             /*    16   160 */
	/* --- cacheline 2 boundary (128 bytes) was 48 bytes ago --- */
	MemoryListener             prereg_listener;      /*   176   160 */
	/* --- cacheline 5 boundary (320 bytes) was 16 bytes ago --- */
	unsigned int               iommu_type;           /*   336     4 */
	int                        error;                /*   340     4 */
	_Bool                      initialized;          /*   344     1 */

	/* XXX 7 bytes hole, try to pack */

	struct {
		struct VFIOGuestIOMMU * lh_first;        /*   352     8 */
	} giommu_list;                                   /*   352     8 */
	struct {
		struct VFIOHostDMAWindow * lh_first;     /*   360     8 */
	} hostwin_list;                                  /*   360     8 */
	struct {
		struct VFIOGroup * lh_first;             /*   368     8 */
	} group_list;                                    /*   368     8 */
	struct {
		struct VFIOContainer * le_next;          /*   376     8 */
		/* --- cacheline 6 boundary (384 bytes) --- */
		struct VFIOContainer * * le_prev;        /*   384     8 */
	} next;                                          /*   376    16 */

	/* size: 392, cachelines: 7, members: 11 */
	/* sum members: 381, holes: 2, sum holes: 11 */
	/* last cacheline: 8 bytes */
};
struct VFIOAddressSpace {
	AddressSpace *             as;                   /*     0     8 */
	struct {
		struct VFIOContainer * lh_first;         /*     8     8 */
	} containers;                                    /*     8     8 */
	struct {
		struct VFIOAddressSpace * le_next;       /*    16     8 */
		struct VFIOAddressSpace * * le_prev;     /*    24     8 */
	} list;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct VFIOGuestIOMMU {
	VFIOContainer *            container;            /*     0     8 */
	MemoryRegion *             iommu;                /*     8     8 */
	hwaddr                     iommu_offset;         /*    16     8 */
	IOMMUNotifier              n;                    /*    24    32 */
	struct {
		struct VFIOGuestIOMMU * le_next;         /*    56     8 */
		/* --- cacheline 1 boundary (64 bytes) --- */
		struct VFIOGuestIOMMU * * le_prev;       /*    64     8 */
	} giommu_next;                                   /*    56    16 */

	/* size: 72, cachelines: 2, members: 5 */
	/* last cacheline: 8 bytes */
};
struct VFIOHostDMAWindow {
	hwaddr                     min_iova;             /*     0     8 */
	hwaddr                     max_iova;             /*     8     8 */
	uint64_t                   iova_pgsizes;         /*    16     8 */
	struct {
		struct VFIOHostDMAWindow * le_next;      /*    24     8 */
		struct VFIOHostDMAWindow * * le_prev;    /*    32     8 */
	} hostwin_next;                                  /*    24    16 */

	/* size: 40, cachelines: 1, members: 4 */
	/* last cacheline: 40 bytes */
};
struct VFIOGroup {
	int                        fd;                   /*     0     4 */
	int                        groupid;              /*     4     4 */
	VFIOContainer *            container;            /*     8     8 */
	struct {
		struct VFIODevice * lh_first;            /*    16     8 */
	} device_list;                                   /*    16     8 */
	struct {
		struct VFIOGroup * le_next;              /*    24     8 */
		struct VFIOGroup * * le_prev;            /*    32     8 */
	} next;                                          /*    24    16 */
	struct {
		struct VFIOGroup * le_next;              /*    40     8 */
		struct VFIOGroup * * le_prev;            /*    48     8 */
	} container_next;                                /*    40    16 */

	/* size: 56, cachelines: 1, members: 6 */
	/* last cacheline: 56 bytes */
};
struct VFIODeviceOps {
	void                       (*vfio_compute_needs_reset)(VFIODevice *); /*     0     8 */
	int                        (*vfio_hot_reset_multi)(VFIODevice *); /*     8     8 */
	void                       (*vfio_eoi)(VFIODevice *); /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct vfio_group_head {
	struct VFIOGroup *         lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct vfio_as_head {
	struct VFIOAddressSpace *  lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct PCIHostDeviceAddress {
	unsigned int               domain;               /*     0     4 */
	unsigned int               bus;                  /*     4     4 */
	unsigned int               slot;                 /*     8     4 */
	unsigned int               function;             /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct vfio_irq_info {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u32                      index;                /*     8     4 */
	__u32                      count;                /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct vfio_pci_dependent_device {
	__u32                      group_id;             /*     0     4 */
	__u16                      segment;              /*     4     2 */
	__u8                       bus;                  /*     6     1 */
	__u8                       devfn;                /*     7     1 */

	/* size: 8, cachelines: 1, members: 4 */
	/* last cacheline: 8 bytes */
};
struct vfio_pci_hot_reset_info {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u32                      count;                /*     8     4 */
	struct vfio_pci_dependent_device devices[];      /*    12     0 */

	/* size: 12, cachelines: 1, members: 4 */
	/* last cacheline: 12 bytes */
};
struct vfio_pci_hot_reset {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u32                      count;                /*     8     4 */
	__s32                      group_fds[];          /*    12     0 */

	/* size: 12, cachelines: 1, members: 4 */
	/* last cacheline: 12 bytes */
};
struct VFIOQuirk {
	struct {
		struct VFIOQuirk * le_next;              /*     0     8 */
		struct VFIOQuirk * * le_prev;            /*     8     8 */
	} next;                                          /*     0    16 */
	void *                     data;                 /*    16     8 */
	int                        nr_mem;               /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	MemoryRegion *             mem;                  /*    32     8 */

	/* size: 40, cachelines: 1, members: 4 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct VFIOBAR {
	VFIORegion                 region;               /*     0    56 */
	_Bool                      ioport;               /*    56     1 */
	_Bool                      mem64;                /*    57     1 */

	/* XXX 6 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	struct {
		struct VFIOQuirk * lh_first;             /*    64     8 */
	} quirks;                                        /*    64     8 */

	/* size: 72, cachelines: 2, members: 4 */
	/* sum members: 66, holes: 1, sum holes: 6 */
	/* last cacheline: 8 bytes */
};
struct VFIOVGARegion {
	MemoryRegion               mem;                  /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	off_t                      offset;               /*   256     8 */
	int                        nr;                   /*   264     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct VFIOQuirk * lh_first;             /*   272     8 */
	} quirks;                                        /*   272     8 */

	/* size: 288, cachelines: 5, members: 4 */
	/* sum members: 276, holes: 1, sum holes: 4 */
	/* padding: 8 */
	/* last cacheline: 32 bytes */
};
struct VFIOVGA {
	off_t                      fd_offset;            /*     0     8 */
	int                        fd;                   /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	VFIOVGARegion              region[3];            /*    16   864 */

	/* size: 880, cachelines: 14, members: 3 */
	/* sum members: 876, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct VFIOINTx {
	_Bool                      pending;              /*     0     1 */
	_Bool                      kvm_accel;            /*     1     1 */
	uint8_t                    pin;                  /*     2     1 */

	/* XXX 1 byte hole, try to pack */

	EventNotifier              interrupt;            /*     4     8 */
	EventNotifier              unmask;               /*    12     8 */
	PCIINTxRoute               route;                /*    20     8 */
	uint32_t                   mmap_timeout;         /*    28     4 */
	QEMUTimer *                mmap_timer;           /*    32     8 */

	/* size: 40, cachelines: 1, members: 8 */
	/* sum members: 39, holes: 1, sum holes: 1 */
	/* last cacheline: 40 bytes */
};
struct VFIOMSIVector {
	EventNotifier              interrupt;            /*     0     8 */
	EventNotifier              kvm_interrupt;        /*     8     8 */
	struct VFIOPCIDevice *     vdev;                 /*    16     8 */
	int                        virq;                 /*    24     4 */
	_Bool                      use;                  /*    28     1 */

	/* size: 32, cachelines: 1, members: 5 */
	/* padding: 3 */
	/* last cacheline: 32 bytes */
};
struct VFIOPCIDevice {
	PCIDevice                  pdev;                 /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	VFIODevice                 vbasedev;             /*  2288    80 */
	/* --- cacheline 37 boundary (2368 bytes) --- */
	VFIOINTx                   intx;                 /*  2368    40 */
	unsigned int               config_size;          /*  2408     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  emulated_config_bits; /*  2416     8 */
	off_t                      config_offset;        /*  2424     8 */
	/* --- cacheline 38 boundary (2432 bytes) --- */
	unsigned int               rom_size;             /*  2432     4 */

	/* XXX 4 bytes hole, try to pack */

	off_t                      rom_offset;           /*  2440     8 */
	void *                     rom;                  /*  2448     8 */
	int                        msi_cap_size;         /*  2456     4 */

	/* XXX 4 bytes hole, try to pack */

	VFIOMSIVector *            msi_vectors;          /*  2464     8 */
	VFIOMSIXInfo *             msix;                 /*  2472     8 */
	int                        nr_vectors;           /*  2480     4 */
	int                        interrupt;            /*  2484     4 */
	VFIOBAR                    bars[6];              /*  2488   432 */
	/* --- cacheline 45 boundary (2880 bytes) was 40 bytes ago --- */
	VFIOVGA *                  vga;                  /*  2920     8 */
	void *                     igd_opregion;         /*  2928     8 */
	PCIHostDeviceAddress       host;                 /*  2936    16 */
	/* --- cacheline 46 boundary (2944 bytes) was 8 bytes ago --- */
	EventNotifier              err_notifier;         /*  2952     8 */
	EventNotifier              req_notifier;         /*  2960     8 */
	int                        (*resetfn)(struct VFIOPCIDevice *); /*  2968     8 */
	uint32_t                   vendor_id;            /*  2976     4 */
	uint32_t                   device_id;            /*  2980     4 */
	uint32_t                   sub_vendor_id;        /*  2984     4 */
	uint32_t                   sub_device_id;        /*  2988     4 */
	uint32_t                   features;             /*  2992     4 */
	int32_t                    bootindex;            /*  2996     4 */
	uint32_t                   igd_gms;              /*  3000     4 */
	uint8_t                    pm_cap;               /*  3004     1 */
	_Bool                      pci_aer;              /*  3005     1 */
	_Bool                      req_enabled;          /*  3006     1 */
	_Bool                      has_flr;              /*  3007     1 */
	/* --- cacheline 47 boundary (3008 bytes) --- */
	_Bool                      has_pm_reset;         /*  3008     1 */
	_Bool                      rom_read_failed;      /*  3009     1 */
	_Bool                      no_kvm_intx;          /*  3010     1 */
	_Bool                      no_kvm_msi;           /*  3011     1 */
	_Bool                      no_kvm_msix;          /*  3012     1 */

	/* Force padding: */
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;

	/* size: 3024, cachelines: 48, members: 37 */
	/* sum members: 3001, holes: 3, sum holes: 12 */
	/* padding: 11 */
	/* last cacheline: 16 bytes */
};
struct VFIOMSIXInfo {
	uint8_t                    table_bar;            /*     0     1 */
	uint8_t                    pba_bar;              /*     1     1 */
	uint16_t                   entries;              /*     2     2 */
	uint32_t                   table_offset;         /*     4     4 */
	uint32_t                   pba_offset;           /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	MemoryRegion               mmap_mem;             /*    16   256 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	void *                     mmap;                 /*   272     8 */
	long unsigned int *        pending;              /*   280     8 */

	/* size: 288, cachelines: 5, members: 8 */
	/* sum members: 284, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct VFIOConfigWindowMatch {
	uint32_t                   match;                /*     0     4 */
	uint32_t                   mask;                 /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct VFIOConfigWindowQuirk {
	struct VFIOPCIDevice *     vdev;                 /*     0     8 */
	uint32_t                   address_val;          /*     8     4 */
	uint32_t                   address_offset;       /*    12     4 */
	uint32_t                   data_offset;          /*    16     4 */
	_Bool                      window_enabled;       /*    20     1 */
	uint8_t                    bar;                  /*    21     1 */

	/* XXX 2 bytes hole, try to pack */

	MemoryRegion *             addr_mem;             /*    24     8 */
	MemoryRegion *             data_mem;             /*    32     8 */
	uint32_t                   nr_matches;           /*    40     4 */
	VFIOConfigWindowMatch      matches[];            /*    44     0 */

	/* size: 48, cachelines: 1, members: 10 */
	/* sum members: 42, holes: 1, sum holes: 2 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct VFIOConfigMirrorQuirk {
	struct VFIOPCIDevice *     vdev;                 /*     0     8 */
	uint32_t                   offset;               /*     8     4 */
	uint8_t                    bar;                  /*    12     1 */

	/* XXX 3 bytes hole, try to pack */

	MemoryRegion *             mem;                  /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 21, holes: 1, sum holes: 3 */
	/* last cacheline: 24 bytes */
};
struct VFIONvidia3d0Quirk {
	VFIOPCIDevice *            vdev;                 /*     0     8 */
	VFIONvidia3d0State         state;                /*     8     4 */
	uint32_t                   offset;               /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct VFIONvidiaBAR5Quirk {
	uint32_t                   master;               /*     0     4 */
	uint32_t                   enable;               /*     4     4 */
	MemoryRegion *             addr_mem;             /*     8     8 */
	MemoryRegion *             data_mem;             /*    16     8 */
	_Bool                      enabled;              /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	VFIOConfigWindowQuirk      window;               /*    32    48 */

	/* size: 80, cachelines: 2, members: 6 */
	/* sum members: 73, holes: 1, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct VFIOrtl8168Quirk {
	VFIOPCIDevice *            vdev;                 /*     0     8 */
	uint32_t                   addr;                 /*     8     4 */
	uint32_t                   data;                 /*    12     4 */
	_Bool                      enabled;              /*    16     1 */

	/* size: 24, cachelines: 1, members: 4 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct VFIOIGDQuirk {
	struct VFIOPCIDevice *     vdev;                 /*     0     8 */
	uint32_t                   index;                /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct VFIOINTp {
	struct {
		struct VFIOINTp *  le_next;              /*     0     8 */
		struct VFIOINTp * * le_prev;             /*     8     8 */
	} next;                                          /*     0    16 */
	struct {
		struct VFIOINTp *  sqe_next;             /*    16     8 */
	} pqnext;                                        /*    16     8 */
	EventNotifier *            interrupt;            /*    24     8 */
	EventNotifier *            unmask;               /*    32     8 */
	qemu_irq                   qemuirq;              /*    40     8 */
	struct VFIOPlatformDevice * vdev;                /*    48     8 */
	int                        state;                /*    56     4 */
	uint8_t                    pin;                  /*    60     1 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	uint32_t                   flags;                /*    64     4 */
	_Bool                      kvm_accel;            /*    68     1 */

	/* size: 72, cachelines: 2, members: 10 */
	/* sum members: 66, holes: 1, sum holes: 3 */
	/* padding: 3 */
	/* last cacheline: 8 bytes */
};
struct VFIOPlatformDevice {
	SysBusDevice               sbdev;                /*     0   768 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	VFIODevice                 vbasedev;             /*   768    80 */
	/* --- cacheline 13 boundary (832 bytes) was 16 bytes ago --- */
	VFIORegion * *             regions;              /*   848     8 */
	struct {
		struct VFIOINTp *  lh_first;             /*   856     8 */
	} intp_list;                                     /*   856     8 */
	struct pending_intp_queue  pending_intp_queue;   /*   864    16 */
	char *                     compat;               /*   880     8 */
	uint32_t                   mmap_timeout;         /*   888     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 14 boundary (896 bytes) --- */
	QEMUTimer *                mmap_timer;           /*   896     8 */
	QemuMutex                  intp_mutex;           /*   904    40 */
	_Bool                      irqfd_allowed;        /*   944     1 */

	/* size: 952, cachelines: 15, members: 10 */
	/* sum members: 941, holes: 1, sum holes: 4 */
	/* padding: 7 */
	/* last cacheline: 56 bytes */
};
struct pending_intp_queue {
	struct VFIOINTp *          sqh_first;            /*     0     8 */
	struct VFIOINTp * *        sqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct VFIOPlatformDeviceClass {
	SysBusDeviceClass          parent_class;         /*     0   216 */

	/* size: 216, cachelines: 4, members: 1 */
	/* last cacheline: 24 bytes */
};
struct VFIOCalxedaXgmacDeviceClass {
	VFIOPlatformDeviceClass    parent_class;         /*     0   216 */
	/* --- cacheline 3 boundary (192 bytes) was 24 bytes ago --- */
	DeviceRealize              parent_realize;       /*   216     8 */

	/* size: 224, cachelines: 4, members: 2 */
	/* last cacheline: 32 bytes */
};
struct VFIOAmdXgbeDeviceClass {
	VFIOPlatformDeviceClass    parent_class;         /*     0   216 */
	/* --- cacheline 3 boundary (192 bytes) was 24 bytes ago --- */
	DeviceRealize              parent_realize;       /*   216     8 */

	/* size: 224, cachelines: 4, members: 2 */
	/* last cacheline: 32 bytes */
};
struct vfio_iommu_spapr_register_memory {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u64                      vaddr;                /*     8     8 */
	__u64                      size;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct vfio_iommu_spapr_tce_create {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u32                      page_shift;           /*     8     4 */
	__u32                      __resv1;              /*    12     4 */
	__u64                      window_size;          /*    16     8 */
	__u32                      levels;               /*    24     4 */
	__u32                      __resv2;              /*    28     4 */
	__u64                      start_addr;           /*    32     8 */

	/* size: 40, cachelines: 1, members: 8 */
	/* last cacheline: 40 bytes */
};
struct vfio_iommu_spapr_tce_remove {
	__u32                      argsz;                /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u64                      start_addr;           /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct VirtQueue {
	VRing                      vring;                /*     0    40 */
	uint16_t                   last_avail_idx;       /*    40     2 */
	uint16_t                   shadow_avail_idx;     /*    42     2 */
	uint16_t                   used_idx;             /*    44     2 */
	uint16_t                   signalled_used;       /*    46     2 */
	_Bool                      signalled_used_valid; /*    48     1 */
	_Bool                      notification;         /*    49     1 */
	uint16_t                   queue_index;          /*    50     2 */
	unsigned int               inuse;                /*    52     4 */
	uint16_t                   vector;               /*    56     2 */

	/* XXX 6 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	VirtIOHandleOutput         handle_output;        /*    64     8 */
	VirtIOHandleOutput         handle_aio_output;    /*    72     8 */
	VirtIODevice *             vdev;                 /*    80     8 */
	EventNotifier              guest_notifier;       /*    88     8 */
	EventNotifier              host_notifier;        /*    96     8 */
	struct {
		struct VirtQueue * le_next;              /*   104     8 */
		struct VirtQueue * * le_prev;            /*   112     8 */
	} node;                                          /*   104    16 */

	/* size: 120, cachelines: 2, members: 16 */
	/* sum members: 114, holes: 1, sum holes: 6 */
	/* last cacheline: 56 bytes */
};
struct VRingDesc {
	uint64_t                   addr;                 /*     0     8 */
	uint32_t                   len;                  /*     8     4 */
	uint16_t                   flags;                /*    12     2 */
	uint16_t                   next;                 /*    14     2 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct VRingUsedElem {
	uint32_t                   id;                   /*     0     4 */
	uint32_t                   len;                  /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct VRing {
	unsigned int               num;                  /*     0     4 */
	unsigned int               num_default;          /*     4     4 */
	unsigned int               align;                /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	hwaddr                     desc;                 /*    16     8 */
	hwaddr                     avail;                /*    24     8 */
	hwaddr                     used;                 /*    32     8 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct VirtQueueElementOld {
	unsigned int               index;                /*     0     4 */
	unsigned int               out_num;              /*     4     4 */
	unsigned int               in_num;               /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	hwaddr                     in_addr[1024];        /*    16  8192 */
	/* --- cacheline 128 boundary (8192 bytes) was 16 bytes ago --- */
	hwaddr                     out_addr[1024];       /*  8208  8192 */
	/* --- cacheline 256 boundary (16384 bytes) was 16 bytes ago --- */
	struct iovec               in_sg[1024];          /* 16400 16384 */
	/* --- cacheline 512 boundary (32768 bytes) was 16 bytes ago --- */
	struct iovec               out_sg[1024];         /* 32784 16384 */

	/* size: 49168, cachelines: 769, members: 7 */
	/* sum members: 49164, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct virtio_balloon_config {
	uint32_t                   num_pages;            /*     0     4 */
	uint32_t                   actual;               /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct virtio_balloon_stat {
	__virtio16                 tag;                  /*     0     2 */
	__virtio64                 val;                  /*     2     8 */

	/* size: 10, cachelines: 1, members: 2 */
	/* last cacheline: 10 bytes */
} __attribute__((__packed__));
struct VirtIOBalloon {
	VirtIODevice               parent_obj;           /*     0   224 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	VirtQueue *                ivq;                  /*   224     8 */
	VirtQueue *                dvq;                  /*   232     8 */
	VirtQueue *                svq;                  /*   240     8 */
	uint32_t                   num_pages;            /*   248     4 */
	uint32_t                   actual;               /*   252     4 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint64_t                   stats[7];             /*   256    56 */
	VirtQueueElement *         stats_vq_elem;        /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	size_t                     stats_vq_offset;      /*   320     8 */
	QEMUTimer *                stats_timer;          /*   328     8 */
	int64_t                    stats_last_update;    /*   336     8 */
	int64_t                    stats_poll_interval;  /*   344     8 */
	uint32_t                   host_features;        /*   352     4 */

	/* size: 360, cachelines: 6, members: 13 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct VhostUserMemoryRegion {
	uint64_t                   guest_phys_addr;      /*     0     8 */
	uint64_t                   memory_size;          /*     8     8 */
	uint64_t                   userspace_addr;       /*    16     8 */
	uint64_t                   mmap_offset;          /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct VhostUserMemory {
	uint32_t                   nregions;             /*     0     4 */
	uint32_t                   padding;              /*     4     4 */
	VhostUserMemoryRegion      regions[8];           /*     8   256 */

	/* size: 264, cachelines: 5, members: 3 */
	/* last cacheline: 8 bytes */
};
struct VhostUserLog {
	uint64_t                   mmap_size;            /*     0     8 */
	uint64_t                   mmap_offset;          /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct VhostUserMsg {
	VhostUserRequest           request;              /*     0     4 */
	uint32_t                   flags;                /*     4     4 */
	uint32_t                   size;                 /*     8     4 */
	union {
		uint64_t           u64;                  /*    12     8 */
		struct vhost_vring_state state;          /*    12     8 */
		struct vhost_vring_addr addr;            /*    12    40 */
		VhostUserMemory    memory;               /*    12   264 */
		VhostUserLog       log;                  /*    12    16 */
	} payload;                                       /*    12   264 */

	/* size: 276, cachelines: 5, members: 4 */
	/* last cacheline: 20 bytes */
} __attribute__((__packed__));
struct virtio_vsock_config {
	uint64_t                   guest_cid;            /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct virtio_vsock_event {
	uint32_t                   id;                   /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct virtio_crypto_ctrl_header {
	__virtio32                 opcode;               /*     0     4 */
	__virtio32                 algo;                 /*     4     4 */
	__virtio32                 flag;                 /*     8     4 */
	__virtio32                 queue_id;             /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct virtio_crypto_cipher_session_para {
	__virtio32                 algo;                 /*     0     4 */
	__virtio32                 keylen;               /*     4     4 */
	__virtio32                 op;                   /*     8     4 */
	__virtio32                 padding;              /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct virtio_crypto_session_input {
	__virtio64                 session_id;           /*     0     8 */
	__virtio32                 status;               /*     8     4 */
	__virtio32                 padding;              /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct virtio_crypto_cipher_session_req {
	struct virtio_crypto_cipher_session_para para;   /*     0    16 */

	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */
};
struct virtio_crypto_hash_session_para {
	__virtio32                 algo;                 /*     0     4 */
	__virtio32                 hash_result_len;      /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct virtio_crypto_hash_create_session_req {
	struct virtio_crypto_hash_session_para para;     /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct virtio_crypto_mac_session_para {
	__virtio32                 algo;                 /*     0     4 */
	__virtio32                 hash_result_len;      /*     4     4 */
	__virtio32                 auth_key_len;         /*     8     4 */
	__virtio32                 padding;              /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct virtio_crypto_mac_create_session_req {
	struct virtio_crypto_mac_session_para para;      /*     0    16 */

	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */
};
struct virtio_crypto_aead_session_para {
	__virtio32                 algo;                 /*     0     4 */
	__virtio32                 key_len;              /*     4     4 */
	__virtio32                 digest_result_len;    /*     8     4 */
	__virtio32                 aad_len;              /*    12     4 */
	__virtio32                 op;                   /*    16     4 */
	__virtio32                 padding;              /*    20     4 */

	/* size: 24, cachelines: 1, members: 6 */
	/* last cacheline: 24 bytes */
};
struct virtio_crypto_aead_create_session_req {
	struct virtio_crypto_aead_session_para para;     /*     0    24 */

	/* size: 24, cachelines: 1, members: 1 */
	/* last cacheline: 24 bytes */
};
struct virtio_crypto_alg_chain_session_para {
	__virtio32                 alg_chain_order;      /*     0     4 */
	__virtio32                 hash_mode;            /*     4     4 */
	struct virtio_crypto_cipher_session_para cipher_param; /*     8    16 */
	union {
		struct virtio_crypto_hash_session_para hash_param; /*    24     8 */
		struct virtio_crypto_mac_session_para mac_param; /*    24    16 */
	} u;                                             /*    24    16 */
	__virtio32                 aad_len;              /*    40     4 */
	__virtio32                 padding;              /*    44     4 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct virtio_crypto_alg_chain_session_req {
	struct virtio_crypto_alg_chain_session_para para; /*     0    48 */

	/* size: 48, cachelines: 1, members: 1 */
	/* last cacheline: 48 bytes */
};
struct virtio_crypto_sym_create_session_req {
	union {
		struct virtio_crypto_cipher_session_req cipher; /*     0    16 */
		struct virtio_crypto_alg_chain_session_req chain; /*     0    48 */
	} u;                                             /*     0    48 */
	__virtio32                 op_type;              /*    48     4 */
	__virtio32                 padding;              /*    52     4 */

	/* size: 56, cachelines: 1, members: 3 */
	/* last cacheline: 56 bytes */
};
struct virtio_crypto_destroy_session_req {
	__virtio64                 session_id;           /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct virtio_crypto_op_ctrl_req {
	struct virtio_crypto_ctrl_header header;         /*     0    16 */
	union {
		struct virtio_crypto_sym_create_session_req sym_create_session; /*    16    56 */
		struct virtio_crypto_hash_create_session_req hash_create_session; /*    16     8 */
		struct virtio_crypto_mac_create_session_req mac_create_session; /*    16    16 */
		struct virtio_crypto_aead_create_session_req aead_create_session; /*    16    24 */
		struct virtio_crypto_destroy_session_req destroy_session; /*    16     8 */
	} u;                                             /*    16    56 */

	/* size: 72, cachelines: 2, members: 2 */
	/* last cacheline: 8 bytes */
};
struct virtio_crypto_op_header {
	__virtio32                 opcode;               /*     0     4 */
	__virtio32                 algo;                 /*     4     4 */
	__virtio64                 session_id;           /*     8     8 */
	__virtio32                 flag;                 /*    16     4 */
	__virtio32                 padding;              /*    20     4 */

	/* size: 24, cachelines: 1, members: 5 */
	/* last cacheline: 24 bytes */
};
struct virtio_crypto_cipher_para {
	__virtio32                 iv_len;               /*     0     4 */
	__virtio32                 src_data_len;         /*     4     4 */
	__virtio32                 dst_data_len;         /*     8     4 */
	__virtio32                 padding;              /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct virtio_crypto_hash_para {
	__virtio32                 src_data_len;         /*     0     4 */
	__virtio32                 hash_result_len;      /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct virtio_crypto_mac_para {
	struct virtio_crypto_hash_para hash;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct virtio_crypto_aead_para {
	__virtio32                 iv_len;               /*     0     4 */
	__virtio32                 aad_len;              /*     4     4 */
	__virtio32                 src_data_len;         /*     8     4 */
	__virtio32                 dst_data_len;         /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct virtio_crypto_cipher_data_req {
	struct virtio_crypto_cipher_para para;           /*     0    16 */

	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */
};
struct virtio_crypto_hash_data_req {
	struct virtio_crypto_hash_para para;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct virtio_crypto_mac_data_req {
	struct virtio_crypto_mac_para para;              /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct virtio_crypto_alg_chain_data_para {
	__virtio32                 iv_len;               /*     0     4 */
	__virtio32                 src_data_len;         /*     4     4 */
	__virtio32                 dst_data_len;         /*     8     4 */
	__virtio32                 cipher_start_src_offset; /*    12     4 */
	__virtio32                 len_to_cipher;        /*    16     4 */
	__virtio32                 hash_start_src_offset; /*    20     4 */
	__virtio32                 len_to_hash;          /*    24     4 */
	__virtio32                 aad_len;              /*    28     4 */
	__virtio32                 hash_result_len;      /*    32     4 */
	__virtio32                 reserved;             /*    36     4 */

	/* size: 40, cachelines: 1, members: 10 */
	/* last cacheline: 40 bytes */
};
struct virtio_crypto_alg_chain_data_req {
	struct virtio_crypto_alg_chain_data_para para;   /*     0    40 */

	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
struct virtio_crypto_sym_data_req {
	union {
		struct virtio_crypto_cipher_data_req cipher; /*     0    16 */
		struct virtio_crypto_alg_chain_data_req chain; /*     0    40 */
	} u;                                             /*     0    40 */
	__virtio32                 op_type;              /*    40     4 */
	__virtio32                 padding;              /*    44     4 */

	/* size: 48, cachelines: 1, members: 3 */
	/* last cacheline: 48 bytes */
};
struct virtio_crypto_aead_data_req {
	struct virtio_crypto_aead_para para;             /*     0    16 */

	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */
};
struct virtio_crypto_op_data_req {
	struct virtio_crypto_op_header header;           /*     0    24 */
	union {
		struct virtio_crypto_sym_data_req sym_req; /*    24    48 */
		struct virtio_crypto_hash_data_req hash_req; /*    24     8 */
		struct virtio_crypto_mac_data_req mac_req; /*    24     8 */
		struct virtio_crypto_aead_data_req aead_req; /*    24    16 */
	} u;                                             /*    24    48 */

	/* size: 72, cachelines: 2, members: 2 */
	/* last cacheline: 8 bytes */
};
struct virtio_crypto_config {
	__virtio32                 status;               /*     0     4 */
	__virtio32                 max_dataqueues;       /*     4     4 */
	__virtio32                 crypto_services;      /*     8     4 */
	__virtio32                 cipher_algo_l;        /*    12     4 */
	__virtio32                 cipher_algo_h;        /*    16     4 */
	__virtio32                 hash_algo;            /*    20     4 */
	__virtio32                 mac_algo_l;           /*    24     4 */
	__virtio32                 mac_algo_h;           /*    28     4 */
	__virtio32                 aead_algo;            /*    32     4 */
	uint32_t                   max_cipher_key_len;   /*    36     4 */
	uint32_t                   max_auth_key_len;     /*    40     4 */
	__virtio32                 reserve;              /*    44     4 */
	__virtio64                 max_size;             /*    48     8 */

	/* size: 56, cachelines: 1, members: 13 */
	/* last cacheline: 56 bytes */
};
struct virtio_crypto_inhdr {
	uint8_t                    status;               /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
};
struct CryptoDevBackendConf {
	CryptoDevBackendPeers      peers;                /*     0   520 */
	/* --- cacheline 8 boundary (512 bytes) was 8 bytes ago --- */
	uint32_t                   crypto_services;      /*   520     4 */
	uint32_t                   cipher_algo_l;        /*   524     4 */
	uint32_t                   cipher_algo_h;        /*   528     4 */
	uint32_t                   hash_algo;            /*   532     4 */
	uint32_t                   mac_algo_l;           /*   536     4 */
	uint32_t                   mac_algo_h;           /*   540     4 */
	uint32_t                   aead_algo;            /*   544     4 */
	uint32_t                   max_cipher_key_len;   /*   548     4 */
	uint32_t                   max_auth_key_len;     /*   552     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   max_size;             /*   560     8 */

	/* size: 568, cachelines: 9, members: 11 */
	/* sum members: 564, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct CryptoDevBackendPeers {
	CryptoDevBackendClient *   ccs[64];              /*     0   512 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	uint32_t                   queues;               /*   512     4 */

	/* size: 520, cachelines: 9, members: 2 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
struct CryptoDevBackendClient {
	char *                     model;                /*     0     8 */
	char *                     name;                 /*     8     8 */
	char *                     info_str;             /*    16     8 */
	unsigned int               queue_index;          /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct CryptoDevBackendClient * tqe_next; /*    32     8 */
		struct CryptoDevBackendClient * * tqe_prev; /*    40     8 */
	} next;                                          /*    32    16 */

	/* size: 48, cachelines: 1, members: 5 */
	/* sum members: 44, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct CryptoDevBackend {
	Object                     parent_obj;           /*     0    40 */
	_Bool                      ready;                /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	CryptoDevBackendConf       conf;                 /*    48   568 */

	/* size: 616, cachelines: 10, members: 3 */
	/* sum members: 609, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
struct CryptoDevBackendSymSessionInfo {
	uint32_t                   op_code;              /*     0     4 */
	uint32_t                   cipher_alg;           /*     4     4 */
	uint32_t                   key_len;              /*     8     4 */
	uint32_t                   hash_alg;             /*    12     4 */
	uint32_t                   hash_result_len;      /*    16     4 */
	uint32_t                   auth_key_len;         /*    20     4 */
	uint32_t                   add_len;              /*    24     4 */
	uint8_t                    op_type;              /*    28     1 */
	uint8_t                    direction;            /*    29     1 */
	uint8_t                    hash_mode;            /*    30     1 */
	uint8_t                    alg_chain_order;      /*    31     1 */
	uint8_t *                  cipher_key;           /*    32     8 */
	uint8_t *                  auth_key;             /*    40     8 */

	/* size: 48, cachelines: 1, members: 13 */
	/* last cacheline: 48 bytes */
};
struct CryptoDevBackendSymOpInfo {
	uint64_t                   session_id;           /*     0     8 */
	uint32_t                   aad_len;              /*     8     4 */
	uint32_t                   iv_len;               /*    12     4 */
	uint32_t                   src_len;              /*    16     4 */
	uint32_t                   dst_len;              /*    20     4 */
	uint32_t                   digest_result_len;    /*    24     4 */
	uint32_t                   hash_start_src_offset; /*    28     4 */
	uint32_t                   cipher_start_src_offset; /*    32     4 */
	uint32_t                   len_to_hash;          /*    36     4 */
	uint32_t                   len_to_cipher;        /*    40     4 */
	uint8_t                    op_type;              /*    44     1 */

	/* XXX 3 bytes hole, try to pack */

	uint8_t *                  iv;                   /*    48     8 */
	uint8_t *                  src;                  /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint8_t *                  dst;                  /*    64     8 */
	uint8_t *                  aad_data;             /*    72     8 */
	uint8_t *                  digest_result;        /*    80     8 */
	uint8_t                    data[];               /*    88     0 */

	/* size: 88, cachelines: 2, members: 17 */
	/* sum members: 85, holes: 1, sum holes: 3 */
	/* last cacheline: 24 bytes */
};
struct VirtIOCryptoConf {
	CryptoDevBackend *         cryptodev;            /*     0     8 */
	uint32_t                   crypto_services;      /*     8     4 */
	uint32_t                   cipher_algo_l;        /*    12     4 */
	uint32_t                   cipher_algo_h;        /*    16     4 */
	uint32_t                   hash_algo;            /*    20     4 */
	uint32_t                   mac_algo_l;           /*    24     4 */
	uint32_t                   mac_algo_h;           /*    28     4 */
	uint32_t                   aead_algo;            /*    32     4 */
	uint32_t                   max_cipher_key_len;   /*    36     4 */
	uint32_t                   max_auth_key_len;     /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   max_size;             /*    48     8 */

	/* size: 56, cachelines: 1, members: 11 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct VirtIOCryptoReq {
	VirtQueueElement           elem;                 /*     0    48 */
	uint32_t                   flags;                /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	struct virtio_crypto_inhdr * in;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	struct iovec *             in_iov;               /*    64     8 */
	unsigned int               in_num;               /*    72     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     in_len;               /*    80     8 */
	VirtQueue *                vq;                   /*    88     8 */
	struct VirtIOCrypto *      vcrypto;              /*    96     8 */
	union {
		CryptoDevBackendSymOpInfo * sym_op_info; /*   104     8 */
	} u;                                             /*   104     8 */

	/* size: 112, cachelines: 2, members: 9 */
	/* sum members: 104, holes: 2, sum holes: 8 */
	/* last cacheline: 48 bytes */
};
struct VirtIOCrypto {
	VirtIODevice               parent_obj;           /*     0   224 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	VirtQueue *                ctrl_vq;              /*   224     8 */
	VirtIOCryptoQueue *        vqs;                  /*   232     8 */
	VirtIOCryptoConf           conf;                 /*   240    56 */
	/* --- cacheline 4 boundary (256 bytes) was 40 bytes ago --- */
	CryptoDevBackend *         cryptodev;            /*   296     8 */
	uint32_t                   max_queues;           /*   304     4 */
	uint32_t                   status;               /*   308     4 */
	int                        multiqueue;           /*   312     4 */
	uint32_t                   curr_queues;          /*   316     4 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	size_t                     config_size;          /*   320     8 */

	/* size: 328, cachelines: 6, members: 10 */
	/* last cacheline: 8 bytes */
};
struct VirtIOCryptoQueue {
	VirtQueue *                dataq;                /*     0     8 */
	QEMUBH *                   dataq_bh;             /*     8     8 */
	struct VirtIOCrypto *      vcrypto;              /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct VirtIOCryptoPCI {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VirtIOCrypto               vdev;                 /* 33808   328 */

	/* size: 34144, cachelines: 534, members: 2 */
	/* padding: 8 */
	/* last cacheline: 32 bytes */
};
struct QEMUOptionRom {
	const char  *              name;                 /*     0     8 */
	int32_t                    bootindex;            /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct DriveInfo {
	const char  *              devaddr;              /*     0     8 */
	BlockInterfaceType         type;                 /*     8     4 */
	int                        bus;                  /*    12     4 */
	int                        unit;                 /*    16     4 */
	int                        auto_del;             /*    20     4 */
	_Bool                      is_default;           /*    24     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        media_cd;             /*    28     4 */
	int                        cyls;                 /*    32     4 */
	int                        heads;                /*    36     4 */
	int                        secs;                 /*    40     4 */
	int                        trans;                /*    44     4 */
	QemuOpts *                 opts;                 /*    48     8 */
	char *                     serial;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	struct {
		struct DriveInfo * tqe_next;             /*    64     8 */
		struct DriveInfo * * tqe_prev;           /*    72     8 */
	} next;                                          /*    64    16 */

	/* size: 80, cachelines: 2, members: 14 */
	/* sum members: 77, holes: 1, sum holes: 3 */
	/* last cacheline: 16 bytes */
};
struct NICInfo {
	MACAddr                    macaddr;              /*     0     6 */

	/* XXX 2 bytes hole, try to pack */

	char *                     model;                /*     8     8 */
	char *                     name;                 /*    16     8 */
	char *                     devaddr;              /*    24     8 */
	NetClientState *           netdev;               /*    32     8 */
	int                        used;                 /*    40     4 */
	int                        instantiated;         /*    44     4 */
	int                        nvectors;             /*    48     4 */

	/* size: 56, cachelines: 1, members: 8 */
	/* sum members: 50, holes: 1, sum holes: 2 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct PCMachineClass {
	MachineClass               parent_class;         /*     0   272 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	HotplugHandler *           (*get_hotplug_handler)(MachineState *, DeviceState *); /*   272     8 */
	_Bool                      pci_enabled;          /*   280     1 */
	_Bool                      kvmclock_enabled;     /*   281     1 */
	_Bool                      has_acpi_build;       /*   282     1 */
	_Bool                      rsdp_in_ram;          /*   283     1 */
	int                        legacy_acpi_table_size; /*   284     4 */
	unsigned int               acpi_data_size;       /*   288     4 */
	_Bool                      smbios_defaults;      /*   292     1 */
	_Bool                      smbios_legacy_mode;   /*   293     1 */
	_Bool                      smbios_uuid_encoded;  /*   294     1 */
	_Bool                      gigabyte_align;       /*   295     1 */
	_Bool                      has_reserved_memory;  /*   296     1 */
	_Bool                      enforce_aligned_dimm; /*   297     1 */
	_Bool                      broken_reserved_end;  /*   298     1 */
	_Bool                      save_tsc_khz;         /*   299     1 */
	_Bool                      legacy_cpu_hotplug;   /*   300     1 */

	/* size: 304, cachelines: 5, members: 17 */
	/* padding: 3 */
	/* last cacheline: 48 bytes */
};
struct PCDIMMDevice {
	DeviceState                parent_obj;           /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	uint64_t                   addr;                 /*   112     8 */
	uint32_t                   node;                 /*   120     4 */
	int32_t                    slot;                 /*   124     4 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	HostMemoryBackend *        hostmem;              /*   128     8 */

	/* size: 136, cachelines: 3, members: 5 */
	/* last cacheline: 8 bytes */
};
struct PCDIMMDeviceClass {
	DeviceClass                parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	void                       (*realize)(PCDIMMDevice *, Error * *); /*   192     8 */
	MemoryRegion *             (*get_memory_region)(PCDIMMDevice *); /*   200     8 */
	MemoryRegion *             (*get_vmstate_memory_region)(PCDIMMDevice *); /*   208     8 */

	/* size: 216, cachelines: 4, members: 4 */
	/* last cacheline: 24 bytes */
};
struct GSIState {
	qemu_irq                   i8259_irq[16];        /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	qemu_irq                   ioapic_irq[24];       /*   128   192 */

	/* size: 320, cachelines: 5, members: 2 */
};
struct X86CPUTopoInfo {
	unsigned int               pkg_id;               /*     0     4 */
	unsigned int               core_id;              /*     4     4 */
	unsigned int               smt_id;               /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
struct hpet_fw_entry {
	uint32_t                   event_timer_block_id; /*     0     4 */
	uint64_t                   address;              /*     4     8 */
	uint16_t                   min_tick;             /*    12     2 */
	uint8_t                    page_prot;            /*    14     1 */

	/* size: 15, cachelines: 1, members: 4 */
	/* last cacheline: 15 bytes */
} __attribute__((__packed__));
struct hpet_fw_config {
	uint8_t                    count;                /*     0     1 */
	struct hpet_fw_entry       hpet[8];              /*     1   120 */

	/* size: 121, cachelines: 2, members: 2 */
	/* last cacheline: 57 bytes */
} __attribute__((__packed__));
struct smbios_phys_mem_area {
	uint64_t                   address;              /*     0     8 */
	uint64_t                   length;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct VTDContextEntry {
	uint64_t                   lo;                   /*     0     8 */
	uint64_t                   hi;                   /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct VTDContextCacheEntry {
	uint32_t                   context_cache_gen;    /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	struct VTDContextEntry     context_entry;        /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct IntelIOMMUState {
	X86IOMMUState              x86_iommu;            /*     0   784 */
	/* --- cacheline 12 boundary (768 bytes) was 16 bytes ago --- */
	MemoryRegion               csrmem;               /*   784   256 */
	/* --- cacheline 16 boundary (1024 bytes) was 16 bytes ago --- */
	uint8_t                    csr[560];             /*  1040   560 */
	/* --- cacheline 25 boundary (1600 bytes) --- */
	uint8_t                    wmask[560];           /*  1600   560 */
	/* --- cacheline 33 boundary (2112 bytes) was 48 bytes ago --- */
	uint8_t                    w1cmask[560];         /*  2160   560 */
	/* --- cacheline 42 boundary (2688 bytes) was 32 bytes ago --- */
	uint8_t                    womask[560];          /*  2720   560 */
	/* --- cacheline 51 boundary (3264 bytes) was 16 bytes ago --- */
	uint32_t                   version;              /*  3280     4 */

	/* XXX 4 bytes hole, try to pack */

	dma_addr_t                 root;                 /*  3288     8 */
	_Bool                      root_extended;        /*  3296     1 */
	_Bool                      dmar_enabled;         /*  3297     1 */
	uint16_t                   iq_head;              /*  3298     2 */
	uint16_t                   iq_tail;              /*  3300     2 */

	/* XXX 2 bytes hole, try to pack */

	dma_addr_t                 iq;                   /*  3304     8 */
	uint16_t                   iq_size;              /*  3312     2 */
	_Bool                      qi_enabled;           /*  3314     1 */
	uint8_t                    iq_last_desc_type;    /*  3315     1 */
	uint16_t                   next_frcd_reg;        /*  3316     2 */

	/* XXX 2 bytes hole, try to pack */

	uint64_t                   cap;                  /*  3320     8 */
	/* --- cacheline 52 boundary (3328 bytes) --- */
	uint64_t                   ecap;                 /*  3328     8 */
	uint32_t                   context_cache_gen;    /*  3336     4 */

	/* XXX 4 bytes hole, try to pack */

	GHashTable *               iotlb;                /*  3344     8 */
	MemoryRegionIOMMUOps       iommu_ops;            /*  3352    24 */
	GHashTable *               vtd_as_by_busptr;     /*  3376     8 */
	VTDBus *                   vtd_as_by_bus_num[256]; /*  3384  2048 */
	/* --- cacheline 84 boundary (5376 bytes) was 56 bytes ago --- */
	_Bool                      intr_enabled;         /*  5432     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 85 boundary (5440 bytes) --- */
	dma_addr_t                 intr_root;            /*  5440     8 */
	uint32_t                   intr_size;            /*  5448     4 */
	_Bool                      intr_eime;            /*  5452     1 */

	/* XXX 3 bytes hole, try to pack */

	OnOffAuto                  intr_eim;             /*  5456     4 */
	_Bool                      buggy_eim;            /*  5460     1 */

	/* Force padding: */
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;

	/* size: 5472, cachelines: 86, members: 30 */
	/* sum members: 5439, holes: 6, sum holes: 22 */
	/* padding: 11 */
	/* last cacheline: 32 bytes */
};
struct VTDAddressSpace {
	PCIBus *                   bus;                  /*     0     8 */
	uint8_t                    devfn;                /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	AddressSpace               as;                   /*    16   272 */
	/* --- cacheline 4 boundary (256 bytes) was 32 bytes ago --- */
	MemoryRegion               iommu;                /*   288   256 */
	/* --- cacheline 8 boundary (512 bytes) was 32 bytes ago --- */
	MemoryRegion               iommu_ir;             /*   544   256 */
	/* --- cacheline 12 boundary (768 bytes) was 32 bytes ago --- */
	IntelIOMMUState *          iommu_state;          /*   800     8 */
	VTDContextCacheEntry       context_cache_entry;  /*   808    24 */

	/* size: 832, cachelines: 13, members: 7 */
	/* sum members: 825, holes: 1, sum holes: 7 */
};
struct VTDBus {
	PCIBus *                   bus;                  /*     0     8 */
	VTDAddressSpace *          dev_as[];             /*     8     0 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct e820_entry {
	uint64_t                   address;              /*     0     8 */
	uint64_t                   length;               /*     8     8 */
	uint32_t                   type;                 /*    16     4 */

	/* size: 20, cachelines: 1, members: 3 */
	/* last cacheline: 20 bytes */
} __attribute__((__packed__));
struct e820_table {
	uint32_t                   count;                /*     0     4 */
	struct e820_entry          entry[16];            /*     4   320 */

	/* size: 324, cachelines: 6, members: 2 */
	/* last cacheline: 4 bytes */
} __attribute__((__packed__));
struct pc_cmos_init_late_arg {
	ISADevice *                rtc_state;            /*     0     8 */
	BusState *                 idebus[2];            /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
struct check_fdc_state {
	ISADevice *                floppy;               /*     0     8 */
	_Bool                      multiple;             /*     8     1 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct Port92State {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	MemoryRegion               io;                   /*   128   256 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	uint8_t                    outport;              /*   384     1 */

	/* XXX 7 bytes hole, try to pack */

	qemu_irq                   a20_out;              /*   392     8 */

	/* size: 400, cachelines: 7, members: 4 */
	/* sum members: 393, holes: 1, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct setup_data {
	uint64_t                   next;                 /*     0     8 */
	uint32_t                   type;                 /*     8     4 */
	uint32_t                   len;                  /*    12     4 */
	uint8_t                    data[];               /*    16     0 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct GlobalProperty {
	const char  *              driver;               /*     0     8 */
	const char  *              property;             /*     8     8 */
	const char  *              value;                /*    16     8 */
	_Bool                      user_provided;        /*    24     1 */
	_Bool                      used;                 /*    25     1 */

	/* XXX 6 bytes hole, try to pack */

	Error * *                  errp;                 /*    32     8 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 34, holes: 1, sum holes: 6 */
	/* last cacheline: 40 bytes */
};
struct PCIExpressHost {
	PCIHostState               pci;                  /*     0  1568 */
	/* --- cacheline 24 boundary (1536 bytes) was 32 bytes ago --- */
	hwaddr                     base_addr;            /*  1568     8 */
	hwaddr                     size;                 /*  1576     8 */
	MemoryRegion               mmio;                 /*  1584   256 */

	/* size: 1840, cachelines: 29, members: 4 */
	/* last cacheline: 48 bytes */
};
struct PCIHostState {
	SysBusDevice               busdev;               /*     0   768 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	MemoryRegion               conf_mem;             /*   768   256 */
	/* --- cacheline 16 boundary (1024 bytes) --- */
	MemoryRegion               data_mem;             /*  1024   256 */
	/* --- cacheline 20 boundary (1280 bytes) --- */
	MemoryRegion               mmcfg;                /*  1280   256 */
	/* --- cacheline 24 boundary (1536 bytes) --- */
	uint32_t                   config_reg;           /*  1536     4 */

	/* XXX 4 bytes hole, try to pack */

	PCIBus *                   bus;                  /*  1544     8 */
	struct {
		struct PCIHostState * le_next;           /*  1552     8 */
		struct PCIHostState * * le_prev;         /*  1560     8 */
	} next;                                          /*  1552    16 */

	/* size: 1568, cachelines: 25, members: 7 */
	/* sum members: 1564, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct Range {
	uint64_t                   lob;                  /*     0     8 */
	uint64_t                   upb;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PAMMemoryRegion {
	MemoryRegion               alias[4];             /*     0  1024 */
	/* --- cacheline 16 boundary (1024 bytes) --- */
	unsigned int               current;              /*  1024     4 */

	/* Force padding: */
	unsigned int               :32;
	unsigned int               :32;
	unsigned int               :32;

	/* size: 1040, cachelines: 17, members: 2 */
	/* padding: 12 */
	/* last cacheline: 16 bytes */
};
struct MCHPCIState {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	MemoryRegion *             ram_memory;           /*  2288     8 */
	MemoryRegion *             pci_address_space;    /*  2296     8 */
	/* --- cacheline 36 boundary (2304 bytes) --- */
	MemoryRegion *             system_memory;        /*  2304     8 */
	MemoryRegion *             address_space_io;     /*  2312     8 */
	PAMMemoryRegion            pam_regions[13];      /*  2320 13520 */
	/* --- cacheline 247 boundary (15808 bytes) was 32 bytes ago --- */
	MemoryRegion               smram_region;         /* 15840   256 */
	/* --- cacheline 251 boundary (16064 bytes) was 32 bytes ago --- */
	MemoryRegion               open_high_smram;      /* 16096   256 */
	/* --- cacheline 255 boundary (16320 bytes) was 32 bytes ago --- */
	MemoryRegion               smram;                /* 16352   256 */
	/* --- cacheline 259 boundary (16576 bytes) was 32 bytes ago --- */
	MemoryRegion               low_smram;            /* 16608   256 */
	/* --- cacheline 263 boundary (16832 bytes) was 32 bytes ago --- */
	MemoryRegion               high_smram;           /* 16864   256 */
	/* --- cacheline 267 boundary (17088 bytes) was 32 bytes ago --- */
	MemoryRegion               tseg_blackhole;       /* 17120   256 */
	/* --- cacheline 271 boundary (17344 bytes) was 32 bytes ago --- */
	MemoryRegion               tseg_window;          /* 17376   256 */
	/* --- cacheline 275 boundary (17600 bytes) was 32 bytes ago --- */
	Range                      pci_hole;             /* 17632    16 */
	uint64_t                   below_4g_mem_size;    /* 17648     8 */
	uint64_t                   above_4g_mem_size;    /* 17656     8 */
	/* --- cacheline 276 boundary (17664 bytes) --- */
	uint64_t                   pci_hole64_size;      /* 17664     8 */
	uint32_t                   short_root_bus;       /* 17672     4 */

	/* size: 17680, cachelines: 277, members: 18 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct Q35PCIHost {
	PCIExpressHost             parent_obj;           /*     0  1840 */
	/* --- cacheline 28 boundary (1792 bytes) was 48 bytes ago --- */
	MCHPCIState                mch;                  /*  1840 17680 */

	/* size: 19520, cachelines: 305, members: 2 */
};
struct IDEBus {
	BusState                   qbus;                 /*     0   104 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	IDEDevice *                master;               /*   104     8 */
	IDEDevice *                slave;                /*   112     8 */
	IDEState                   ifs[2];               /*   120  1952 */
	/* --- cacheline 32 boundary (2048 bytes) was 24 bytes ago --- */
	QEMUBH *                   bh;                   /*  2072     8 */
	int                        bus_id;               /*  2080     4 */
	int                        max_units;            /*  2084     4 */
	IDEDMA *                   dma;                  /*  2088     8 */
	uint8_t                    unit;                 /*  2096     1 */
	uint8_t                    cmd;                  /*  2097     1 */

	/* XXX 6 bytes hole, try to pack */

	qemu_irq                   irq;                  /*  2104     8 */
	/* --- cacheline 33 boundary (2112 bytes) --- */
	int                        error_status;         /*  2112     4 */
	uint8_t                    retry_unit;           /*  2116     1 */

	/* XXX 3 bytes hole, try to pack */

	int64_t                    retry_sector_num;     /*  2120     8 */
	uint32_t                   retry_nsector;        /*  2128     4 */

	/* XXX 4 bytes hole, try to pack */

	PortioList                 portio_list;          /*  2136    64 */
	/* --- cacheline 34 boundary (2176 bytes) was 24 bytes ago --- */
	PortioList                 portio2_list;         /*  2200    64 */
	/* --- cacheline 35 boundary (2240 bytes) was 24 bytes ago --- */
	VMChangeStateEntry *       vmstate;              /*  2264     8 */

	/* size: 2272, cachelines: 36, members: 18 */
	/* sum members: 2259, holes: 3, sum holes: 13 */
	/* last cacheline: 32 bytes */
};
struct IDEDevice {
	DeviceState                qdev;                 /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	uint32_t                   unit;                 /*   112     4 */

	/* XXX 4 bytes hole, try to pack */

	BlockConf                  conf;                 /*   120    56 */
	/* --- cacheline 2 boundary (128 bytes) was 48 bytes ago --- */
	int                        chs_trans;            /*   176     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     version;              /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	char *                     serial;               /*   192     8 */
	char *                     model;                /*   200     8 */
	uint64_t                   wwn;                  /*   208     8 */

	/* size: 216, cachelines: 4, members: 8 */
	/* sum members: 208, holes: 2, sum holes: 8 */
	/* last cacheline: 24 bytes */
};
struct IDEState {
	IDEBus *                   bus;                  /*     0     8 */
	uint8_t                    unit;                 /*     8     1 */

	/* XXX 3 bytes hole, try to pack */

	IDEDriveKind               drive_kind;           /*    12     4 */
	int                        cylinders;            /*    16     4 */
	int                        heads;                /*    20     4 */
	int                        sectors;              /*    24     4 */
	int                        chs_trans;            /*    28     4 */
	int64_t                    nb_sectors;           /*    32     8 */
	int                        mult_sectors;         /*    40     4 */
	int                        identify_set;         /*    44     4 */
	uint8_t                    identify_data[512];   /*    48   512 */
	/* --- cacheline 8 boundary (512 bytes) was 48 bytes ago --- */
	int                        drive_serial;         /*   560     4 */
	char                       drive_serial_str[21]; /*   564    21 */
	/* --- cacheline 9 boundary (576 bytes) was 9 bytes ago --- */
	char                       drive_model_str[41];  /*   585    41 */

	/* XXX 6 bytes hole, try to pack */

	uint64_t                   wwn;                  /*   632     8 */
	/* --- cacheline 10 boundary (640 bytes) --- */
	uint8_t                    feature;              /*   640     1 */
	uint8_t                    error;                /*   641     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   nsector;              /*   644     4 */
	uint8_t                    sector;               /*   648     1 */
	uint8_t                    lcyl;                 /*   649     1 */
	uint8_t                    hcyl;                 /*   650     1 */
	uint8_t                    hob_feature;          /*   651     1 */
	uint8_t                    hob_nsector;          /*   652     1 */
	uint8_t                    hob_sector;           /*   653     1 */
	uint8_t                    hob_lcyl;             /*   654     1 */
	uint8_t                    hob_hcyl;             /*   655     1 */
	uint8_t                    select;               /*   656     1 */
	uint8_t                    status;               /*   657     1 */
	uint8_t                    lba48;                /*   658     1 */

	/* XXX 5 bytes hole, try to pack */

	BlockBackend *             blk;                  /*   664     8 */
	char                       version[9];           /*   672     9 */
	struct unreported_events   events;               /*   681     2 */
	uint8_t                    sense_key;            /*   683     1 */
	uint8_t                    asc;                  /*   684     1 */
	_Bool                      tray_open;            /*   685     1 */
	_Bool                      tray_locked;          /*   686     1 */
	uint8_t                    cdrom_changed;        /*   687     1 */
	int                        packet_transfer_size; /*   688     4 */
	int                        elementary_transfer_size; /*   692     4 */
	int32_t                    io_buffer_index;      /*   696     4 */
	int                        lba;                  /*   700     4 */
	/* --- cacheline 11 boundary (704 bytes) --- */
	int                        cd_sector_size;       /*   704     4 */
	int                        atapi_dma;            /*   708     4 */
	BlockAcctCookie            acct;                 /*   712    24 */
	BlockAIOCB *               pio_aiocb;            /*   736     8 */
	struct iovec               iov;                  /*   744    16 */
	QEMUIOVector               qiov;                 /*   760    24 */
	/* --- cacheline 12 boundary (768 bytes) was 16 bytes ago --- */
	struct {
		struct IDEBufferedRequest * lh_first;    /*   784     8 */
	} buffered_requests;                             /*   784     8 */
	uint64_t                   io_buffer_offset;     /*   792     8 */
	int32_t                    io_buffer_size;       /*   800     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUSGList                 sg;                   /*   808    40 */
	/* --- cacheline 13 boundary (832 bytes) was 16 bytes ago --- */
	int                        req_nb_sectors;       /*   848     4 */

	/* XXX 4 bytes hole, try to pack */

	EndTransferFunc *          end_transfer_func;    /*   856     8 */
	uint8_t *                  data_ptr;             /*   864     8 */
	uint8_t *                  data_end;             /*   872     8 */
	uint8_t *                  io_buffer;            /*   880     8 */
	int32_t                    io_buffer_total_len;  /*   888     4 */
	int32_t                    cur_io_buffer_offset; /*   892     4 */
	/* --- cacheline 14 boundary (896 bytes) --- */
	int32_t                    cur_io_buffer_len;    /*   896     4 */
	uint8_t                    end_transfer_fn_idx;  /*   900     1 */

	/* XXX 3 bytes hole, try to pack */

	QEMUTimer *                sector_write_timer;   /*   904     8 */
	uint32_t                   irq_count;            /*   912     4 */
	uint8_t                    ext_error;            /*   916     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   mdata_size;           /*   920     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  mdata_storage;        /*   928     8 */
	int                        media_changed;        /*   936     4 */
	enum ide_dma_cmd           dma_cmd;              /*   940     4 */
	uint8_t                    smart_enabled;        /*   944     1 */
	uint8_t                    smart_autosave;       /*   945     1 */

	/* XXX 2 bytes hole, try to pack */

	int                        smart_errors;         /*   948     4 */
	uint8_t                    smart_selftest_count; /*   952     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 15 boundary (960 bytes) --- */
	uint8_t *                  smart_selftest_data;  /*   960     8 */
	int                        ncq_queues;           /*   968     4 */

	/* size: 976, cachelines: 16, members: 73 */
	/* sum members: 929, holes: 11, sum holes: 43 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct IDEDMA {
	const struct IDEDMAOps  *  ops;                  /*     0     8 */
	struct iovec               iov;                  /*     8    16 */
	QEMUIOVector               qiov;                 /*    24    24 */
	BlockAIOCB *               aiocb;                /*    48     8 */

	/* size: 56, cachelines: 1, members: 4 */
	/* last cacheline: 56 bytes */
};
struct IDEDMAOps {
	DMAStartFunc *             start_dma;            /*     0     8 */
	DMAVoidFunc *              start_transfer;       /*     8     8 */
	DMAInt32Func *             prepare_buf;          /*    16     8 */
	DMAu32Func *               commit_buf;           /*    24     8 */
	DMAIntFunc *               rw_buf;               /*    32     8 */
	DMAVoidFunc *              restart;              /*    40     8 */
	DMAVoidFunc *              restart_dma;          /*    48     8 */
	DMAStopFunc *              set_inactive;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	DMAVoidFunc *              cmd_done;             /*    64     8 */
	DMAVoidFunc *              reset;                /*    72     8 */

	/* size: 80, cachelines: 2, members: 10 */
	/* last cacheline: 16 bytes */
};
struct unreported_events {
	_Bool                      eject_request;        /*     0     1 */
	_Bool                      new_media;            /*     1     1 */

	/* size: 2, cachelines: 1, members: 2 */
	/* last cacheline: 2 bytes */
};
struct IDEBufferedRequest {
	struct {
		struct IDEBufferedRequest * le_next;     /*     0     8 */
		struct IDEBufferedRequest * * le_prev;   /*     8     8 */
	} list;                                          /*     0    16 */
	struct iovec               iov;                  /*    16    16 */
	QEMUIOVector               qiov;                 /*    32    24 */
	QEMUIOVector *             original_qiov;        /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	BlockCompletionFunc *      original_cb;          /*    64     8 */
	void *                     original_opaque;      /*    72     8 */
	_Bool                      orphaned;             /*    80     1 */

	/* size: 88, cachelines: 2, members: 7 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct AHCIControlRegs {
	uint32_t                   cap;                  /*     0     4 */
	uint32_t                   ghc;                  /*     4     4 */
	uint32_t                   irqstatus;            /*     8     4 */
	uint32_t                   impl;                 /*    12     4 */
	uint32_t                   version;              /*    16     4 */

	/* size: 20, cachelines: 1, members: 5 */
	/* last cacheline: 20 bytes */
};
struct AHCIPortRegs {
	uint32_t                   lst_addr;             /*     0     4 */
	uint32_t                   lst_addr_hi;          /*     4     4 */
	uint32_t                   fis_addr;             /*     8     4 */
	uint32_t                   fis_addr_hi;          /*    12     4 */
	uint32_t                   irq_stat;             /*    16     4 */
	uint32_t                   irq_mask;             /*    20     4 */
	uint32_t                   cmd;                  /*    24     4 */
	uint32_t                   unused0;              /*    28     4 */
	uint32_t                   tfdata;               /*    32     4 */
	uint32_t                   sig;                  /*    36     4 */
	uint32_t                   scr_stat;             /*    40     4 */
	uint32_t                   scr_ctl;              /*    44     4 */
	uint32_t                   scr_err;              /*    48     4 */
	uint32_t                   scr_act;              /*    52     4 */
	uint32_t                   cmd_issue;            /*    56     4 */
	uint32_t                   reserved;             /*    60     4 */

	/* size: 64, cachelines: 1, members: 16 */
};
struct AHCICmdHdr {
	uint16_t                   opts;                 /*     0     2 */
	uint16_t                   prdtl;                /*     2     2 */
	uint32_t                   status;               /*     4     4 */
	uint64_t                   tbl_addr;             /*     8     8 */
	uint32_t                   reserved[4];          /*    16    16 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct AHCIDevice {
	IDEDMA                     dma;                  /*     0    56 */
	IDEBus                     port;                 /*    56  2272 */
	/* --- cacheline 36 boundary (2304 bytes) was 24 bytes ago --- */
	int                        port_no;              /*  2328     4 */
	uint32_t                   port_state;           /*  2332     4 */
	uint32_t                   finished;             /*  2336     4 */
	AHCIPortRegs               port_regs;            /*  2340    64 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 37 boundary (2368 bytes) was 40 bytes ago --- */
	struct AHCIState *         hba;                  /*  2408     8 */
	QEMUBH *                   check_bh;             /*  2416     8 */
	uint8_t *                  lst;                  /*  2424     8 */
	/* --- cacheline 38 boundary (2432 bytes) --- */
	uint8_t *                  res_fis;              /*  2432     8 */
	_Bool                      done_atapi_packet;    /*  2440     1 */

	/* XXX 3 bytes hole, try to pack */

	int32_t                    busy_slot;            /*  2444     4 */
	_Bool                      init_d2h_sent;        /*  2448     1 */

	/* XXX 7 bytes hole, try to pack */

	AHCICmdHdr *               cur_cmd;              /*  2456     8 */
	NCQTransferState           ncq_tfs[32];          /*  2464  3584 */

	/* size: 6048, cachelines: 95, members: 15 */
	/* sum members: 6034, holes: 3, sum holes: 14 */
	/* last cacheline: 32 bytes */
};
struct NCQTransferState {
	AHCIDevice *               drive;                /*     0     8 */
	BlockAIOCB *               aiocb;                /*     8     8 */
	AHCICmdHdr *               cmdh;                 /*    16     8 */
	QEMUSGList                 sglist;               /*    24    40 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	BlockAcctCookie            acct;                 /*    64    24 */
	uint32_t                   sector_count;         /*    88     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   lba;                  /*    96     8 */
	uint8_t                    tag;                  /*   104     1 */
	uint8_t                    cmd;                  /*   105     1 */
	uint8_t                    slot;                 /*   106     1 */
	_Bool                      used;                 /*   107     1 */
	_Bool                      halt;                 /*   108     1 */

	/* size: 112, cachelines: 2, members: 12 */
	/* sum members: 105, holes: 1, sum holes: 4 */
	/* padding: 3 */
	/* last cacheline: 48 bytes */
};
struct AHCIState {
	DeviceState *              container;            /*     0     8 */
	AHCIDevice *               dev;                  /*     8     8 */
	AHCIControlRegs            control_regs;         /*    16    20 */

	/* XXX 12 bytes hole, try to pack */

	MemoryRegion               mem;                  /*    48   256 */
	/* --- cacheline 4 boundary (256 bytes) was 48 bytes ago --- */
	MemoryRegion               idp;                  /*   304   256 */
	/* --- cacheline 8 boundary (512 bytes) was 48 bytes ago --- */
	unsigned int               idp_offset;           /*   560     4 */
	uint32_t                   idp_index;            /*   564     4 */
	int32_t                    ports;                /*   568     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 9 boundary (576 bytes) --- */
	qemu_irq                   irq;                  /*   576     8 */
	AddressSpace *             as;                   /*   584     8 */

	/* size: 592, cachelines: 10, members: 10 */
	/* sum members: 576, holes: 2, sum holes: 16 */
	/* last cacheline: 16 bytes */
};
struct AHCIPCIState {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	AHCIState                  ahci;                 /*  2288   592 */

	/* size: 2880, cachelines: 45, members: 2 */
};
struct Location {
	enum {
		LOC_NONE = 0,
		LOC_CMDLINE = 1,
		LOC_FILE = 2,
	} kind;                                          /*     0     4 */
	int                        num;                  /*     4     4 */
	const void  *              ptr;                  /*     8     8 */
	struct Location *          prev;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct X86IOMMUClass {
	SysBusDeviceClass          parent;               /*     0   216 */
	/* --- cacheline 3 boundary (192 bytes) was 24 bytes ago --- */
	DeviceRealize              realize;              /*   216     8 */
	int                        (*int_remap)(X86IOMMUState *, MSIMessage *, MSIMessage *, uint16_t); /*   224     8 */

	/* size: 232, cachelines: 4, members: 3 */
	/* last cacheline: 40 bytes */
};
struct _GHashTableIter {
	gpointer                   dummy1;               /*     0     8 */
	gpointer                   dummy2;               /*     8     8 */
	gpointer                   dummy3;               /*    16     8 */
	int                        dummy4;               /*    24     4 */
	gboolean                   dummy5;               /*    28     4 */
	gpointer                   dummy6;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 6 */
	/* last cacheline: 40 bytes */
};
struct VTDIOTLBEntry {
	uint64_t                   gfn;                  /*     0     8 */
	uint16_t                   domain_id;            /*     8     2 */

	/* XXX 6 bytes hole, try to pack */

	uint64_t                   slpte;                /*    16     8 */
	uint64_t                   mask;                 /*    24     8 */
	_Bool                      read_flags;           /*    32     1 */
	_Bool                      write_flags;          /*    33     1 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 28, holes: 1, sum holes: 6 */
	/* padding: 6 */
	/* last cacheline: 40 bytes */
};
union VTD_IR_TableEntry {
	struct {
		uint32_t           present:1;          /*     0: 0  4 */
		uint32_t           fault_disable:1;    /*     0: 1  4 */
		uint32_t           dest_mode:1;        /*     0: 2  4 */
		uint32_t           redir_hint:1;       /*     0: 3  4 */
		uint32_t           trigger_mode:1;     /*     0: 4  4 */
		uint32_t           delivery_mode:3;    /*     0: 5  4 */
		uint32_t           __avail:4;          /*     0: 8  4 */
		uint32_t           __reserved_0:3;     /*     0:12  4 */
		uint32_t           irte_mode:1;        /*     0:15  4 */
		uint32_t           vector:8;           /*     0:16  4 */
		uint32_t           __reserved_1:8;     /*     0:24  4 */
		uint32_t           dest_id;            /*     4     4 */
		uint16_t           source_id;          /*     8     2 */

		/* Bitfield combined with previous fields */

		uint64_t           sid_q:2;            /*     8:16  8 */
		uint64_t           sid_vtype:2;        /*     8:18  8 */
		uint64_t           __reserved_2:44;    /*     8:20  8 */
	} irte;                                        /*     0    16 */
	uint64_t                   data[2];            /*     0    16 */
};
union VTD_IR_MSIAddress {
	struct {
		uint32_t           __not_care:2;       /*     0: 0  4 */
		uint32_t           index_h:1;          /*     0: 2  4 */
		uint32_t           sub_valid:1;        /*     0: 3  4 */
		uint32_t           int_mode:1;         /*     0: 4  4 */
		uint32_t           index_l:15;         /*     0: 5  4 */
		uint32_t           __head:12;          /*     0:20  4 */
	} addr;                                        /*     0     4 */
	uint32_t                   data;               /*     0     4 */
};
struct VTDIrq {
	uint8_t                    trigger_mode;         /*     0     1 */
	uint8_t                    vector;               /*     1     1 */
	uint8_t                    delivery_mode;        /*     2     1 */

	/* XXX 1 byte hole, try to pack */

	uint32_t                   dest;                 /*     4     4 */
	uint8_t                    dest_mode;            /*     8     1 */
	uint8_t                    redir_hint;           /*     9     1 */
	uint8_t                    msi_addr_last_bits;   /*    10     1 */

	/* size: 12, cachelines: 1, members: 7 */
	/* sum members: 10, holes: 1, sum holes: 1 */
	/* padding: 1 */
	/* last cacheline: 12 bytes */
};
struct VTD_MSIMessage {
	union {
		struct {
			uint32_t   __not_used:2;         /*     0: 0  4 */
			uint32_t   dest_mode:1;          /*     0: 2  4 */
			uint32_t   redir_hint:1;         /*     0: 3  4 */
			uint32_t   __reserved:8;         /*     0: 4  4 */
			uint32_t   dest:8;               /*     0:12  4 */
			uint32_t   __addr_head:12;       /*     0:20  4 */
			uint32_t   __addr_hi;            /*     4     4 */
		};                                       /*     0     8 */
		uint64_t           msi_addr;             /*     0     8 */
	};                                               /*     0     8 */
	union {
		struct {
			uint16_t   vector:8;             /*     8: 0  2 */
			uint16_t   delivery_mode:3;      /*     8: 8  2 */
			uint16_t   __resved:3;           /*     8:11  2 */
			uint16_t   level:1;              /*     8:14  2 */
			uint16_t   trigger_mode:1;       /*     8:15  2 */
			uint16_t   __resved1;            /*    10     2 */
		};                                       /*     8     4 */
		uint32_t           msi_data;             /*     8     4 */
	};                                               /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct VTDInvDescIEC {
	uint32_t                   type:4;               /*     0: 0  4 */
	uint32_t                   granularity:1;        /*     0: 4  4 */
	uint32_t                   resved_1:22;          /*     0: 5  4 */
	uint32_t                   index_mask:5;         /*     0:27  4 */
	uint32_t                   index:16;             /*     4: 0  4 */
	uint32_t                   reserved_2:16;        /*     4:16  4 */

	/* size: 8, cachelines: 1, members: 6 */
	/* last cacheline: 8 bytes */
};
union VTDInvDesc {
	struct {
		uint64_t           lo;                 /*     0     8 */
		uint64_t           hi;                 /*     8     8 */
	};                                             /*     0    16 */
	union {
		VTDInvDescIEC      iec;                /*     0     8 */
	};                                             /*     0     8 */
};
struct VTDIOTLBPageInvInfo {
	uint16_t                   domain_id;            /*     0     2 */

	/* XXX 6 bytes hole, try to pack */

	uint64_t                   addr;                 /*     8     8 */
	uint8_t                    mask;                 /*    16     1 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 11, holes: 1, sum holes: 6 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct VTDRootEntry {
	uint64_t                   val;                  /*     0     8 */
	uint64_t                   rsvd;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct AMDVIAddressSpace {
	uint8_t                    bus_num;              /*     0     1 */
	uint8_t                    devfn;                /*     1     1 */

	/* XXX 6 bytes hole, try to pack */

	AMDVIState *               iommu_state;          /*     8     8 */
	MemoryRegion               iommu;                /*    16   256 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	MemoryRegion               iommu_ir;             /*   272   256 */
	/* --- cacheline 8 boundary (512 bytes) was 16 bytes ago --- */
	AddressSpace               as;                   /*   528   272 */

	/* size: 800, cachelines: 13, members: 6 */
	/* sum members: 794, holes: 1, sum holes: 6 */
	/* last cacheline: 32 bytes */
};
struct AMDVIPCIState {
	PCIDevice                  dev;                  /*     0  2288 */

	/* size: 2288, cachelines: 36, members: 1 */
	/* last cacheline: 48 bytes */
};
struct AMDVIState {
	X86IOMMUState              iommu;                /*     0   784 */
	/* --- cacheline 12 boundary (768 bytes) was 16 bytes ago --- */
	AMDVIPCIState              pci;                  /*   784  2288 */
	/* --- cacheline 48 boundary (3072 bytes) --- */
	uint32_t                   version;              /*  3072     4 */
	uint32_t                   capab_offset;         /*  3076     4 */
	uint64_t                   mmio_addr;            /*  3080     8 */
	uint32_t                   devid;                /*  3088     4 */
	_Bool                      enabled;              /*  3092     1 */
	_Bool                      ats_enabled;          /*  3093     1 */
	_Bool                      cmdbuf_enabled;       /*  3094     1 */
	_Bool                      evtlog_enabled;       /*  3095     1 */
	_Bool                      excl_enabled;         /*  3096     1 */

	/* XXX 7 bytes hole, try to pack */

	hwaddr                     devtab;               /*  3104     8 */
	size_t                     devtab_len;           /*  3112     8 */
	hwaddr                     cmdbuf;               /*  3120     8 */
	uint64_t                   cmdbuf_len;           /*  3128     8 */
	/* --- cacheline 49 boundary (3136 bytes) --- */
	uint32_t                   cmdbuf_head;          /*  3136     4 */
	uint32_t                   cmdbuf_tail;          /*  3140     4 */
	_Bool                      completion_wait_intr; /*  3144     1 */

	/* XXX 7 bytes hole, try to pack */

	hwaddr                     evtlog;               /*  3152     8 */
	_Bool                      evtlog_intr;          /*  3160     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   evtlog_len;           /*  3164     4 */
	uint32_t                   evtlog_head;          /*  3168     4 */
	uint32_t                   evtlog_tail;          /*  3172     4 */
	hwaddr                     excl_base;            /*  3176     8 */
	hwaddr                     excl_limit;           /*  3184     8 */
	_Bool                      excl_allow;           /*  3192     1 */
	_Bool                      excl_enable;          /*  3193     1 */

	/* XXX 6 bytes hole, try to pack */

	/* --- cacheline 50 boundary (3200 bytes) --- */
	hwaddr                     ppr_log;              /*  3200     8 */
	uint32_t                   pprlog_len;           /*  3208     4 */
	uint32_t                   pprlog_head;          /*  3212     4 */
	uint32_t                   pprlog_tail;          /*  3216     4 */

	/* XXX 12 bytes hole, try to pack */

	MemoryRegion               mmio;                 /*  3232   256 */
	/* --- cacheline 54 boundary (3456 bytes) was 32 bytes ago --- */
	uint8_t                    mmior[16384];         /*  3488 16384 */
	/* --- cacheline 310 boundary (19840 bytes) was 32 bytes ago --- */
	uint8_t                    w1cmask[16384];       /* 19872 16384 */
	/* --- cacheline 566 boundary (36224 bytes) was 32 bytes ago --- */
	uint8_t                    romask[16384];        /* 36256 16384 */
	/* --- cacheline 822 boundary (52608 bytes) was 32 bytes ago --- */
	_Bool                      mmio_enabled;         /* 52640     1 */

	/* XXX 7 bytes hole, try to pack */

	MemoryRegionIOMMUOps       iommu_ops;            /* 52648    24 */
	/* --- cacheline 823 boundary (52672 bytes) --- */
	AMDVIAddressSpace * *      address_spaces[256];  /* 52672  2048 */
	/* --- cacheline 855 boundary (54720 bytes) --- */
	GHashTable *               iotlb;                /* 54720     8 */

	/* size: 54736, cachelines: 856, members: 39 */
	/* sum members: 54686, holes: 6, sum holes: 42 */
	/* padding: 8 */
	/* last cacheline: 16 bytes */
};
struct AMDVIIOTLBEntry {
	uint16_t                   domid;                /*     0     2 */
	uint16_t                   devid;                /*     2     2 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   perms;                /*     8     8 */
	uint64_t                   translated_addr;      /*    16     8 */
	uint64_t                   page_mask;            /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct VAPICHandlers {
	uint32_t                   set_tpr;              /*     0     4 */
	uint32_t                   set_tpr_eax;          /*     4     4 */
	uint32_t                   get_tpr[8];           /*     8    32 */
	uint32_t                   get_tpr_stack;        /*    40     4 */

	/* size: 44, cachelines: 1, members: 4 */
	/* last cacheline: 44 bytes */
};
struct GuestROMState {
	char                       signature[8];         /*     0     8 */
	uint32_t                   vaddr;                /*     8     4 */
	uint32_t                   fixup_start;          /*    12     4 */
	uint32_t                   fixup_end;            /*    16     4 */
	uint32_t                   vapic_vaddr;          /*    20     4 */
	uint32_t                   vapic_size;           /*    24     4 */
	uint32_t                   vcpu_shift;           /*    28     4 */
	uint32_t                   real_tpr_addr;        /*    32     4 */
	VAPICHandlers              up;                   /*    36    44 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	VAPICHandlers              mp;                   /*    80    44 */

	/* size: 124, cachelines: 2, members: 10 */
	/* last cacheline: 60 bytes */
};
struct VAPICROMState {
	SysBusDevice               busdev;               /*     0   768 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	MemoryRegion               io;                   /*   768   256 */
	/* --- cacheline 16 boundary (1024 bytes) --- */
	MemoryRegion               rom;                  /*  1024   256 */
	/* --- cacheline 20 boundary (1280 bytes) --- */
	uint32_t                   state;                /*  1280     4 */
	uint32_t                   rom_state_paddr;      /*  1284     4 */
	uint32_t                   rom_state_vaddr;      /*  1288     4 */
	uint32_t                   vapic_paddr;          /*  1292     4 */
	uint32_t                   real_tpr_addr;        /*  1296     4 */
	GuestROMState              rom_state;            /*  1300   124 */
	/* --- cacheline 22 boundary (1408 bytes) was 16 bytes ago --- */
	size_t                     rom_size;             /*  1424     8 */
	_Bool                      rom_mapped_writable;  /*  1432     1 */

	/* XXX 7 bytes hole, try to pack */

	VMChangeStateEntry *       vmsentry;             /*  1440     8 */

	/* size: 1456, cachelines: 23, members: 12 */
	/* sum members: 1441, holes: 1, sum holes: 7 */
	/* padding: 8 */
	/* last cacheline: 48 bytes */
};
struct TPRInstruction {
	uint8_t                    opcode;               /*     0     1 */
	uint8_t                    modrm_reg;            /*     1     1 */

	/* XXX 2 bytes hole, try to pack */

	unsigned int               flags;                /*     4     4 */
	TPRAccess                  access;               /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     length;               /*    16     8 */
	off_t                      addr_offset;          /*    24     8 */

	/* size: 32, cachelines: 1, members: 6 */
	/* sum members: 26, holes: 2, sum holes: 6 */
	/* last cacheline: 32 bytes */
};
struct VAPICEnableTPRReporting {
	DeviceState *              apic;                 /*     0     8 */
	_Bool                      enable;               /*     8     1 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct _GPtrArray {
	gpointer *                 pdata;                /*     0     8 */
	guint                      len;                  /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct PCIBridge {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	PCIBus                     sec_bus;              /*  2288  2296 */

	/* XXX 8 bytes hole, try to pack */

	/* --- cacheline 71 boundary (4544 bytes) was 48 bytes ago --- */
	MemoryRegion               address_space_mem;    /*  4592   256 */
	/* --- cacheline 75 boundary (4800 bytes) was 48 bytes ago --- */
	MemoryRegion               address_space_io;     /*  4848   256 */
	/* --- cacheline 79 boundary (5056 bytes) was 48 bytes ago --- */
	PCIBridgeWindows *         windows;              /*  5104     8 */
	pci_map_irq_fn             map_irq;              /*  5112     8 */
	/* --- cacheline 80 boundary (5120 bytes) --- */
	const char  *              bus_name;             /*  5120     8 */

	/* size: 5136, cachelines: 81, members: 7 */
	/* sum members: 5120, holes: 1, sum holes: 8 */
	/* padding: 8 */
	/* last cacheline: 16 bytes */
};
struct BIOSLinker {
	GArray *                   cmd_blob;             /*     0     8 */
	GArray *                   file_list;            /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct Acpi20GenericAddress {
	uint8_t                    address_space_id;     /*     0     1 */
	uint8_t                    register_bit_width;   /*     1     1 */
	uint8_t                    register_bit_offset;  /*     2     1 */
	uint8_t                    reserved;             /*     3     1 */
	uint64_t                   address;              /*     4     8 */

	/* size: 12, cachelines: 1, members: 5 */
	/* last cacheline: 12 bytes */
} __attribute__((__packed__));
struct AcpiRsdpDescriptor {
	uint64_t                   signature;            /*     0     8 */
	uint8_t                    checksum;             /*     8     1 */
	uint8_t                    oem_id[6];            /*     9     6 */
	uint8_t                    revision;             /*    15     1 */
	uint32_t                   rsdt_physical_address; /*    16     4 */
	uint32_t                   length;               /*    20     4 */
	uint64_t                   xsdt_physical_address; /*    24     8 */
	uint8_t                    extended_checksum;    /*    32     1 */
	uint8_t                    reserved[3];          /*    33     3 */

	/* size: 36, cachelines: 1, members: 9 */
	/* last cacheline: 36 bytes */
} __attribute__((__packed__));
struct AcpiTableHeader {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   length;               /*     4     4 */
	uint8_t                    revision;             /*     8     1 */
	uint8_t                    checksum;             /*     9     1 */
	uint8_t                    oem_id[6];            /*    10     6 */
	uint8_t                    oem_table_id[8];      /*    16     8 */
	uint32_t                   oem_revision;         /*    24     4 */
	uint8_t                    asl_compiler_id[4];   /*    28     4 */
	uint32_t                   asl_compiler_revision; /*    32     4 */

	/* size: 36, cachelines: 1, members: 9 */
	/* last cacheline: 36 bytes */
};
struct AcpiFadtDescriptorRev1 {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   length;               /*     4     4 */
	uint8_t                    revision;             /*     8     1 */
	uint8_t                    checksum;             /*     9     1 */
	uint8_t                    oem_id[6];            /*    10     6 */
	uint8_t                    oem_table_id[8];      /*    16     8 */
	uint32_t                   oem_revision;         /*    24     4 */
	uint8_t                    asl_compiler_id[4];   /*    28     4 */
	uint32_t                   asl_compiler_revision; /*    32     4 */
	uint32_t                   firmware_ctrl;        /*    36     4 */
	uint32_t                   dsdt;                 /*    40     4 */
	uint8_t                    model;                /*    44     1 */
	uint8_t                    reserved1;            /*    45     1 */
	uint16_t                   sci_int;              /*    46     2 */
	uint32_t                   smi_cmd;              /*    48     4 */
	uint8_t                    acpi_enable;          /*    52     1 */
	uint8_t                    acpi_disable;         /*    53     1 */
	uint8_t                    S4bios_req;           /*    54     1 */
	uint8_t                    reserved2;            /*    55     1 */
	uint32_t                   pm1a_evt_blk;         /*    56     4 */
	uint32_t                   pm1b_evt_blk;         /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint32_t                   pm1a_cnt_blk;         /*    64     4 */
	uint32_t                   pm1b_cnt_blk;         /*    68     4 */
	uint32_t                   pm2_cnt_blk;          /*    72     4 */
	uint32_t                   pm_tmr_blk;           /*    76     4 */
	uint32_t                   gpe0_blk;             /*    80     4 */
	uint32_t                   gpe1_blk;             /*    84     4 */
	uint8_t                    pm1_evt_len;          /*    88     1 */
	uint8_t                    pm1_cnt_len;          /*    89     1 */
	uint8_t                    pm2_cnt_len;          /*    90     1 */
	uint8_t                    pm_tmr_len;           /*    91     1 */
	uint8_t                    gpe0_blk_len;         /*    92     1 */
	uint8_t                    gpe1_blk_len;         /*    93     1 */
	uint8_t                    gpe1_base;            /*    94     1 */
	uint8_t                    reserved3;            /*    95     1 */
	uint16_t                   plvl2_lat;            /*    96     2 */
	uint16_t                   plvl3_lat;            /*    98     2 */
	uint16_t                   flush_size;           /*   100     2 */
	uint16_t                   flush_stride;         /*   102     2 */
	uint8_t                    duty_offset;          /*   104     1 */
	uint8_t                    duty_width;           /*   105     1 */
	uint8_t                    day_alrm;             /*   106     1 */
	uint8_t                    mon_alrm;             /*   107     1 */
	uint8_t                    century;              /*   108     1 */
	uint8_t                    reserved4;            /*   109     1 */
	uint8_t                    reserved4a;           /*   110     1 */
	uint8_t                    reserved4b;           /*   111     1 */
	uint32_t                   flags;                /*   112     4 */

	/* size: 116, cachelines: 2, members: 48 */
	/* last cacheline: 52 bytes */
};
struct AcpiFacsDescriptorRev1 {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   length;               /*     4     4 */
	uint32_t                   hardware_signature;   /*     8     4 */
	uint32_t                   firmware_waking_vector; /*    12     4 */
	uint32_t                   global_lock;          /*    16     4 */
	uint32_t                   flags;                /*    20     4 */
	uint8_t                    resverved3[40];       /*    24    40 */

	/* size: 64, cachelines: 1, members: 7 */
};
struct AcpiMultipleApicTable {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   length;               /*     4     4 */
	uint8_t                    revision;             /*     8     1 */
	uint8_t                    checksum;             /*     9     1 */
	uint8_t                    oem_id[6];            /*    10     6 */
	uint8_t                    oem_table_id[8];      /*    16     8 */
	uint32_t                   oem_revision;         /*    24     4 */
	uint8_t                    asl_compiler_id[4];   /*    28     4 */
	uint32_t                   asl_compiler_revision; /*    32     4 */
	uint32_t                   local_apic_address;   /*    36     4 */
	uint32_t                   flags;                /*    40     4 */

	/* size: 44, cachelines: 1, members: 11 */
	/* last cacheline: 44 bytes */
};
struct AcpiMadtProcessorApic {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    length;               /*     1     1 */
	uint8_t                    processor_id;         /*     2     1 */
	uint8_t                    local_apic_id;        /*     3     1 */
	uint32_t                   flags;                /*     4     4 */

	/* size: 8, cachelines: 1, members: 5 */
	/* last cacheline: 8 bytes */
};
struct AcpiMadtIoApic {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    length;               /*     1     1 */
	uint8_t                    io_apic_id;           /*     2     1 */
	uint8_t                    reserved;             /*     3     1 */
	uint32_t                   address;              /*     4     4 */
	uint32_t                   interrupt;            /*     8     4 */

	/* size: 12, cachelines: 1, members: 6 */
	/* last cacheline: 12 bytes */
};
struct AcpiMadtIntsrcovr {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    length;               /*     1     1 */
	uint8_t                    bus;                  /*     2     1 */
	uint8_t                    source;               /*     3     1 */
	uint32_t                   gsi;                  /*     4     4 */
	uint16_t                   flags;                /*     8     2 */

	/* size: 10, cachelines: 1, members: 6 */
	/* last cacheline: 10 bytes */
} __attribute__((__packed__));
struct AcpiMadtLocalNmi {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    length;               /*     1     1 */
	uint8_t                    processor_id;         /*     2     1 */
	uint16_t                   flags;                /*     3     2 */
	uint8_t                    lint;                 /*     5     1 */

	/* size: 6, cachelines: 1, members: 5 */
	/* last cacheline: 6 bytes */
} __attribute__((__packed__));
struct AcpiMadtProcessorX2Apic {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    length;               /*     1     1 */
	uint16_t                   reserved;             /*     2     2 */
	uint32_t                   x2apic_id;            /*     4     4 */
	uint32_t                   flags;                /*     8     4 */
	uint32_t                   uid;                  /*    12     4 */

	/* size: 16, cachelines: 1, members: 6 */
	/* last cacheline: 16 bytes */
};
struct AcpiMadtLocalX2ApicNmi {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    length;               /*     1     1 */
	uint16_t                   flags;                /*     2     2 */
	uint32_t                   uid;                  /*     4     4 */
	uint8_t                    lint;                 /*     8     1 */
	uint8_t                    reserved[3];          /*     9     3 */

	/* size: 12, cachelines: 1, members: 6 */
	/* last cacheline: 12 bytes */
};
struct Acpi20Hpet {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   length;               /*     4     4 */
	uint8_t                    revision;             /*     8     1 */
	uint8_t                    checksum;             /*     9     1 */
	uint8_t                    oem_id[6];            /*    10     6 */
	uint8_t                    oem_table_id[8];      /*    16     8 */
	uint32_t                   oem_revision;         /*    24     4 */
	uint8_t                    asl_compiler_id[4];   /*    28     4 */
	uint32_t                   asl_compiler_revision; /*    32     4 */
	uint32_t                   timer_block_id;       /*    36     4 */
	Acpi20GenericAddress       addr;                 /*    40    12 */
	uint8_t                    hpet_number;          /*    52     1 */
	uint16_t                   min_tick;             /*    53     2 */
	uint8_t                    page_protect;         /*    55     1 */

	/* size: 56, cachelines: 1, members: 14 */
	/* last cacheline: 56 bytes */
} __attribute__((__packed__));
struct AcpiSystemResourceAffinityTable {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   length;               /*     4     4 */
	uint8_t                    revision;             /*     8     1 */
	uint8_t                    checksum;             /*     9     1 */
	uint8_t                    oem_id[6];            /*    10     6 */
	uint8_t                    oem_table_id[8];      /*    16     8 */
	uint32_t                   oem_revision;         /*    24     4 */
	uint8_t                    asl_compiler_id[4];   /*    28     4 */
	uint32_t                   asl_compiler_revision; /*    32     4 */
	uint32_t                   reserved1;            /*    36     4 */
	uint32_t                   reserved2[2];         /*    40     8 */

	/* size: 48, cachelines: 1, members: 11 */
	/* last cacheline: 48 bytes */
};
struct AcpiSratProcessorAffinity {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    length;               /*     1     1 */
	uint8_t                    proximity_lo;         /*     2     1 */
	uint8_t                    local_apic_id;        /*     3     1 */
	uint32_t                   flags;                /*     4     4 */
	uint8_t                    local_sapic_eid;      /*     8     1 */
	uint8_t                    proximity_hi[3];      /*     9     3 */
	uint32_t                   reserved;             /*    12     4 */

	/* size: 16, cachelines: 1, members: 8 */
	/* last cacheline: 16 bytes */
};
struct AcpiSratProcessorX2ApicAffinity {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    length;               /*     1     1 */
	uint16_t                   reserved;             /*     2     2 */
	uint32_t                   proximity_domain;     /*     4     4 */
	uint32_t                   x2apic_id;            /*     8     4 */
	uint32_t                   flags;                /*    12     4 */
	uint32_t                   clk_domain;           /*    16     4 */
	uint32_t                   reserved2;            /*    20     4 */

	/* size: 24, cachelines: 1, members: 8 */
	/* last cacheline: 24 bytes */
};
struct AcpiSratMemoryAffinity {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    length;               /*     1     1 */
	uint32_t                   proximity;            /*     2     4 */
	uint16_t                   reserved1;            /*     6     2 */
	uint64_t                   base_addr;            /*     8     8 */
	uint64_t                   range_length;         /*    16     8 */
	uint32_t                   reserved2;            /*    24     4 */
	uint32_t                   flags;                /*    28     4 */
	uint32_t                   reserved3[2];         /*    32     8 */

	/* size: 40, cachelines: 1, members: 9 */
	/* last cacheline: 40 bytes */
} __attribute__((__packed__));
struct AcpiMcfgAllocation {
	uint64_t                   address;              /*     0     8 */
	uint16_t                   pci_segment;          /*     8     2 */
	uint8_t                    start_bus_number;     /*    10     1 */
	uint8_t                    end_bus_number;       /*    11     1 */
	uint32_t                   reserved;             /*    12     4 */

	/* size: 16, cachelines: 1, members: 5 */
	/* last cacheline: 16 bytes */
};
struct AcpiTableMcfg {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   length;               /*     4     4 */
	uint8_t                    revision;             /*     8     1 */
	uint8_t                    checksum;             /*     9     1 */
	uint8_t                    oem_id[6];            /*    10     6 */
	uint8_t                    oem_table_id[8];      /*    16     8 */
	uint32_t                   oem_revision;         /*    24     4 */
	uint8_t                    asl_compiler_id[4];   /*    28     4 */
	uint32_t                   asl_compiler_revision; /*    32     4 */
	uint8_t                    reserved[8];          /*    36     8 */
	AcpiMcfgAllocation         allocation[];         /*    44     0 */

	/* size: 44, cachelines: 1, members: 11 */
	/* last cacheline: 44 bytes */
} __attribute__((__packed__));
struct Acpi20Tcpa {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   length;               /*     4     4 */
	uint8_t                    revision;             /*     8     1 */
	uint8_t                    checksum;             /*     9     1 */
	uint8_t                    oem_id[6];            /*    10     6 */
	uint8_t                    oem_table_id[8];      /*    16     8 */
	uint32_t                   oem_revision;         /*    24     4 */
	uint8_t                    asl_compiler_id[4];   /*    28     4 */
	uint32_t                   asl_compiler_revision; /*    32     4 */
	uint16_t                   platform_class;       /*    36     2 */
	uint32_t                   log_area_minimum_length; /*    38     4 */
	uint64_t                   log_area_start_address; /*    42     8 */

	/* size: 50, cachelines: 1, members: 12 */
	/* last cacheline: 50 bytes */
} __attribute__((__packed__));
struct Acpi20TPM2 {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   length;               /*     4     4 */
	uint8_t                    revision;             /*     8     1 */
	uint8_t                    checksum;             /*     9     1 */
	uint8_t                    oem_id[6];            /*    10     6 */
	uint8_t                    oem_table_id[8];      /*    16     8 */
	uint32_t                   oem_revision;         /*    24     4 */
	uint8_t                    asl_compiler_id[4];   /*    28     4 */
	uint32_t                   asl_compiler_revision; /*    32     4 */
	uint16_t                   platform_class;       /*    36     2 */
	uint16_t                   reserved;             /*    38     2 */
	uint64_t                   control_area_address; /*    40     8 */
	uint32_t                   start_method;         /*    48     4 */

	/* size: 52, cachelines: 1, members: 13 */
	/* last cacheline: 52 bytes */
} __attribute__((__packed__));
struct AcpiTableDmar {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   length;               /*     4     4 */
	uint8_t                    revision;             /*     8     1 */
	uint8_t                    checksum;             /*     9     1 */
	uint8_t                    oem_id[6];            /*    10     6 */
	uint8_t                    oem_table_id[8];      /*    16     8 */
	uint32_t                   oem_revision;         /*    24     4 */
	uint8_t                    asl_compiler_id[4];   /*    28     4 */
	uint32_t                   asl_compiler_revision; /*    32     4 */
	uint8_t                    host_address_width;   /*    36     1 */
	uint8_t                    flags;                /*    37     1 */
	uint8_t                    reserved[10];         /*    38    10 */

	/* size: 48, cachelines: 1, members: 12 */
	/* last cacheline: 48 bytes */
};
struct AcpiDmarDeviceScope {
	uint8_t                    entry_type;           /*     0     1 */
	uint8_t                    length;               /*     1     1 */
	uint16_t                   reserved;             /*     2     2 */
	uint8_t                    enumeration_id;       /*     4     1 */
	uint8_t                    bus;                  /*     5     1 */
	struct {
		uint8_t            device;               /*     6     1 */
		uint8_t            function;             /*     7     1 */
	} path[]; /*     6     0 */

	/* size: 6, cachelines: 1, members: 6 */
	/* last cacheline: 6 bytes */
};
struct AcpiDmarHardwareUnit {
	uint16_t                   type;                 /*     0     2 */
	uint16_t                   length;               /*     2     2 */
	uint8_t                    flags;                /*     4     1 */
	uint8_t                    reserved;             /*     5     1 */
	uint16_t                   pci_segment;          /*     6     2 */
	uint64_t                   address;              /*     8     8 */
	AcpiDmarDeviceScope        scope[];              /*    16     0 */

	/* size: 16, cachelines: 1, members: 7 */
	/* last cacheline: 16 bytes */
};
struct AcpiSlicOem {
	char *                     id;                   /*     0     8 */
	char *                     table_id;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct Aml {
	GArray *                   buf;                  /*     0     8 */
	uint8_t                    op;                   /*     8     1 */

	/* XXX 3 bytes hole, try to pack */

	AmlBlockFlags              block_flags;          /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* sum members: 13, holes: 1, sum holes: 3 */
	/* last cacheline: 16 bytes */
};
struct AcpiBuildTables {
	GArray *                   table_data;           /*     0     8 */
	GArray *                   rsdp;                 /*     8     8 */
	GArray *                   tcpalog;              /*    16     8 */
	BIOSLinker *               linker;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct CPUHotplugFeatures {
	_Bool                      apci_1_compatible;    /*     0     1 */
	_Bool                      has_legacy_cphp;      /*     1     1 */

	/* size: 2, cachelines: 1, members: 2 */
	/* last cacheline: 2 bytes */
};
struct PCIBridgeWindows {
	MemoryRegion               alias_pref_mem;       /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	MemoryRegion               alias_mem;            /*   256   256 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	MemoryRegion               alias_io;             /*   512   256 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	MemoryRegion               alias_vga[3];         /*   768   768 */

	/* size: 1536, cachelines: 24, members: 4 */
};
struct AcpiMcfgInfo {
	uint64_t                   mcfg_base;            /*     0     8 */
	uint32_t                   mcfg_size;            /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct AcpiPmInfo {
	_Bool                      s3_disabled;          /*     0     1 */
	_Bool                      s4_disabled;          /*     1     1 */
	_Bool                      pcihp_bridge_en;      /*     2     1 */
	uint8_t                    s4_val;               /*     3     1 */
	uint16_t                   sci_int;              /*     4     2 */
	uint8_t                    acpi_enable_cmd;      /*     6     1 */
	uint8_t                    acpi_disable_cmd;     /*     7     1 */
	uint32_t                   gpe0_blk;             /*     8     4 */
	uint32_t                   gpe0_blk_len;         /*    12     4 */
	uint32_t                   io_base;              /*    16     4 */
	uint16_t                   cpu_hp_io_base;       /*    20     2 */
	uint16_t                   mem_hp_io_base;       /*    22     2 */
	uint16_t                   mem_hp_io_len;        /*    24     2 */
	uint16_t                   pcihp_io_base;        /*    26     2 */
	uint16_t                   pcihp_io_len;         /*    28     2 */

	/* size: 32, cachelines: 1, members: 15 */
	/* padding: 2 */
	/* last cacheline: 32 bytes */
};
struct AcpiMiscInfo {
	_Bool                      is_piix4;             /*     0     1 */
	_Bool                      has_hpet;             /*     1     1 */

	/* XXX 2 bytes hole, try to pack */

	TPMVersion                 tpm_version;          /*     4     4 */
	const unsigned char  *     dsdt_code;            /*     8     8 */
	unsigned int               dsdt_size;            /*    16     4 */
	uint16_t                   pvpanic_port;         /*    20     2 */
	uint16_t                   applesmc_io_base;     /*    22     2 */

	/* size: 24, cachelines: 1, members: 7 */
	/* sum members: 22, holes: 1, sum holes: 2 */
	/* last cacheline: 24 bytes */
};
struct CrsRangeEntry {
	uint64_t                   base;                 /*     0     8 */
	uint64_t                   limit;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct CrsRangeSet {
	GPtrArray *                io_ranges;            /*     0     8 */
	GPtrArray *                mem_ranges;           /*     8     8 */
	GPtrArray *                mem_64bit_ranges;     /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct AcpiBuildState {
	MemoryRegion *             table_mr;             /*     0     8 */
	uint8_t                    patched;              /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	void *                     rsdp;                 /*    16     8 */
	MemoryRegion *             rsdp_mr;              /*    24     8 */
	MemoryRegion *             linker_mr;            /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 33, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
struct kvm_clock_data {
	__u64                      clock;                /*     0     8 */
	__u32                      flags;                /*     8     4 */
	__u32                      pad[9];               /*    12    36 */

	/* size: 48, cachelines: 1, members: 3 */
	/* last cacheline: 48 bytes */
};
struct KVMClockState {
	SysBusDevice               busdev;               /*     0   768 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	uint64_t                   clock;                /*   768     8 */
	_Bool                      clock_valid;          /*   776     1 */

	/* size: 784, cachelines: 13, members: 3 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct pvclock_vcpu_time_info {
	uint32_t                   version;              /*     0     4 */
	uint32_t                   pad0;                 /*     4     4 */
	uint64_t                   tsc_timestamp;        /*     8     8 */
	uint64_t                   system_time;          /*    16     8 */
	uint32_t                   tsc_to_system_mul;    /*    24     4 */
	int8_t                     tsc_shift;            /*    28     1 */
	uint8_t                    flags;                /*    29     1 */
	uint8_t                    pad[2];               /*    30     2 */

	/* size: 32, cachelines: 1, members: 8 */
	/* last cacheline: 32 bytes */
};
struct kvm_lapic_state {
	char                       regs[1024];           /*     0  1024 */

	/* size: 1024, cachelines: 16, members: 1 */
};
struct kvm_tpr_access_ctl {
	__u32                      enabled;              /*     0     4 */
	__u32                      flags;                /*     4     4 */
	__u32                      reserved[8];          /*     8    32 */

	/* size: 40, cachelines: 1, members: 3 */
	/* last cacheline: 40 bytes */
};
struct kvm_vapic_addr {
	__u64                      vapic_addr;           /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct ISADeviceClass {
	DeviceClass                parent_class;         /*     0   192 */

	/* size: 192, cachelines: 3, members: 1 */
};
struct PICCommonState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint8_t                    last_irr;             /*   128     1 */
	uint8_t                    irr;                  /*   129     1 */
	uint8_t                    imr;                  /*   130     1 */
	uint8_t                    isr;                  /*   131     1 */
	uint8_t                    priority_add;         /*   132     1 */
	uint8_t                    irq_base;             /*   133     1 */
	uint8_t                    read_reg_select;      /*   134     1 */
	uint8_t                    poll;                 /*   135     1 */
	uint8_t                    special_mask;         /*   136     1 */
	uint8_t                    init_state;           /*   137     1 */
	uint8_t                    auto_eoi;             /*   138     1 */
	uint8_t                    rotate_on_auto_eoi;   /*   139     1 */
	uint8_t                    special_fully_nested_mode; /*   140     1 */
	uint8_t                    init4;                /*   141     1 */
	uint8_t                    single_mode;          /*   142     1 */
	uint8_t                    elcr;                 /*   143     1 */
	uint8_t                    elcr_mask;            /*   144     1 */

	/* XXX 7 bytes hole, try to pack */

	qemu_irq                   int_out[1];           /*   152     8 */
	uint32_t                   master;               /*   160     4 */
	uint32_t                   iobase;               /*   164     4 */
	uint32_t                   elcr_addr;            /*   168     4 */

	/* XXX 4 bytes hole, try to pack */

	MemoryRegion               base_io;              /*   176   256 */
	/* --- cacheline 6 boundary (384 bytes) was 48 bytes ago --- */
	MemoryRegion               elcr_io;              /*   432   256 */

	/* size: 688, cachelines: 11, members: 24 */
	/* sum members: 677, holes: 2, sum holes: 11 */
	/* last cacheline: 48 bytes */
};
struct PICCommonClass {
	ISADeviceClass             parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	void                       (*pre_save)(PICCommonState *); /*   192     8 */
	void                       (*post_load)(PICCommonState *); /*   200     8 */

	/* size: 208, cachelines: 4, members: 3 */
	/* last cacheline: 16 bytes */
};
struct kvm_pic_state {
	__u8                       last_irr;             /*     0     1 */
	__u8                       irr;                  /*     1     1 */
	__u8                       imr;                  /*     2     1 */
	__u8                       isr;                  /*     3     1 */
	__u8                       priority_add;         /*     4     1 */
	__u8                       irq_base;             /*     5     1 */
	__u8                       read_reg_select;      /*     6     1 */
	__u8                       poll;                 /*     7     1 */
	__u8                       special_mask;         /*     8     1 */
	__u8                       init_state;           /*     9     1 */
	__u8                       auto_eoi;             /*    10     1 */
	__u8                       rotate_on_auto_eoi;   /*    11     1 */
	__u8                       special_fully_nested_mode; /*    12     1 */
	__u8                       init4;                /*    13     1 */
	__u8                       elcr;                 /*    14     1 */
	__u8                       elcr_mask;            /*    15     1 */

	/* size: 16, cachelines: 1, members: 16 */
	/* last cacheline: 16 bytes */
};
struct kvm_ioapic_state {
	__u64                      base_address;         /*     0     8 */
	__u32                      ioregsel;             /*     8     4 */
	__u32                      id;                   /*    12     4 */
	__u32                      irr;                  /*    16     4 */
	__u32                      pad;                  /*    20     4 */
	union {
		__u64              bits;                 /*    24     8 */
		struct {
			__u8       vector;               /*    24     1 */
			__u8       delivery_mode:3;      /*    25: 0  1 */
			__u8       dest_mode:1;          /*    25: 3  1 */
			__u8       delivery_status:1;    /*    25: 4  1 */
			__u8       polarity:1;           /*    25: 5  1 */
			__u8       remote_irr:1;         /*    25: 6  1 */
			__u8       trig_mode:1;          /*    25: 7  1 */
			__u8       mask:1;               /*    26: 0  1 */
			__u8       reserve:7;            /*    26: 1  1 */
			__u8       reserved[4];          /*    27     4 */
			__u8       dest_id;              /*    31     1 */
		} fields;                                /*    24     8 */
	} redirtbl[24]; /*    24   192 */

	/* size: 216, cachelines: 4, members: 6 */
	/* last cacheline: 24 bytes */
};
struct kvm_irqchip {
	__u32                      chip_id;              /*     0     4 */
	__u32                      pad;                  /*     4     4 */
	union {
		char               dummy[512];           /*     8   512 */
		struct kvm_pic_state pic;                /*     8    16 */
		struct kvm_ioapic_state ioapic;          /*     8   216 */
	} chip;                                          /*     8   512 */

	/* size: 520, cachelines: 9, members: 3 */
	/* last cacheline: 8 bytes */
};
struct KVMPICClass {
	PICCommonClass             parent_class;         /*     0   208 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	DeviceRealize              parent_realize;       /*   208     8 */

	/* size: 216, cachelines: 4, members: 2 */
	/* last cacheline: 24 bytes */
};
struct KVMIOAPICState {
	IOAPICCommonState          ioapic;               /*     0  1264 */
	/* --- cacheline 19 boundary (1216 bytes) was 48 bytes ago --- */
	uint32_t                   kvm_gsi_base;         /*  1264     4 */

	/* Force padding: */
	uint32_t                   :32;
	uint32_t                   :32;
	uint32_t                   :32;

	/* size: 1280, cachelines: 20, members: 2 */
	/* padding: 12 */
};
struct kvm_pit_channel_state {
	__u32                      count;                /*     0     4 */
	__u16                      latched_count;        /*     4     2 */
	__u8                       count_latched;        /*     6     1 */
	__u8                       status_latched;       /*     7     1 */
	__u8                       status;               /*     8     1 */
	__u8                       read_state;           /*     9     1 */
	__u8                       write_state;          /*    10     1 */
	__u8                       write_latch;          /*    11     1 */
	__u8                       rw_mode;              /*    12     1 */
	__u8                       mode;                 /*    13     1 */
	__u8                       bcd;                  /*    14     1 */
	__u8                       gate;                 /*    15     1 */
	__s64                      count_load_time;      /*    16     8 */

	/* size: 24, cachelines: 1, members: 13 */
	/* last cacheline: 24 bytes */
};
struct kvm_pit_state2 {
	struct kvm_pit_channel_state channels[3];        /*     0    72 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	__u32                      flags;                /*    72     4 */
	__u32                      reserved[9];          /*    76    36 */

	/* size: 112, cachelines: 2, members: 3 */
	/* last cacheline: 48 bytes */
};
struct kvm_reinject_control {
	__u8                       pit_reinject;         /*     0     1 */
	__u8                       reserved[31];         /*     1    31 */

	/* size: 32, cachelines: 1, members: 2 */
	/* last cacheline: 32 bytes */
};
struct kvm_pit_config {
	__u32                      flags;                /*     0     4 */
	__u32                      pad[15];              /*     4    60 */

	/* size: 64, cachelines: 1, members: 2 */
};
struct PITChannelInfo {
	int                        gate;                 /*     0     4 */
	int                        mode;                 /*     4     4 */
	int                        initial_count;        /*     8     4 */
	int                        out;                  /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct PITChannelState {
	int                        count;                /*     0     4 */
	uint16_t                   latched_count;        /*     4     2 */
	uint8_t                    count_latched;        /*     6     1 */
	uint8_t                    status_latched;       /*     7     1 */
	uint8_t                    status;               /*     8     1 */
	uint8_t                    read_state;           /*     9     1 */
	uint8_t                    write_state;          /*    10     1 */
	uint8_t                    write_latch;          /*    11     1 */
	uint8_t                    rw_mode;              /*    12     1 */
	uint8_t                    mode;                 /*    13     1 */
	uint8_t                    bcd;                  /*    14     1 */
	uint8_t                    gate;                 /*    15     1 */
	int64_t                    count_load_time;      /*    16     8 */
	int64_t                    next_transition_time; /*    24     8 */
	QEMUTimer *                irq_timer;            /*    32     8 */
	qemu_irq                   irq;                  /*    40     8 */
	uint32_t                   irq_disabled;         /*    48     4 */

	/* size: 56, cachelines: 1, members: 17 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct PITCommonState {
	ISADevice                  dev;                  /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	MemoryRegion               ioports;              /*   128   256 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	uint32_t                   iobase;               /*   384     4 */

	/* XXX 4 bytes hole, try to pack */

	PITChannelState            channels[3];          /*   392   168 */

	/* size: 560, cachelines: 9, members: 4 */
	/* sum members: 556, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct PITCommonClass {
	ISADeviceClass             parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	void                       (*set_channel_gate)(PITCommonState *, PITChannelState *, int); /*   192     8 */
	void                       (*get_channel_info)(PITCommonState *, PITChannelState *, PITChannelInfo *); /*   200     8 */
	void                       (*pre_save)(PITCommonState *); /*   208     8 */
	void                       (*post_load)(PITCommonState *); /*   216     8 */

	/* size: 224, cachelines: 4, members: 5 */
	/* last cacheline: 32 bytes */
};
struct KVMPITState {
	PITCommonState             parent_obj;           /*     0   560 */
	/* --- cacheline 8 boundary (512 bytes) was 48 bytes ago --- */
	LostTickPolicy             lost_tick_policy;     /*   560     4 */
	_Bool                      vm_stopped;           /*   564     1 */

	/* XXX 3 bytes hole, try to pack */

	int64_t                    kernel_clock_offset;  /*   568     8 */

	/* size: 576, cachelines: 9, members: 4 */
	/* sum members: 573, holes: 1, sum holes: 3 */
};
struct KVMPITClass {
	PITCommonClass             parent_class;         /*     0   224 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	DeviceRealize              parent_realize;       /*   224     8 */

	/* size: 232, cachelines: 4, members: 2 */
	/* last cacheline: 40 bytes */
};
struct PCIRegion {
	int                        type;                 /*     0     4 */
	int                        valid;                /*     4     4 */
	uint64_t                   base_addr;            /*     8     8 */
	uint64_t                   size;                 /*    16     8 */
	int                        resource_fd;          /*    24     4 */

	/* size: 32, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct PCIDevRegions {
	uint8_t                    bus;                  /*     0     1 */
	uint8_t                    dev;                  /*     1     1 */
	uint8_t                    func;                 /*     2     1 */

	/* XXX 1 byte hole, try to pack */

	int                        irq;                  /*     4     4 */
	uint16_t                   region_number;        /*     8     2 */

	/* XXX 6 bytes hole, try to pack */

	PCIRegion                  regions[6];           /*    16   192 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	int                        config_fd;            /*   208     4 */

	/* size: 216, cachelines: 4, members: 7 */
	/* sum members: 205, holes: 2, sum holes: 7 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct AssignedDevRegion {
	MemoryRegion               container;            /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	MemoryRegion               real_iomem;           /*   256   256 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	union {
		uint8_t *          r_virtbase;           /*   512     8 */
		uint32_t           r_baseport;           /*   512     4 */
	} u;                                             /*   512     8 */
	pcibus_t                   e_size;               /*   520     8 */
	pcibus_t                   r_size;               /*   528     8 */
	PCIRegion *                region;               /*   536     8 */

	/* size: 544, cachelines: 9, members: 6 */
	/* last cacheline: 32 bytes */
};
struct MSIXTableEntry {
	uint32_t                   addr_lo;              /*     0     4 */
	uint32_t                   addr_hi;              /*     4     4 */
	uint32_t                   data;                 /*     8     4 */
	uint32_t                   ctrl;                 /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct AssignedDevice {
	PCIDevice                  dev;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	PCIHostDeviceAddress       host;                 /*  2288    16 */
	/* --- cacheline 36 boundary (2304 bytes) --- */
	uint32_t                   dev_id;               /*  2304     4 */
	uint32_t                   features;             /*  2308     4 */
	int                        intpin;               /*  2312     4 */

	/* XXX 4 bytes hole, try to pack */

	AssignedDevRegion          v_addrs[6];           /*  2320  3264 */
	/* --- cacheline 87 boundary (5568 bytes) was 16 bytes ago --- */
	PCIDevRegions              real_device;          /*  5584   216 */
	/* --- cacheline 90 boundary (5760 bytes) was 40 bytes ago --- */
	PCIINTxRoute               intx_route;           /*  5800     8 */
	AssignedIRQType            assigned_irq_type;    /*  5808     4 */
	struct {
		uint32_t           available;            /*  5812     4 */
		uint32_t           state;                /*  5816     4 */
	} cap;                                           /*  5812     8 */
	uint8_t                    emulate_config_read[256]; /*  5820   256 */
	/* --- cacheline 94 boundary (6016 bytes) was 60 bytes ago --- */
	uint8_t                    emulate_config_write[256]; /*  6076   256 */
	/* --- cacheline 98 boundary (6272 bytes) was 60 bytes ago --- */
	int                        msi_virq_nr;          /*  6332     4 */
	/* --- cacheline 99 boundary (6336 bytes) --- */
	int *                      msi_virq;             /*  6336     8 */
	MSIXTableEntry *           msix_table;           /*  6344     8 */
	hwaddr                     msix_table_addr;      /*  6352     8 */
	uint16_t                   msix_table_size;      /*  6360     2 */
	uint16_t                   msix_max;             /*  6362     2 */

	/* XXX 4 bytes hole, try to pack */

	MemoryRegion               mmio;                 /*  6368   256 */
	/* --- cacheline 103 boundary (6592 bytes) was 32 bytes ago --- */
	char *                     configfd_name;        /*  6624     8 */
	int32_t                    bootindex;            /*  6632     4 */

	/* size: 6640, cachelines: 104, members: 21 */
	/* sum members: 6628, holes: 2, sum holes: 8 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct DisasContext {
	int                        override;             /*     0     4 */
	int                        prefix;               /*     4     4 */
	TCGMemOp                   aflag;                /*     8     4 */
	TCGMemOp                   dflag;                /*    12     4 */
	target_ulong               pc_start;             /*    16     8 */
	target_ulong               pc;                   /*    24     8 */
	int                        is_jmp;               /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	target_ulong               cs_base;              /*    40     8 */
	int                        pe;                   /*    48     4 */
	int                        code32;               /*    52     4 */
	int                        lma;                  /*    56     4 */
	int                        code64;               /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        rex_x;                /*    64     4 */
	int                        rex_b;                /*    68     4 */
	int                        vex_l;                /*    72     4 */
	int                        vex_v;                /*    76     4 */
	int                        ss32;                 /*    80     4 */
	CCOp                       cc_op;                /*    84     4 */
	_Bool                      cc_op_dirty;          /*    88     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        addseg;               /*    92     4 */
	int                        f_st;                 /*    96     4 */
	int                        vm86;                 /*   100     4 */
	int                        cpl;                  /*   104     4 */
	int                        iopl;                 /*   108     4 */
	int                        tf;                   /*   112     4 */
	int                        singlestep_enabled;   /*   116     4 */
	int                        jmp_opt;              /*   120     4 */
	int                        repz_opt;             /*   124     4 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int                        mem_index;            /*   128     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   flags;                /*   136     8 */
	struct TranslationBlock *  tb;                   /*   144     8 */
	int                        popl_esp_hack;        /*   152     4 */
	int                        rip_offset;           /*   156     4 */
	int                        cpuid_features;       /*   160     4 */
	int                        cpuid_ext_features;   /*   164     4 */
	int                        cpuid_ext2_features;  /*   168     4 */
	int                        cpuid_ext3_features;  /*   172     4 */
	int                        cpuid_7_0_ebx_features; /*   176     4 */
	int                        cpuid_xsave_features; /*   180     4 */

	/* size: 184, cachelines: 3, members: 39 */
	/* sum members: 173, holes: 3, sum holes: 11 */
	/* last cacheline: 56 bytes */
};
struct CCPrepare {
	TCGCond                    cond;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	TCGv_i64                   reg;                  /*     8     8 */
	TCGv_i64                   reg2;                 /*    16     8 */
	target_ulong               imm;                  /*    24     8 */
	target_ulong               mask;                 /*    32     8 */
	_Bool                      use_reg2;             /*    40     1 */
	_Bool                      no_setcond;           /*    41     1 */

	/* size: 48, cachelines: 1, members: 7 */
	/* sum members: 38, holes: 1, sum holes: 4 */
	/* padding: 6 */
	/* last cacheline: 48 bytes */
};
struct AddressParts {
	int                        def_seg;              /*     0     4 */
	int                        base;                 /*     4     4 */
	int                        index;                /*     8     4 */
	int                        scale;                /*    12     4 */
	target_long                disp;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 5 */
	/* last cacheline: 24 bytes */
};
struct SSEOpHelper_epp {
	SSEFunc_0_epp              op[2];                /*     0    16 */
	uint32_t                   ext_mask;             /*    16     4 */

	/* size: 24, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct SSEOpHelper_eppi {
	SSEFunc_0_eppi             op[2];                /*     0    16 */
	uint32_t                   ext_mask;             /*    16     4 */

	/* size: 24, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct MCEInjectionParams {
	Monitor *                  mon;                  /*     0     8 */
	int                        bank;                 /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   status;               /*    16     8 */
	uint64_t                   mcg_status;           /*    24     8 */
	uint64_t                   addr;                 /*    32     8 */
	uint64_t                   misc;                 /*    40     8 */
	int                        flags;                /*    48     4 */

	/* size: 56, cachelines: 1, members: 7 */
	/* sum members: 48, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct CpuDefinitionInfo {
	char *                     name;                 /*     0     8 */
	_Bool                      has_migration_safe;   /*     8     1 */
	_Bool                      migration_safe;       /*     9     1 */
	_Bool                      q_static;             /*    10     1 */
	_Bool                      has_unavailable_features; /*    11     1 */

	/* XXX 4 bytes hole, try to pack */

	strList *                  unavailable_features; /*    16     8 */

	/* size: 24, cachelines: 1, members: 6 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct CpuDefinitionInfoList {
	CpuDefinitionInfoList *    next;                 /*     0     8 */
	CpuDefinitionInfo *        value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct X86CPUFeatureWordInfo {
	int64_t                    cpuid_input_eax;      /*     0     8 */
	_Bool                      has_cpuid_input_ecx;  /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    cpuid_input_ecx;      /*    16     8 */
	X86CPURegister32           cpuid_register;       /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    features;             /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 29, holes: 2, sum holes: 11 */
	/* last cacheline: 40 bytes */
};
struct X86CPUFeatureWordInfoList {
	X86CPUFeatureWordInfoList * next;                /*     0     8 */
	X86CPUFeatureWordInfo *    value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct X86CPUDefinition {
	const char  *              name;                 /*     0     8 */
	uint32_t                   level;                /*     8     4 */
	uint32_t                   xlevel;               /*    12     4 */
	char                       vendor[13];           /*    16    13 */

	/* XXX 3 bytes hole, try to pack */

	int                        family;               /*    32     4 */
	int                        model;                /*    36     4 */
	int                        stepping;             /*    40     4 */
	FeatureWordArray           features;             /*    44    72 */
	/* --- cacheline 1 boundary (64 bytes) was 52 bytes ago --- */
	char                       model_id[48];         /*   116    48 */

	/* size: 168, cachelines: 3, members: 9 */
	/* sum members: 161, holes: 1, sum holes: 3 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct X86CPUClass {
	CPUClass                   parent_class;         /*     0   496 */
	/* --- cacheline 7 boundary (448 bytes) was 48 bytes ago --- */
	X86CPUDefinition *         cpu_def;              /*   496     8 */
	_Bool                      kvm_required;         /*   504     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 8 boundary (512 bytes) --- */
	const char  *              model_description;    /*   512     8 */
	DeviceRealize              parent_realize;       /*   520     8 */
	DeviceUnrealize            parent_unrealize;     /*   528     8 */
	void                       (*parent_reset)(CPUState *); /*   536     8 */

	/* size: 544, cachelines: 9, members: 7 */
	/* sum members: 537, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct CPUListState {
	fprintf_function           cpu_fprintf;          /*     0     8 */
	FILE *                     file;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct FeatureWordInfo {
	const char  *              feat_names[32];       /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint32_t                   cpuid_eax;            /*   256     4 */
	_Bool                      cpuid_needs_ecx;      /*   260     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   cpuid_ecx;            /*   264     4 */
	int                        cpuid_reg;            /*   268     4 */
	uint32_t                   tcg_features;         /*   272     4 */
	uint32_t                   unmigratable_flags;   /*   276     4 */
	uint32_t                   migratable_flags;     /*   280     4 */

	/* size: 288, cachelines: 5, members: 8 */
	/* sum members: 281, holes: 1, sum holes: 3 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct X86RegisterInfo32 {
	const char  *              name;                 /*     0     8 */
	X86CPURegister32           qapi_enum;            /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct ExtSaveArea {
	uint32_t                   feature;              /*     0     4 */
	uint32_t                   bits;                 /*     4     4 */
	uint32_t                   offset;               /*     8     4 */
	uint32_t                   size;                 /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct PropValue {
	const char  *              prop;                 /*     0     8 */
	const char  *              value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BitProperty {
	uint32_t *                 ptr;                  /*     0     8 */
	uint32_t                   mask;                 /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
union x86_longdouble {
	uint64_t                   mant;               /*     0     8 */
	uint16_t                   exp;                /*     0     2 */
};
struct elf32_note {
	Elf32_Word                 n_namesz;             /*     0     4 */
	Elf32_Word                 n_descsz;             /*     4     4 */
	Elf32_Word                 n_type;               /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
struct elf64_note {
	Elf64_Word                 n_namesz;             /*     0     4 */
	Elf64_Word                 n_descsz;             /*     4     4 */
	Elf64_Word                 n_type;               /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
struct QEMUCPUSegment {
	uint32_t                   selector;             /*     0     4 */
	uint32_t                   limit;                /*     4     4 */
	uint32_t                   flags;                /*     8     4 */
	uint32_t                   pad;                  /*    12     4 */
	uint64_t                   base;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 5 */
	/* last cacheline: 24 bytes */
};
struct QEMUCPUState {
	uint32_t                   version;              /*     0     4 */
	uint32_t                   size;                 /*     4     4 */
	uint64_t                   rax;                  /*     8     8 */
	uint64_t                   rbx;                  /*    16     8 */
	uint64_t                   rcx;                  /*    24     8 */
	uint64_t                   rdx;                  /*    32     8 */
	uint64_t                   rsi;                  /*    40     8 */
	uint64_t                   rdi;                  /*    48     8 */
	uint64_t                   rsp;                  /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint64_t                   rbp;                  /*    64     8 */
	uint64_t                   r8;                   /*    72     8 */
	uint64_t                   r9;                   /*    80     8 */
	uint64_t                   r10;                  /*    88     8 */
	uint64_t                   r11;                  /*    96     8 */
	uint64_t                   r12;                  /*   104     8 */
	uint64_t                   r13;                  /*   112     8 */
	uint64_t                   r14;                  /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint64_t                   r15;                  /*   128     8 */
	uint64_t                   rip;                  /*   136     8 */
	uint64_t                   rflags;               /*   144     8 */
	QEMUCPUSegment             cs;                   /*   152    24 */
	QEMUCPUSegment             ds;                   /*   176    24 */
	/* --- cacheline 3 boundary (192 bytes) was 8 bytes ago --- */
	QEMUCPUSegment             es;                   /*   200    24 */
	QEMUCPUSegment             fs;                   /*   224    24 */
	QEMUCPUSegment             gs;                   /*   248    24 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	QEMUCPUSegment             ss;                   /*   272    24 */
	QEMUCPUSegment             ldt;                  /*   296    24 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	QEMUCPUSegment             tr;                   /*   320    24 */
	QEMUCPUSegment             gdt;                  /*   344    24 */
	QEMUCPUSegment             idt;                  /*   368    24 */
	/* --- cacheline 6 boundary (384 bytes) was 8 bytes ago --- */
	uint64_t                   cr[5];                /*   392    40 */

	/* size: 432, cachelines: 7, members: 31 */
	/* last cacheline: 48 bytes */
};
struct utsname {
	char                       sysname[65];          /*     0    65 */
	/* --- cacheline 1 boundary (64 bytes) was 1 bytes ago --- */
	char                       nodename[65];         /*    65    65 */
	/* --- cacheline 2 boundary (128 bytes) was 2 bytes ago --- */
	char                       release[65];          /*   130    65 */
	/* --- cacheline 3 boundary (192 bytes) was 3 bytes ago --- */
	char                       version[65];          /*   195    65 */
	/* --- cacheline 4 boundary (256 bytes) was 4 bytes ago --- */
	char                       machine[65];          /*   260    65 */
	/* --- cacheline 5 boundary (320 bytes) was 5 bytes ago --- */
	char                       domainname[65];       /*   325    65 */

	/* size: 390, cachelines: 7, members: 6 */
	/* last cacheline: 6 bytes */
};
struct kvm_regs {
	__u64                      rax;                  /*     0     8 */
	__u64                      rbx;                  /*     8     8 */
	__u64                      rcx;                  /*    16     8 */
	__u64                      rdx;                  /*    24     8 */
	__u64                      rsi;                  /*    32     8 */
	__u64                      rdi;                  /*    40     8 */
	__u64                      rsp;                  /*    48     8 */
	__u64                      rbp;                  /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	__u64                      r8;                   /*    64     8 */
	__u64                      r9;                   /*    72     8 */
	__u64                      r10;                  /*    80     8 */
	__u64                      r11;                  /*    88     8 */
	__u64                      r12;                  /*    96     8 */
	__u64                      r13;                  /*   104     8 */
	__u64                      r14;                  /*   112     8 */
	__u64                      r15;                  /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	__u64                      rip;                  /*   128     8 */
	__u64                      rflags;               /*   136     8 */

	/* size: 144, cachelines: 3, members: 18 */
	/* last cacheline: 16 bytes */
};
struct kvm_segment {
	__u64                      base;                 /*     0     8 */
	__u32                      limit;                /*     8     4 */
	__u16                      selector;             /*    12     2 */
	__u8                       type;                 /*    14     1 */
	__u8                       present;              /*    15     1 */
	__u8                       dpl;                  /*    16     1 */
	__u8                       db;                   /*    17     1 */
	__u8                       s;                    /*    18     1 */
	__u8                       l;                    /*    19     1 */
	__u8                       g;                    /*    20     1 */
	__u8                       avl;                  /*    21     1 */
	__u8                       unusable;             /*    22     1 */
	__u8                       padding;              /*    23     1 */

	/* size: 24, cachelines: 1, members: 13 */
	/* last cacheline: 24 bytes */
};
struct kvm_dtable {
	__u64                      base;                 /*     0     8 */
	__u16                      limit;                /*     8     2 */
	__u16                      padding[3];           /*    10     6 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct kvm_sregs {
	struct kvm_segment         cs;                   /*     0    24 */
	struct kvm_segment         ds;                   /*    24    24 */
	struct kvm_segment         es;                   /*    48    24 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	struct kvm_segment         fs;                   /*    72    24 */
	struct kvm_segment         gs;                   /*    96    24 */
	struct kvm_segment         ss;                   /*   120    24 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	struct kvm_segment         tr;                   /*   144    24 */
	struct kvm_segment         ldt;                  /*   168    24 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	struct kvm_dtable          gdt;                  /*   192    16 */
	struct kvm_dtable          idt;                  /*   208    16 */
	__u64                      cr0;                  /*   224     8 */
	__u64                      cr2;                  /*   232     8 */
	__u64                      cr3;                  /*   240     8 */
	__u64                      cr4;                  /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	__u64                      cr8;                  /*   256     8 */
	__u64                      efer;                 /*   264     8 */
	__u64                      apic_base;            /*   272     8 */
	__u64                      interrupt_bitmap[4];  /*   280    32 */

	/* size: 312, cachelines: 5, members: 18 */
	/* last cacheline: 56 bytes */
};
struct kvm_fpu {
	__u8                       fpr[8][16];           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	__u16                      fcw;                  /*   128     2 */
	__u16                      fsw;                  /*   130     2 */
	__u8                       ftwx;                 /*   132     1 */
	__u8                       pad1;                 /*   133     1 */
	__u16                      last_opcode;          /*   134     2 */
	__u64                      last_ip;              /*   136     8 */
	__u64                      last_dp;              /*   144     8 */
	__u8                       xmm[16][16];          /*   152   256 */
	/* --- cacheline 6 boundary (384 bytes) was 24 bytes ago --- */
	__u32                      mxcsr;                /*   408     4 */
	__u32                      pad2;                 /*   412     4 */

	/* size: 416, cachelines: 7, members: 11 */
	/* last cacheline: 32 bytes */
};
struct kvm_msr_list {
	__u32                      nmsrs;                /*     0     4 */
	__u32                      indices[];            /*     4     0 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
struct kvm_cpuid_entry2 {
	__u32                      function;             /*     0     4 */
	__u32                      index;                /*     4     4 */
	__u32                      flags;                /*     8     4 */
	__u32                      eax;                  /*    12     4 */
	__u32                      ebx;                  /*    16     4 */
	__u32                      ecx;                  /*    20     4 */
	__u32                      edx;                  /*    24     4 */
	__u32                      padding[3];           /*    28    12 */

	/* size: 40, cachelines: 1, members: 8 */
	/* last cacheline: 40 bytes */
};
struct kvm_cpuid2 {
	__u32                      nent;                 /*     0     4 */
	__u32                      padding;              /*     4     4 */
	struct kvm_cpuid_entry2    entries[];            /*     8     0 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct kvm_vcpu_events {
	struct {
		__u8               injected;             /*     0     1 */
		__u8               nr;                   /*     1     1 */
		__u8               has_error_code;       /*     2     1 */
		__u8               pad;                  /*     3     1 */
		__u32              error_code;           /*     4     4 */
	} exception;                                     /*     0     8 */
	struct {
		__u8               injected;             /*     8     1 */
		__u8               nr;                   /*     9     1 */
		__u8               soft;                 /*    10     1 */
		__u8               shadow;               /*    11     1 */
	} interrupt;                                     /*     8     4 */
	struct {
		__u8               injected;             /*    12     1 */
		__u8               pending;              /*    13     1 */
		__u8               masked;               /*    14     1 */
		__u8               pad;                  /*    15     1 */
	} nmi;                                           /*    12     4 */
	__u32                      sipi_vector;          /*    16     4 */
	__u32                      flags;                /*    20     4 */
	struct {
		__u8               smm;                  /*    24     1 */
		__u8               pending;              /*    25     1 */
		__u8               smm_inside_nmi;       /*    26     1 */
		__u8               latched_init;         /*    27     1 */
	} smi;                                           /*    24     4 */
	__u32                      reserved[9];          /*    28    36 */

	/* size: 64, cachelines: 1, members: 7 */
};
struct kvm_debugregs {
	__u64                      db[4];                /*     0    32 */
	__u64                      dr6;                  /*    32     8 */
	__u64                      dr7;                  /*    40     8 */
	__u64                      flags;                /*    48     8 */
	__u64                      reserved[9];          /*    56    72 */

	/* size: 128, cachelines: 2, members: 5 */
};
struct kvm_xsave {
	__u32                      region[1024];         /*     0  4096 */

	/* size: 4096, cachelines: 64, members: 1 */
};
struct kvm_xcr {
	__u32                      xcr;                  /*     0     4 */
	__u32                      reserved;             /*     4     4 */
	__u64                      value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct kvm_xcrs {
	__u32                      nr_xcrs;              /*     0     4 */
	__u32                      flags;                /*     4     4 */
	struct kvm_xcr             xcrs[16];             /*     8   256 */
	/* --- cacheline 4 boundary (256 bytes) was 8 bytes ago --- */
	__u64                      padding[16];          /*   264   128 */

	/* size: 392, cachelines: 7, members: 4 */
	/* last cacheline: 8 bytes */
};
struct kvm_interrupt {
	__u32                      irq;                  /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct kvm_mp_state {
	__u32                      mp_state;             /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct kvm_x86_mce {
	__u64                      status;               /*     0     8 */
	__u64                      addr;                 /*     8     8 */
	__u64                      misc;                 /*    16     8 */
	__u64                      mcg_status;           /*    24     8 */
	__u8                       bank;                 /*    32     1 */
	__u8                       pad1[7];              /*    33     7 */
	__u64                      pad2[3];              /*    40    24 */

	/* size: 64, cachelines: 1, members: 7 */
};
struct kvm_assigned_pci_dev {
	__u32                      assigned_dev_id;      /*     0     4 */
	__u32                      busnr;                /*     4     4 */
	__u32                      devfn;                /*     8     4 */
	__u32                      flags;                /*    12     4 */
	__u32                      segnr;                /*    16     4 */
	union {
		__u32              reserved[11];         /*    20    44 */
	};                                               /*    20    44 */

	/* size: 64, cachelines: 1, members: 6 */
};
struct kvm_assigned_irq {
	__u32                      assigned_dev_id;      /*     0     4 */
	__u32                      host_irq;             /*     4     4 */
	__u32                      guest_irq;            /*     8     4 */
	__u32                      flags;                /*    12     4 */
	union {
		__u32              reserved[12];         /*    16    48 */
	};                                               /*    16    48 */

	/* size: 64, cachelines: 1, members: 5 */
};
struct kvm_assigned_msix_nr {
	__u32                      assigned_dev_id;      /*     0     4 */
	__u16                      entry_nr;             /*     4     2 */
	__u16                      padding;              /*     6     2 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct kvm_assigned_msix_entry {
	__u32                      assigned_dev_id;      /*     0     4 */
	__u32                      gsi;                  /*     4     4 */
	__u16                      entry;                /*     8     2 */
	__u16                      padding[3];           /*    10     6 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
union X86LegacyXSaveArea {
	struct {
		uint16_t           fcw;                /*     0     2 */
		uint16_t           fsw;                /*     2     2 */
		uint8_t            ftw;                /*     4     1 */
		uint8_t            reserved;           /*     5     1 */
		uint16_t           fpop;               /*     6     2 */
		uint64_t           fpip;               /*     8     8 */
		uint64_t           fpdp;               /*    16     8 */
		uint32_t           mxcsr;              /*    24     4 */
		uint32_t           mxcsr_mask;         /*    28     4 */
		FPReg              fpregs[8];          /*    32   128 */
		/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
		uint8_t            xmm_regs[16][16];   /*   160   256 */
	};                                             /*     0   416 */
	uint8_t                    data[512];          /*     0   512 */
};
struct X86XSaveHeader {
	uint64_t                   xstate_bv;            /*     0     8 */
	uint64_t                   xcomp_bv;             /*     8     8 */
	uint64_t                   reserve0;             /*    16     8 */
	uint8_t                    reserved[40];         /*    24    40 */

	/* size: 64, cachelines: 1, members: 4 */
};
struct XSaveAVX {
	uint8_t                    ymmh[16][16];         /*     0   256 */

	/* size: 256, cachelines: 4, members: 1 */
};
struct XSaveBNDREG {
	BNDReg                     bnd_regs[4];          /*     0    64 */

	/* size: 64, cachelines: 1, members: 1 */
};
union XSaveBNDCSR {
	BNDCSReg                   bndcsr;             /*     0    16 */
	uint8_t                    data[64];           /*     0    64 */
};
struct XSaveOpmask {
	uint64_t                   opmask_regs[8];       /*     0    64 */

	/* size: 64, cachelines: 1, members: 1 */
};
struct XSaveZMM_Hi256 {
	uint8_t                    zmm_hi256[16][32];    /*     0   512 */

	/* size: 512, cachelines: 8, members: 1 */
};
struct XSaveHi16_ZMM {
	uint8_t                    hi16_zmm[16][64];     /*     0  1024 */

	/* size: 1024, cachelines: 16, members: 1 */
};
struct XSavePKRU {
	uint32_t                   pkru;                 /*     0     4 */
	uint32_t                   padding;              /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct X86XSaveArea {
	X86LegacyXSaveArea         legacy;               /*     0   512 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	X86XSaveHeader             header;               /*   512    64 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	XSaveAVX                   avx_state;            /*   576   256 */
	/* --- cacheline 13 boundary (832 bytes) --- */
	uint8_t                    padding[128];         /*   832   128 */
	/* --- cacheline 15 boundary (960 bytes) --- */
	XSaveBNDREG                bndreg_state;         /*   960    64 */
	/* --- cacheline 16 boundary (1024 bytes) --- */
	XSaveBNDCSR                bndcsr_state;         /*  1024    64 */
	/* --- cacheline 17 boundary (1088 bytes) --- */
	XSaveOpmask                opmask_state;         /*  1088    64 */
	/* --- cacheline 18 boundary (1152 bytes) --- */
	XSaveZMM_Hi256             zmm_hi256_state;      /*  1152   512 */
	/* --- cacheline 26 boundary (1664 bytes) --- */
	XSaveHi16_ZMM              hi16_zmm_state;       /*  1664  1024 */
	/* --- cacheline 42 boundary (2688 bytes) --- */
	XSavePKRU                  pkru_state;           /*  2688     8 */

	/* size: 2704, cachelines: 43, members: 10 */
	/* padding: 8 */
	/* last cacheline: 16 bytes */
};
struct kvm_para_features {
	int                        cap;                  /*     0     4 */
	int                        feature;              /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct HWPoisonPage {
	ram_addr_t                 ram_addr;             /*     0     8 */
	struct {
		struct HWPoisonPage * le_next;           /*     8     8 */
		struct HWPoisonPage * * le_prev;         /*    16     8 */
	} list;                                          /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
struct MSIRouteEntry {
	PCIDevice *                dev;                  /*     0     8 */
	int                        vector;               /*     8     4 */
	int                        virq;                 /*    12     4 */
	struct {
		struct MSIRouteEntry * le_next;          /*    16     8 */
		struct MSIRouteEntry * * le_prev;        /*    24     8 */
	} list;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct BlockBackendRootState {
	int                        open_flags;           /*     0     4 */
	_Bool                      read_only;            /*     4     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockdevDetectZeroesOptions detect_zeroes;       /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* sum members: 9, holes: 1, sum holes: 3 */
	/* last cacheline: 12 bytes */
};
struct Abort {
	char                       qapi_dummy_for_empty_struct; /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
};
struct BlkdebugInjectErrorOptions {
	BlkdebugEvent              event;                /*     0     4 */
	_Bool                      has_state;            /*     4     1 */

	/* XXX 3 bytes hole, try to pack */

	int64_t                    state;                /*     8     8 */
	_Bool                      has_q_errno;          /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    q_errno;              /*    24     8 */
	_Bool                      has_sector;           /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    sector;               /*    40     8 */
	_Bool                      has_once;             /*    48     1 */
	_Bool                      once;                 /*    49     1 */
	_Bool                      has_immediately;      /*    50     1 */
	_Bool                      immediately;          /*    51     1 */

	/* size: 56, cachelines: 1, members: 11 */
	/* sum members: 35, holes: 3, sum holes: 17 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct BlkdebugInjectErrorOptionsList {
	BlkdebugInjectErrorOptionsList * next;           /*     0     8 */
	BlkdebugInjectErrorOptions * value;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlkdebugSetStateOptions {
	BlkdebugEvent              event;                /*     0     4 */
	_Bool                      has_state;            /*     4     1 */

	/* XXX 3 bytes hole, try to pack */

	int64_t                    state;                /*     8     8 */
	int64_t                    new_state;            /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 21, holes: 1, sum holes: 3 */
	/* last cacheline: 24 bytes */
};
struct BlkdebugSetStateOptionsList {
	BlkdebugSetStateOptionsList * next;              /*     0     8 */
	BlkdebugSetStateOptions *  value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlockDeviceInfo {
	char *                     file;                 /*     0     8 */
	_Bool                      has_node_name;        /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     node_name;            /*    16     8 */
	_Bool                      ro;                   /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     drv;                  /*    32     8 */
	_Bool                      has_backing_file;     /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     backing_file;         /*    48     8 */
	int64_t                    backing_file_depth;   /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      encrypted;            /*    64     1 */
	_Bool                      encryption_key_missing; /*    65     1 */

	/* XXX 2 bytes hole, try to pack */

	BlockdevDetectZeroesOptions detect_zeroes;       /*    68     4 */
	int64_t                    bps;                  /*    72     8 */
	int64_t                    bps_rd;               /*    80     8 */
	int64_t                    bps_wr;               /*    88     8 */
	int64_t                    iops;                 /*    96     8 */
	int64_t                    iops_rd;              /*   104     8 */
	int64_t                    iops_wr;              /*   112     8 */
	ImageInfo *                image;                /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	_Bool                      has_bps_max;          /*   128     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    bps_max;              /*   136     8 */
	_Bool                      has_bps_rd_max;       /*   144     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    bps_rd_max;           /*   152     8 */
	_Bool                      has_bps_wr_max;       /*   160     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    bps_wr_max;           /*   168     8 */
	_Bool                      has_iops_max;         /*   176     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_max;             /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	_Bool                      has_iops_rd_max;      /*   192     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_rd_max;          /*   200     8 */
	_Bool                      has_iops_wr_max;      /*   208     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_wr_max;          /*   216     8 */
	_Bool                      has_bps_max_length;   /*   224     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    bps_max_length;       /*   232     8 */
	_Bool                      has_bps_rd_max_length; /*   240     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    bps_rd_max_length;    /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	_Bool                      has_bps_wr_max_length; /*   256     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    bps_wr_max_length;    /*   264     8 */
	_Bool                      has_iops_max_length;  /*   272     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_max_length;      /*   280     8 */
	_Bool                      has_iops_rd_max_length; /*   288     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_rd_max_length;   /*   296     8 */
	_Bool                      has_iops_wr_max_length; /*   304     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_wr_max_length;   /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	_Bool                      has_iops_size;        /*   320     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_size;            /*   328     8 */
	_Bool                      has_group;            /*   336     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     group;                /*   344     8 */
	BlockdevCacheInfo *        cache;                /*   352     8 */
	int64_t                    write_threshold;      /*   360     8 */

	/* size: 368, cachelines: 6, members: 48 */
	/* sum members: 247, holes: 18, sum holes: 121 */
	/* last cacheline: 48 bytes */
};
struct BlockDeviceInfoList {
	BlockDeviceInfoList *      next;                 /*     0     8 */
	BlockDeviceInfo *          value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlockDirtyBitmap {
	char *                     node;                 /*     0     8 */
	char *                     name;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlockDirtyBitmapAdd {
	char *                     node;                 /*     0     8 */
	char *                     name;                 /*     8     8 */
	_Bool                      has_granularity;      /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   granularity;          /*    20     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 21, holes: 1, sum holes: 3 */
	/* last cacheline: 24 bytes */
};
struct BlockIOThrottle {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	_Bool                      has_id;               /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     id;                   /*    24     8 */
	int64_t                    bps;                  /*    32     8 */
	int64_t                    bps_rd;               /*    40     8 */
	int64_t                    bps_wr;               /*    48     8 */
	int64_t                    iops;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int64_t                    iops_rd;              /*    64     8 */
	int64_t                    iops_wr;              /*    72     8 */
	_Bool                      has_bps_max;          /*    80     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    bps_max;              /*    88     8 */
	_Bool                      has_bps_rd_max;       /*    96     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    bps_rd_max;           /*   104     8 */
	_Bool                      has_bps_wr_max;       /*   112     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    bps_wr_max;           /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	_Bool                      has_iops_max;         /*   128     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_max;             /*   136     8 */
	_Bool                      has_iops_rd_max;      /*   144     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_rd_max;          /*   152     8 */
	_Bool                      has_iops_wr_max;      /*   160     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_wr_max;          /*   168     8 */
	_Bool                      has_bps_max_length;   /*   176     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    bps_max_length;       /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	_Bool                      has_bps_rd_max_length; /*   192     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    bps_rd_max_length;    /*   200     8 */
	_Bool                      has_bps_wr_max_length; /*   208     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    bps_wr_max_length;    /*   216     8 */
	_Bool                      has_iops_max_length;  /*   224     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_max_length;      /*   232     8 */
	_Bool                      has_iops_rd_max_length; /*   240     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_rd_max_length;   /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	_Bool                      has_iops_wr_max_length; /*   256     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_wr_max_length;   /*   264     8 */
	_Bool                      has_iops_size;        /*   272     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    iops_size;            /*   280     8 */
	_Bool                      has_group;            /*   288     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     group;                /*   296     8 */

	/* size: 304, cachelines: 5, members: 38 */
	/* sum members: 192, holes: 16, sum holes: 112 */
	/* last cacheline: 48 bytes */
};
struct BlockJobInfo {
	char *                     type;                 /*     0     8 */
	char *                     device;               /*     8     8 */
	int64_t                    len;                  /*    16     8 */
	int64_t                    offset;               /*    24     8 */
	_Bool                      busy;                 /*    32     1 */
	_Bool                      paused;               /*    33     1 */

	/* XXX 6 bytes hole, try to pack */

	int64_t                    speed;                /*    40     8 */
	BlockDeviceIoStatus        io_status;            /*    48     4 */
	_Bool                      ready;                /*    52     1 */

	/* size: 56, cachelines: 1, members: 9 */
	/* sum members: 47, holes: 1, sum holes: 6 */
	/* padding: 3 */
	/* last cacheline: 56 bytes */
};
struct BlockJobInfoList {
	BlockJobInfoList *         next;                 /*     0     8 */
	BlockJobInfo *             value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlockdevBackup {
	_Bool                      has_job_id;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     job_id;               /*     8     8 */
	char *                     device;               /*    16     8 */
	char *                     target;               /*    24     8 */
	MirrorSyncMode             sync;                 /*    32     4 */
	_Bool                      has_speed;            /*    36     1 */

	/* XXX 3 bytes hole, try to pack */

	int64_t                    speed;                /*    40     8 */
	_Bool                      has_compress;         /*    48     1 */
	_Bool                      compress;             /*    49     1 */
	_Bool                      has_on_source_error;  /*    50     1 */

	/* XXX 1 byte hole, try to pack */

	BlockdevOnError            on_source_error;      /*    52     4 */
	_Bool                      has_on_target_error;  /*    56     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockdevOnError            on_target_error;      /*    60     4 */

	/* size: 64, cachelines: 1, members: 13 */
	/* sum members: 50, holes: 4, sum holes: 14 */
};
struct BlockdevCacheInfo {
	_Bool                      writeback;            /*     0     1 */
	_Bool                      direct;               /*     1     1 */
	_Bool                      no_flush;             /*     2     1 */

	/* size: 3, cachelines: 1, members: 3 */
	/* last cacheline: 3 bytes */
};
struct BlockdevCacheOptions {
	_Bool                      has_direct;           /*     0     1 */
	_Bool                      direct;               /*     1     1 */
	_Bool                      has_no_flush;         /*     2     1 */
	_Bool                      no_flush;             /*     3     1 */

	/* size: 4, cachelines: 1, members: 4 */
	/* last cacheline: 4 bytes */
};
struct BlockdevOptions {
	BlockdevDriver             driver;               /*     0     4 */
	_Bool                      has_node_name;        /*     4     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     node_name;            /*     8     8 */
	_Bool                      has_discard;          /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockdevDiscardOptions     discard;              /*    20     4 */
	_Bool                      has_cache;            /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	BlockdevCacheOptions *     cache;                /*    32     8 */
	_Bool                      has_read_only;        /*    40     1 */
	_Bool                      read_only;            /*    41     1 */
	_Bool                      has_detect_zeroes;    /*    42     1 */

	/* XXX 1 byte hole, try to pack */

	BlockdevDetectZeroesOptions detect_zeroes;       /*    44     4 */
	union {
		BlockdevOptionsArchipelago archipelago;  /*    48    56 */
		BlockdevOptionsBlkdebug blkdebug;        /*    48    72 */
		BlockdevOptionsBlkverify blkverify;      /*    48    16 */
		BlockdevOptionsGenericFormat bochs;      /*    48     8 */
		BlockdevOptionsGenericFormat cloop;      /*    48     8 */
		BlockdevOptionsGenericFormat dmg;        /*    48     8 */
		BlockdevOptionsFile file;                /*    48    16 */
		BlockdevOptionsCurl ftp;                 /*    48     8 */
		BlockdevOptionsCurl ftps;                /*    48     8 */
		BlockdevOptionsGluster gluster;          /*    48    56 */
		BlockdevOptionsFile host_cdrom;          /*    48    16 */
		BlockdevOptionsFile host_device;         /*    48    16 */
		BlockdevOptionsCurl http;                /*    48     8 */
		BlockdevOptionsCurl https;               /*    48     8 */
		BlockdevOptionsLUKS luks;                /*    48    24 */
		BlockdevOptionsNbd nbd;                  /*    48    40 */
		BlockdevOptionsNfs nfs;                  /*    48   112 */
		BlockdevOptionsNull null_aio;            /*    48    32 */
		BlockdevOptionsNull null_co;             /*    48    32 */
		BlockdevOptionsGenericFormat parallels;  /*    48     8 */
		BlockdevOptionsQcow2 qcow2;              /*    48   112 */
		BlockdevOptionsGenericCOWFormat qcow;    /*    48    24 */
		BlockdevOptionsGenericCOWFormat qed;     /*    48    24 */
		BlockdevOptionsQuorum quorum;            /*    48    32 */
		BlockdevOptionsRaw raw;                  /*    48    40 */
		BlockdevOptionsReplication replication;  /*    48    24 */
		BlockdevOptionsSsh ssh;                  /*    48    32 */
		BlockdevOptionsGenericFormat vdi;        /*    48     8 */
		BlockdevOptionsGenericFormat vhdx;       /*    48     8 */
		BlockdevOptionsGenericCOWFormat vmdk;    /*    48    24 */
		BlockdevOptionsGenericFormat vpc;        /*    48     8 */
		BlockdevOptionsVVFAT vvfat;              /*    48    48 */
	} u;                                             /*    48   112 */

	/* size: 160, cachelines: 3, members: 12 */
	/* sum members: 146, holes: 4, sum holes: 14 */
	/* last cacheline: 32 bytes */
};
struct BlockdevOptionsArchipelago {
	char *                     volume;               /*     0     8 */
	_Bool                      has_mport;            /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    mport;                /*    16     8 */
	_Bool                      has_vport;            /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    vport;                /*    32     8 */
	_Bool                      has_segment;          /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     segment;              /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* sum members: 35, holes: 3, sum holes: 21 */
	/* last cacheline: 56 bytes */
};
struct BlockdevOptionsBlkdebug {
	BlockdevRef *              image;                /*     0     8 */
	_Bool                      has_config;           /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     config;               /*    16     8 */
	_Bool                      has_align;            /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    align;                /*    32     8 */
	_Bool                      has_inject_error;     /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	BlkdebugInjectErrorOptionsList * inject_error;   /*    48     8 */
	_Bool                      has_set_state;        /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	BlkdebugSetStateOptionsList * set_state;         /*    64     8 */

	/* size: 72, cachelines: 2, members: 9 */
	/* sum members: 44, holes: 4, sum holes: 28 */
	/* last cacheline: 8 bytes */
};
struct BlockdevOptionsBlkverify {
	BlockdevRef *              test;                 /*     0     8 */
	BlockdevRef *              raw;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlockdevOptionsCurl {
	char *                     filename;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct BlockdevOptionsFile {
	char *                     filename;             /*     0     8 */
	_Bool                      has_aio;              /*     8     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockdevAioOptions         aio;                  /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* sum members: 13, holes: 1, sum holes: 3 */
	/* last cacheline: 16 bytes */
};
struct BlockdevOptionsGenericCOWFormat {
	BlockdevRef *              file;                 /*     0     8 */
	_Bool                      has_backing;          /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	BlockdevRef *              backing;              /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct BlockdevOptionsGenericFormat {
	BlockdevRef *              file;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct BlockdevOptionsGluster {
	char *                     volume;               /*     0     8 */
	char *                     path;                 /*     8     8 */
	GlusterServerList *        server;               /*    16     8 */
	_Bool                      has_debug;            /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    debug;                /*    32     8 */
	_Bool                      has_logfile;          /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     logfile;              /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* sum members: 42, holes: 2, sum holes: 14 */
	/* last cacheline: 56 bytes */
};
struct BlockdevOptionsLUKS {
	BlockdevRef *              file;                 /*     0     8 */
	_Bool                      has_key_secret;       /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     key_secret;           /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct BlockdevOptionsNbd {
	SocketAddress *            server;               /*     0     8 */
	_Bool                      has_export;           /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     export;               /*    16     8 */
	_Bool                      has_tls_creds;        /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     tls_creds;            /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 26, holes: 2, sum holes: 14 */
	/* last cacheline: 40 bytes */
};
struct BlockdevOptionsNfs {
	NFSServer *                server;               /*     0     8 */
	char *                     path;                 /*     8     8 */
	_Bool                      has_user;             /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    user;                 /*    24     8 */
	_Bool                      has_group;            /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    group;                /*    40     8 */
	_Bool                      has_tcp_syn_count;    /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    tcp_syn_count;        /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_readahead_size;   /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    readahead_size;       /*    72     8 */
	_Bool                      has_page_cache_size;  /*    80     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    page_cache_size;      /*    88     8 */
	_Bool                      has_debug;            /*    96     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    debug;                /*   104     8 */

	/* size: 112, cachelines: 2, members: 14 */
	/* sum members: 70, holes: 6, sum holes: 42 */
	/* last cacheline: 48 bytes */
};
struct BlockdevOptionsNull {
	_Bool                      has_size;             /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    size;                 /*     8     8 */
	_Bool                      has_latency_ns;       /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	uint64_t                   latency_ns;           /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 18, holes: 2, sum holes: 14 */
	/* last cacheline: 32 bytes */
};
struct BlockdevOptionsQcow2 {
	BlockdevRef *              file;                 /*     0     8 */
	_Bool                      has_backing;          /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	BlockdevRef *              backing;              /*    16     8 */
	_Bool                      has_lazy_refcounts;   /*    24     1 */
	_Bool                      lazy_refcounts;       /*    25     1 */
	_Bool                      has_pass_discard_request; /*    26     1 */
	_Bool                      pass_discard_request; /*    27     1 */
	_Bool                      has_pass_discard_snapshot; /*    28     1 */
	_Bool                      pass_discard_snapshot; /*    29     1 */
	_Bool                      has_pass_discard_other; /*    30     1 */
	_Bool                      pass_discard_other;   /*    31     1 */
	_Bool                      has_overlap_check;    /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	Qcow2OverlapChecks *       overlap_check;        /*    40     8 */
	_Bool                      has_cache_size;       /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    cache_size;           /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_l2_cache_size;    /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    l2_cache_size;        /*    72     8 */
	_Bool                      has_refcount_cache_size; /*    80     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    refcount_cache_size;  /*    88     8 */
	_Bool                      has_cache_clean_interval; /*    96     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    cache_clean_interval; /*   104     8 */

	/* size: 112, cachelines: 2, members: 21 */
	/* sum members: 70, holes: 6, sum holes: 42 */
	/* last cacheline: 48 bytes */
};
struct BlockdevOptionsQuorum {
	_Bool                      has_blkverify;        /*     0     1 */
	_Bool                      blkverify;            /*     1     1 */

	/* XXX 6 bytes hole, try to pack */

	BlockdevRefList *          children;             /*     8     8 */
	int64_t                    vote_threshold;       /*    16     8 */
	_Bool                      has_rewrite_corrupted; /*    24     1 */
	_Bool                      rewrite_corrupted;    /*    25     1 */
	_Bool                      has_read_pattern;     /*    26     1 */

	/* XXX 1 byte hole, try to pack */

	QuorumReadPattern          read_pattern;         /*    28     4 */

	/* size: 32, cachelines: 1, members: 8 */
	/* sum members: 25, holes: 2, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct BlockdevOptionsRaw {
	BlockdevRef *              file;                 /*     0     8 */
	_Bool                      has_offset;           /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    offset;               /*    16     8 */
	_Bool                      has_size;             /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    size;                 /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 26, holes: 2, sum holes: 14 */
	/* last cacheline: 40 bytes */
};
struct BlockdevOptionsReplication {
	BlockdevRef *              file;                 /*     0     8 */
	ReplicationMode            mode;                 /*     8     4 */
	_Bool                      has_top_id;           /*    12     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     top_id;               /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 21, holes: 1, sum holes: 3 */
	/* last cacheline: 24 bytes */
};
struct BlockdevOptionsSsh {
	InetSocketAddress *        server;               /*     0     8 */
	char *                     path;                 /*     8     8 */
	_Bool                      has_user;             /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     user;                 /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 25, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct BlockdevOptionsVVFAT {
	char *                     dir;                  /*     0     8 */
	_Bool                      has_fat_type;         /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    fat_type;             /*    16     8 */
	_Bool                      has_floppy;           /*    24     1 */
	_Bool                      floppy;               /*    25     1 */
	_Bool                      has_label;            /*    26     1 */

	/* XXX 5 bytes hole, try to pack */

	char *                     label;                /*    32     8 */
	_Bool                      has_rw;               /*    40     1 */
	_Bool                      rw;                   /*    41     1 */

	/* size: 48, cachelines: 1, members: 9 */
	/* sum members: 30, holes: 2, sum holes: 12 */
	/* padding: 6 */
	/* last cacheline: 48 bytes */
};
struct BlockdevRef {
	QType                      type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		BlockdevOptions    definition;           /*     8   160 */
		char *             reference;            /*     8     8 */
	} u;                                             /*     8   160 */

	/* size: 168, cachelines: 3, members: 2 */
	/* sum members: 164, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct BlockdevRefList {
	BlockdevRefList *          next;                 /*     0     8 */
	BlockdevRef *              value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlockdevSnapshot {
	char *                     node;                 /*     0     8 */
	char *                     overlay;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlockdevSnapshotInternal {
	char *                     device;               /*     0     8 */
	char *                     name;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlockdevSnapshotSync {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	_Bool                      has_node_name;        /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     node_name;            /*    24     8 */
	char *                     snapshot_file;        /*    32     8 */
	_Bool                      has_snapshot_node_name; /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     snapshot_node_name;   /*    48     8 */
	_Bool                      has_format;           /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     format;               /*    64     8 */
	_Bool                      has_mode;             /*    72     1 */

	/* XXX 3 bytes hole, try to pack */

	NewImageMode               mode;                 /*    76     4 */

	/* size: 80, cachelines: 2, members: 11 */
	/* sum members: 49, holes: 5, sum holes: 31 */
	/* last cacheline: 16 bytes */
};
struct DriveBackup {
	_Bool                      has_job_id;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     job_id;               /*     8     8 */
	char *                     device;               /*    16     8 */
	char *                     target;               /*    24     8 */
	_Bool                      has_format;           /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     format;               /*    40     8 */
	MirrorSyncMode             sync;                 /*    48     4 */
	_Bool                      has_mode;             /*    52     1 */

	/* XXX 3 bytes hole, try to pack */

	NewImageMode               mode;                 /*    56     4 */
	_Bool                      has_speed;            /*    60     1 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	int64_t                    speed;                /*    64     8 */
	_Bool                      has_bitmap;           /*    72     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     bitmap;               /*    80     8 */
	_Bool                      has_compress;         /*    88     1 */
	_Bool                      compress;             /*    89     1 */
	_Bool                      has_on_source_error;  /*    90     1 */

	/* XXX 1 byte hole, try to pack */

	BlockdevOnError            on_source_error;      /*    92     4 */
	_Bool                      has_on_target_error;  /*    96     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockdevOnError            on_target_error;      /*   100     4 */

	/* size: 104, cachelines: 2, members: 19 */
	/* sum members: 73, holes: 7, sum holes: 31 */
	/* last cacheline: 40 bytes */
};
struct DriveMirror {
	_Bool                      has_job_id;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     job_id;               /*     8     8 */
	char *                     device;               /*    16     8 */
	char *                     target;               /*    24     8 */
	_Bool                      has_format;           /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     format;               /*    40     8 */
	_Bool                      has_node_name;        /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     node_name;            /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_replaces;         /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     replaces;             /*    72     8 */
	MirrorSyncMode             sync;                 /*    80     4 */
	_Bool                      has_mode;             /*    84     1 */

	/* XXX 3 bytes hole, try to pack */

	NewImageMode               mode;                 /*    88     4 */
	_Bool                      has_speed;            /*    92     1 */

	/* XXX 3 bytes hole, try to pack */

	int64_t                    speed;                /*    96     8 */
	_Bool                      has_granularity;      /*   104     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   granularity;          /*   108     4 */
	_Bool                      has_buf_size;         /*   112     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    buf_size;             /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	_Bool                      has_on_source_error;  /*   128     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockdevOnError            on_source_error;      /*   132     4 */
	_Bool                      has_on_target_error;  /*   136     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockdevOnError            on_target_error;      /*   140     4 */
	_Bool                      has_unmap;            /*   144     1 */
	_Bool                      unmap;                /*   145     1 */

	/* size: 152, cachelines: 3, members: 25 */
	/* sum members: 96, holes: 10, sum holes: 50 */
	/* padding: 6 */
	/* last cacheline: 24 bytes */
};
struct GlusterServer {
	GlusterTransport           type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		UnixSocketAddress  q_unix;               /*     8     8 */
		InetSocketAddress  tcp;                  /*     8    24 */
	} u;                                             /*     8    24 */

	/* size: 32, cachelines: 1, members: 2 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct GlusterServerList {
	GlusterServerList *        next;                 /*     0     8 */
	GlusterServer *            value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct InetSocketAddress {
	char *                     host;                 /*     0     8 */
	char *                     port;                 /*     8     8 */
	_Bool                      has_to;               /*    16     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   to;                   /*    18     2 */
	_Bool                      has_ipv4;             /*    20     1 */
	_Bool                      ipv4;                 /*    21     1 */
	_Bool                      has_ipv6;             /*    22     1 */
	_Bool                      ipv6;                 /*    23     1 */

	/* size: 24, cachelines: 1, members: 8 */
	/* sum members: 23, holes: 1, sum holes: 1 */
	/* last cacheline: 24 bytes */
};
struct NFSServer {
	NFSTransport               type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     host;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct Qcow2OverlapCheckFlags {
	_Bool                      has_q_template;       /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	Qcow2OverlapCheckMode      q_template;           /*     4     4 */
	_Bool                      has_main_header;      /*     8     1 */
	_Bool                      main_header;          /*     9     1 */
	_Bool                      has_active_l1;        /*    10     1 */
	_Bool                      active_l1;            /*    11     1 */
	_Bool                      has_active_l2;        /*    12     1 */
	_Bool                      active_l2;            /*    13     1 */
	_Bool                      has_refcount_table;   /*    14     1 */
	_Bool                      refcount_table;       /*    15     1 */
	_Bool                      has_refcount_block;   /*    16     1 */
	_Bool                      refcount_block;       /*    17     1 */
	_Bool                      has_snapshot_table;   /*    18     1 */
	_Bool                      snapshot_table;       /*    19     1 */
	_Bool                      has_inactive_l1;      /*    20     1 */
	_Bool                      inactive_l1;          /*    21     1 */
	_Bool                      has_inactive_l2;      /*    22     1 */
	_Bool                      inactive_l2;          /*    23     1 */

	/* size: 24, cachelines: 1, members: 18 */
	/* sum members: 21, holes: 1, sum holes: 3 */
	/* last cacheline: 24 bytes */
};
struct Qcow2OverlapChecks {
	QType                      type;                 /*     0     4 */
	union {
		Qcow2OverlapCheckFlags flags;            /*     4    24 */
		Qcow2OverlapCheckMode mode;              /*     4     4 */
	} u;                                             /*     4    24 */

	/* size: 28, cachelines: 1, members: 2 */
	/* last cacheline: 28 bytes */
};
struct SocketAddress {
	SocketAddressKind          type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		q_obj_InetSocketAddress_wrapper inet;    /*     8     8 */
		q_obj_UnixSocketAddress_wrapper q_unix;  /*     8     8 */
		q_obj_VsockSocketAddress_wrapper vsock;  /*     8     8 */
		q_obj_String_wrapper fd;                 /*     8     8 */
	} u;                                             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct String {
	char *                     str;                  /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct TransactionAction {
	TransactionActionKind      type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		q_obj_BlockdevSnapshot_wrapper blockdev_snapshot; /*     8     8 */
		q_obj_BlockdevSnapshotSync_wrapper blockdev_snapshot_sync; /*     8     8 */
		q_obj_DriveBackup_wrapper drive_backup;  /*     8     8 */
		q_obj_BlockdevBackup_wrapper blockdev_backup; /*     8     8 */
		q_obj_Abort_wrapper abort;               /*     8     8 */
		q_obj_BlockdevSnapshotInternal_wrapper blockdev_snapshot_internal_sync; /*     8     8 */
		q_obj_BlockDirtyBitmapAdd_wrapper block_dirty_bitmap_add; /*     8     8 */
		q_obj_BlockDirtyBitmap_wrapper block_dirty_bitmap_clear; /*     8     8 */
	} u;                                             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct TransactionActionList {
	TransactionActionList *    next;                 /*     0     8 */
	TransactionAction *        value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct TransactionProperties {
	_Bool                      has_completion_mode;  /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	ActionCompletionMode       completion_mode;      /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* sum members: 5, holes: 1, sum holes: 3 */
	/* last cacheline: 8 bytes */
};
struct UnixSocketAddress {
	char *                     path;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct VsockSocketAddress {
	char *                     cid;                  /*     0     8 */
	char *                     port;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_Abort_wrapper {
	Abort *                    data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_BlockDirtyBitmap_wrapper {
	BlockDirtyBitmap *         data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_BlockDirtyBitmapAdd_wrapper {
	BlockDirtyBitmapAdd *      data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_BlockdevBackup_wrapper {
	BlockdevBackup *           data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_BlockdevSnapshot_wrapper {
	BlockdevSnapshot *         data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_BlockdevSnapshotInternal_wrapper {
	BlockdevSnapshotInternal * data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_BlockdevSnapshotSync_wrapper {
	BlockdevSnapshotSync *     data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_DriveBackup_wrapper {
	DriveBackup *              data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_InetSocketAddress_wrapper {
	InetSocketAddress *        data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_String_wrapper {
	String *                   data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_UnixSocketAddress_wrapper {
	UnixSocketAddress *        data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_VsockSocketAddress_wrapper {
	VsockSocketAddress *       data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct QListEntry {
	QObject *                  value;                /*     0     8 */
	struct {
		struct QListEntry * tqe_next;            /*     8     8 */
		struct QListEntry * * tqe_prev;          /*    16     8 */
	} next;                                          /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
struct QList {
	QObject                    base;                 /*     0    16 */
	struct {
		struct QListEntry * tqh_first;           /*    16     8 */
		struct QListEntry * * tqh_last;          /*    24     8 */
	} head;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 2 */
	/* last cacheline: 32 bytes */
};
struct LeakyBucket {
	double                     avg;                  /*     0     8 */
	double                     max;                  /*     8     8 */
	double                     level;                /*    16     8 */
	double                     burst_level;          /*    24     8 */
	unsigned int               burst_length;         /*    32     4 */

	/* size: 40, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct ThrottleConfig {
	LeakyBucket                buckets[6];           /*     0   240 */
	/* --- cacheline 3 boundary (192 bytes) was 48 bytes ago --- */
	uint64_t                   op_size;              /*   240     8 */

	/* size: 248, cachelines: 4, members: 2 */
	/* last cacheline: 56 bytes */
};
struct ThrottleState {
	ThrottleConfig             cfg;                  /*     0   248 */
	/* --- cacheline 3 boundary (192 bytes) was 56 bytes ago --- */
	int64_t                    previous_leak;        /*   248     8 */

	/* size: 256, cachelines: 4, members: 2 */
};
struct ThrottleTimers {
	QEMUTimer *                timers[2];            /*     0    16 */
	QEMUClockType              clock_type;           /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUTimerCB *              read_timer_cb;        /*    24     8 */
	QEMUTimerCB *              write_timer_cb;       /*    32     8 */
	void *                     timer_opaque;         /*    40     8 */

	/* size: 48, cachelines: 1, members: 5 */
	/* sum members: 44, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct BlockBackendPublic {
	CoQueue                    throttled_reqs[2];    /*     0    32 */
	unsigned int               io_limits_disabled;   /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	ThrottleState *            throttle_state;       /*    40     8 */
	ThrottleTimers             throttle_timers;      /*    48    48 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	unsigned int               pending_reqs[2];      /*    96     8 */
	struct {
		struct BlockBackendPublic * le_next;     /*   104     8 */
		struct BlockBackendPublic * * le_prev;   /*   112     8 */
	} round_robin;                                   /*   104    16 */

	/* size: 120, cachelines: 2, members: 6 */
	/* sum members: 116, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct BlkActionState {
	TransactionAction *        action;               /*     0     8 */
	const BlkActionOps  *      ops;                  /*     8     8 */
	BlockJobTxn *              block_job_txn;        /*    16     8 */
	TransactionProperties *    txn_props;            /*    24     8 */
	struct {
		struct BlkActionState * sqe_next;        /*    32     8 */
	} entry;                                         /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct BlkActionOps {
	size_t                     instance_size;        /*     0     8 */
	void                       (*prepare)(BlkActionState *, Error * *); /*     8     8 */
	void                       (*commit)(BlkActionState *); /*    16     8 */
	void                       (*abort)(BlkActionState *); /*    24     8 */
	void                       (*clean)(BlkActionState *); /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct InternalSnapshotState {
	BlkActionState             common;               /*     0    40 */
	BlockDriverState *         bs;                   /*    40     8 */
	AioContext *               aio_context;          /*    48     8 */
	QEMUSnapshotInfo           sn;                   /*    56   408 */
	/* --- cacheline 7 boundary (448 bytes) was 16 bytes ago --- */
	_Bool                      created;              /*   464     1 */

	/* size: 472, cachelines: 8, members: 5 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct ExternalSnapshotState {
	BlkActionState             common;               /*     0    40 */
	BlockDriverState *         old_bs;               /*    40     8 */
	BlockDriverState *         new_bs;               /*    48     8 */
	AioContext *               aio_context;          /*    56     8 */

	/* size: 64, cachelines: 1, members: 4 */
};
struct DriveBackupState {
	BlkActionState             common;               /*     0    40 */
	BlockDriverState *         bs;                   /*    40     8 */
	AioContext *               aio_context;          /*    48     8 */
	BlockJob *                 job;                  /*    56     8 */

	/* size: 64, cachelines: 1, members: 4 */
};
struct BlockdevBackupState {
	BlkActionState             common;               /*     0    40 */
	BlockDriverState *         bs;                   /*    40     8 */
	BlockJob *                 job;                  /*    48     8 */
	AioContext *               aio_context;          /*    56     8 */

	/* size: 64, cachelines: 1, members: 4 */
};
struct BlockDirtyBitmapState {
	BlkActionState             common;               /*     0    40 */
	BdrvDirtyBitmap *          bitmap;               /*    40     8 */
	BlockDriverState *         bs;                   /*    48     8 */
	AioContext *               aio_context;          /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	HBitmap *                  backup;               /*    64     8 */
	_Bool                      prepared;             /*    72     1 */

	/* size: 80, cachelines: 2, members: 6 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct sockaddr_storage {
	sa_family_t                ss_family;            /*     0     2 */

	/* XXX 6 bytes hole, try to pack */

	long unsigned int          __ss_align;           /*     8     8 */
	char                       __ss_padding[112];    /*    16   112 */

	/* size: 128, cachelines: 2, members: 3 */
	/* sum members: 122, holes: 1, sum holes: 6 */
};
struct QIOChannelSocket {
	QIOChannel                 parent;               /*     0    56 */
	int                        fd;                   /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	struct sockaddr_storage    localAddr;            /*    64   128 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	socklen_t                  localAddrLen;         /*   192     4 */

	/* XXX 4 bytes hole, try to pack */

	struct sockaddr_storage    remoteAddr;           /*   200   128 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	socklen_t                  remoteAddrLen;        /*   328     4 */

	/* size: 336, cachelines: 6, members: 6 */
	/* sum members: 324, holes: 2, sum holes: 8 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct QCryptoTLSCreds {
	Object                     parent_obj;           /*     0    40 */
	char *                     dir;                  /*    40     8 */
	QCryptoTLSCredsEndpoint    endpoint;             /*    48     4 */
	_Bool                      verifyPeer;           /*    52     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     priority;             /*    56     8 */

	/* size: 64, cachelines: 1, members: 5 */
	/* sum members: 61, holes: 1, sum holes: 3 */
};
struct NBDServerData {
	QIOChannelSocket *         listen_ioc;           /*     0     8 */
	int                        watch;                /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	QCryptoTLSCreds *          tlscreds;             /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct IOThreadInfo {
	char *                     id;                   /*     0     8 */
	int64_t                    thread_id;            /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct IOThreadInfoList {
	IOThreadInfoList *         next;                 /*     0     8 */
	IOThreadInfo *             value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct UserCreatable {
	Object                     Parent;               /*     0    40 */

	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
struct UserCreatableClass {
	InterfaceClass             parent_class;         /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	void                       (*complete)(UserCreatable *, Error * *); /*   112     8 */
	_Bool                      (*can_be_deleted)(UserCreatable *, Error * *); /*   120     8 */

	/* size: 128, cachelines: 2, members: 3 */
};
struct DevicePropertyInfo {
	char *                     name;                 /*     0     8 */
	char *                     type;                 /*     8     8 */
	_Bool                      has_description;      /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     description;          /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 25, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct DevicePropertyInfoList {
	DevicePropertyInfoList *   next;                 /*     0     8 */
	DevicePropertyInfo *       value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct QDevAlias {
	const char  *              typename;             /*     0     8 */
	const char  *              alias;                /*     8     8 */
	uint32_t                   arch_mask;            /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct QOMCompositionState {
	Monitor *                  mon;                  /*     0     8 */
	int                        indent;               /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct passwd {
	char *                     pw_name;              /*     0     8 */
	char *                     pw_passwd;            /*     8     8 */
	__uid_t                    pw_uid;               /*    16     4 */
	__gid_t                    pw_gid;               /*    20     4 */
	char *                     pw_gecos;             /*    24     8 */
	char *                     pw_dir;               /*    32     8 */
	char *                     pw_shell;             /*    40     8 */

	/* size: 48, cachelines: 1, members: 7 */
	/* last cacheline: 48 bytes */
};
struct sockaddr {
	sa_family_t                sa_family;            /*     0     2 */
	char                       sa_data[14];          /*     2    14 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct sockaddr_un {
	sa_family_t                sun_family;           /*     0     2 */
	char                       sun_path[108];        /*     2   108 */

	/* size: 110, cachelines: 2, members: 2 */
	/* last cacheline: 46 bytes */
};
struct _GPollFD {
	gint                       fd;                   /*     0     4 */
	gushort                    events;               /*     4     2 */
	gushort                    revents;              /*     6     2 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct ChardevBackend {
	ChardevBackendKind         type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		q_obj_ChardevFile_wrapper file;          /*     8     8 */
		q_obj_ChardevHostdev_wrapper serial;     /*     8     8 */
		q_obj_ChardevHostdev_wrapper parallel;   /*     8     8 */
		q_obj_ChardevHostdev_wrapper pipe;       /*     8     8 */
		q_obj_ChardevSocket_wrapper socket;      /*     8     8 */
		q_obj_ChardevUdp_wrapper udp;            /*     8     8 */
		q_obj_ChardevCommon_wrapper pty;         /*     8     8 */
		q_obj_ChardevCommon_wrapper null;        /*     8     8 */
		q_obj_ChardevMux_wrapper mux;            /*     8     8 */
		q_obj_ChardevCommon_wrapper msmouse;     /*     8     8 */
		q_obj_ChardevCommon_wrapper braille;     /*     8     8 */
		q_obj_ChardevCommon_wrapper testdev;     /*     8     8 */
		q_obj_ChardevStdio_wrapper stdio;        /*     8     8 */
		q_obj_ChardevCommon_wrapper console;     /*     8     8 */
		q_obj_ChardevSpiceChannel_wrapper spicevmc; /*     8     8 */
		q_obj_ChardevSpicePort_wrapper spiceport; /*     8     8 */
		q_obj_ChardevVC_wrapper vc;              /*     8     8 */
		q_obj_ChardevRingbuf_wrapper ringbuf;    /*     8     8 */
		q_obj_ChardevRingbuf_wrapper memory;     /*     8     8 */
	} u;                                             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct ChardevFile {
	_Bool                      has_logfile;          /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     logfile;              /*     8     8 */
	_Bool                      has_logappend;        /*    16     1 */
	_Bool                      logappend;            /*    17     1 */
	_Bool                      has_in;               /*    18     1 */

	/* XXX 5 bytes hole, try to pack */

	char *                     in;                   /*    24     8 */
	char *                     out;                  /*    32     8 */
	_Bool                      has_append;           /*    40     1 */
	_Bool                      append;               /*    41     1 */

	/* size: 48, cachelines: 1, members: 9 */
	/* sum members: 30, holes: 2, sum holes: 12 */
	/* padding: 6 */
	/* last cacheline: 48 bytes */
};
struct ChardevHostdev {
	_Bool                      has_logfile;          /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     logfile;              /*     8     8 */
	_Bool                      has_logappend;        /*    16     1 */
	_Bool                      logappend;            /*    17     1 */

	/* XXX 6 bytes hole, try to pack */

	char *                     device;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 19, holes: 2, sum holes: 13 */
	/* last cacheline: 32 bytes */
};
struct ChardevMux {
	_Bool                      has_logfile;          /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     logfile;              /*     8     8 */
	_Bool                      has_logappend;        /*    16     1 */
	_Bool                      logappend;            /*    17     1 */

	/* XXX 6 bytes hole, try to pack */

	char *                     chardev;              /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 19, holes: 2, sum holes: 13 */
	/* last cacheline: 32 bytes */
};
struct ChardevReturn {
	_Bool                      has_pty;              /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     pty;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 9, holes: 1, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct ChardevRingbuf {
	_Bool                      has_logfile;          /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     logfile;              /*     8     8 */
	_Bool                      has_logappend;        /*    16     1 */
	_Bool                      logappend;            /*    17     1 */
	_Bool                      has_size;             /*    18     1 */

	/* XXX 5 bytes hole, try to pack */

	int64_t                    size;                 /*    24     8 */

	/* size: 32, cachelines: 1, members: 6 */
	/* sum members: 20, holes: 2, sum holes: 12 */
	/* last cacheline: 32 bytes */
};
struct ChardevSocket {
	_Bool                      has_logfile;          /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     logfile;              /*     8     8 */
	_Bool                      has_logappend;        /*    16     1 */
	_Bool                      logappend;            /*    17     1 */

	/* XXX 6 bytes hole, try to pack */

	SocketAddress *            addr;                 /*    24     8 */
	_Bool                      has_tls_creds;        /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     tls_creds;            /*    40     8 */
	_Bool                      has_server;           /*    48     1 */
	_Bool                      server;               /*    49     1 */
	_Bool                      has_wait;             /*    50     1 */
	_Bool                      wait;                 /*    51     1 */
	_Bool                      has_nodelay;          /*    52     1 */
	_Bool                      nodelay;              /*    53     1 */
	_Bool                      has_telnet;           /*    54     1 */
	_Bool                      telnet;               /*    55     1 */
	_Bool                      has_reconnect;        /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	int64_t                    reconnect;            /*    64     8 */

	/* size: 72, cachelines: 2, members: 17 */
	/* sum members: 45, holes: 4, sum holes: 27 */
	/* last cacheline: 8 bytes */
};
struct ChardevSpiceChannel {
	_Bool                      has_logfile;          /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     logfile;              /*     8     8 */
	_Bool                      has_logappend;        /*    16     1 */
	_Bool                      logappend;            /*    17     1 */

	/* XXX 6 bytes hole, try to pack */

	char *                     type;                 /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 19, holes: 2, sum holes: 13 */
	/* last cacheline: 32 bytes */
};
struct ChardevSpicePort {
	_Bool                      has_logfile;          /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     logfile;              /*     8     8 */
	_Bool                      has_logappend;        /*    16     1 */
	_Bool                      logappend;            /*    17     1 */

	/* XXX 6 bytes hole, try to pack */

	char *                     fqdn;                 /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 19, holes: 2, sum holes: 13 */
	/* last cacheline: 32 bytes */
};
struct ChardevStdio {
	_Bool                      has_logfile;          /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     logfile;              /*     8     8 */
	_Bool                      has_logappend;        /*    16     1 */
	_Bool                      logappend;            /*    17     1 */
	_Bool                      has_signal;           /*    18     1 */
	_Bool                      signal;               /*    19     1 */

	/* size: 24, cachelines: 1, members: 6 */
	/* sum members: 13, holes: 1, sum holes: 7 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct ChardevUdp {
	_Bool                      has_logfile;          /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     logfile;              /*     8     8 */
	_Bool                      has_logappend;        /*    16     1 */
	_Bool                      logappend;            /*    17     1 */

	/* XXX 6 bytes hole, try to pack */

	SocketAddress *            remote;               /*    24     8 */
	_Bool                      has_local;            /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	SocketAddress *            local;                /*    40     8 */

	/* size: 48, cachelines: 1, members: 7 */
	/* sum members: 28, holes: 3, sum holes: 20 */
	/* last cacheline: 48 bytes */
};
struct ChardevVC {
	_Bool                      has_logfile;          /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     logfile;              /*     8     8 */
	_Bool                      has_logappend;        /*    16     1 */
	_Bool                      logappend;            /*    17     1 */
	_Bool                      has_width;            /*    18     1 */

	/* XXX 5 bytes hole, try to pack */

	int64_t                    width;                /*    24     8 */
	_Bool                      has_height;           /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    height;               /*    40     8 */
	_Bool                      has_cols;             /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    cols;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_rows;             /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    rows;                 /*    72     8 */

	/* size: 80, cachelines: 2, members: 12 */
	/* sum members: 47, holes: 5, sum holes: 33 */
	/* last cacheline: 16 bytes */
};
struct q_obj_ChardevCommon_wrapper {
	ChardevCommon *            data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_ChardevFile_wrapper {
	ChardevFile *              data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_ChardevHostdev_wrapper {
	ChardevHostdev *           data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_ChardevMux_wrapper {
	ChardevMux *               data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_ChardevRingbuf_wrapper {
	ChardevRingbuf *           data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_ChardevSocket_wrapper {
	ChardevSocket *            data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_ChardevSpiceChannel_wrapper {
	ChardevSpiceChannel *      data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_ChardevSpicePort_wrapper {
	ChardevSpicePort *         data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_ChardevStdio_wrapper {
	ChardevStdio *             data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_ChardevUdp_wrapper {
	ChardevUdp *               data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_ChardevVC_wrapper {
	ChardevVC *                data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct ParallelIOArg {
	void *                     buffer;               /*     0     8 */
	int                        count;                /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct QIOChannelTLS {
	QIOChannel                 parent;               /*     0    56 */
	QIOChannel *               master;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	QCryptoTLSSession *        session;              /*    64     8 */

	/* size: 72, cachelines: 2, members: 3 */
	/* last cacheline: 8 bytes */
};
struct termios {
	tcflag_t                   c_iflag;              /*     0     4 */
	tcflag_t                   c_oflag;              /*     4     4 */
	tcflag_t                   c_cflag;              /*     8     4 */
	tcflag_t                   c_lflag;              /*    12     4 */
	cc_t                       c_line;               /*    16     1 */
	cc_t                       c_cc[32];             /*    17    32 */

	/* XXX 3 bytes hole, try to pack */

	speed_t                    c_ispeed;             /*    52     4 */
	speed_t                    c_ospeed;             /*    56     4 */

	/* size: 60, cachelines: 1, members: 8 */
	/* sum members: 57, holes: 1, sum holes: 3 */
	/* last cacheline: 60 bytes */
};
struct MuxDriver {
	CharBackend *              backends[4];          /*     0    32 */
	CharBackend                chr;                  /*    32    48 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	int                        focus;                /*    80     4 */
	int                        mux_cnt;              /*    84     4 */
	int                        term_got_escape;      /*    88     4 */
	int                        max_size;             /*    92     4 */
	unsigned char              buffer[4][32];        /*    96   128 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	int                        prod[4];              /*   224    16 */
	int                        cons[4];              /*   240    16 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	int                        timestamps;           /*   256     4 */
	int                        linestart;            /*   260     4 */
	int64_t                    timestamps_start;     /*   264     8 */

	/* size: 272, cachelines: 5, members: 12 */
	/* last cacheline: 16 bytes */
};
struct CharDriverStateHead {
	struct CharDriverState *   tqh_first;            /*     0     8 */
	struct CharDriverState * * tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct IOWatchPoll {
	GSource                    parent;               /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	QIOChannel *               ioc;                  /*    96     8 */
	GSource *                  src;                  /*   104     8 */
	IOCanReadHandler *         fd_can_read;          /*   112     8 */
	GSourceFunc                fd_read;              /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	void *                     opaque;               /*   128     8 */
	GMainContext *             context;              /*   136     8 */

	/* size: 144, cachelines: 3, members: 7 */
	/* last cacheline: 16 bytes */
};
struct FDCharDriver {
	CharDriverState *          chr;                  /*     0     8 */
	QIOChannel *               ioc_in;               /*     8     8 */
	QIOChannel *               ioc_out;              /*    16     8 */
	int                        max_size;             /*    24     4 */

	/* size: 32, cachelines: 1, members: 4 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct CharDriver {
	const char  *              name;                 /*     0     8 */
	ChardevBackendKind         kind;                 /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	CharDriverParse *          parse;                /*    16     8 */
	CharDriverCreate *         create;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct PageCache {
	CacheItem *                page_cache;           /*     0     8 */
	unsigned int               page_size;            /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    max_num_items;        /*    16     8 */
	uint64_t                   max_item_age;         /*    24     8 */
	int64_t                    num_items;            /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct CacheItem {
	uint64_t                   it_addr;              /*     0     8 */
	uint64_t                   it_age;               /*     8     8 */
	uint8_t *                  it_data;              /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct HCIInfo {
	int                        (*bdaddr_set)(struct HCIInfo *, const uint8_t  *); /*     0     8 */
	void                       (*cmd_send)(struct HCIInfo *, const uint8_t  *, int); /*     8     8 */
	void                       (*sco_send)(struct HCIInfo *, const uint8_t  *, int); /*    16     8 */
	void                       (*acl_send)(struct HCIInfo *, const uint8_t  *, int); /*    24     8 */
	void *                     opaque;               /*    32     8 */
	void                       (*evt_recv)(void *, const uint8_t  *, int); /*    40     8 */
	void                       (*acl_recv)(void *, const uint8_t  *, int); /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* last cacheline: 56 bytes */
};
struct bt_host_hci_s {
	struct HCIInfo             hci;                  /*     0    56 */
	int                        fd;                   /*    56     4 */
	uint8_t                    hdr[1028];            /*    60  1028 */
	/* --- cacheline 17 boundary (1088 bytes) --- */
	int                        len;                  /*  1088     4 */

	/* size: 1096, cachelines: 18, members: 4 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
struct bt_vhci_s {
	int                        fd;                   /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	struct HCIInfo *           info;                 /*     8     8 */
	uint8_t                    hdr[4096];            /*    16  4096 */
	/* --- cacheline 64 boundary (4096 bytes) was 16 bytes ago --- */
	int                        len;                  /*  4112     4 */

	/* size: 4120, cachelines: 65, members: 4 */
	/* sum members: 4112, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct MachineInfo {
	char *                     name;                 /*     0     8 */
	_Bool                      has_alias;            /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     alias;                /*    16     8 */
	_Bool                      has_is_default;       /*    24     1 */
	_Bool                      is_default;           /*    25     1 */

	/* XXX 6 bytes hole, try to pack */

	int64_t                    cpu_max;              /*    32     8 */
	_Bool                      hotpluggable_cpus;    /*    40     1 */

	/* size: 48, cachelines: 1, members: 7 */
	/* sum members: 28, holes: 2, sum holes: 13 */
	/* padding: 7 */
	/* last cacheline: 48 bytes */
};
struct MachineInfoList {
	MachineInfoList *          next;                 /*     0     8 */
	MachineInfo *              value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct StatusInfo {
	_Bool                      running;              /*     0     1 */
	_Bool                      singlestep;           /*     1     1 */

	/* XXX 2 bytes hole, try to pack */

	RunState                   status;               /*     4     4 */

	/* size: 8, cachelines: 1, members: 3 */
	/* sum members: 6, holes: 1, sum holes: 2 */
	/* last cacheline: 8 bytes */
};
struct ObjectPropertyIterator {
	ObjectClass *              nextclass;            /*     0     8 */
	GHashTableIter             iter;                 /*     8    40 */

	/* size: 48, cachelines: 1, members: 2 */
	/* last cacheline: 48 bytes */
};
struct USBPort {
	USBDevice *                dev;                  /*     0     8 */
	int                        speedmask;            /*     8     4 */
	int                        hubcount;             /*    12     4 */
	char                       path[16];             /*    16    16 */
	USBPortOps *               ops;                  /*    32     8 */
	void *                     opaque;               /*    40     8 */
	int                        index;                /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct USBPort *   tqe_next;             /*    56     8 */
		/* --- cacheline 1 boundary (64 bytes) --- */
		struct USBPort * * tqe_prev;             /*    64     8 */
	} next;                                          /*    56    16 */

	/* size: 72, cachelines: 2, members: 8 */
	/* sum members: 68, holes: 1, sum holes: 4 */
	/* last cacheline: 8 bytes */
};
struct USBDevice {
	DeviceState                qdev;                 /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	USBPort *                  port;                 /*   112     8 */
	char *                     port_path;            /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	char *                     serial;               /*   128     8 */
	void *                     opaque;               /*   136     8 */
	uint32_t                   flags;                /*   144     4 */
	int                        speed;                /*   148     4 */
	int                        speedmask;            /*   152     4 */
	uint8_t                    addr;                 /*   156     1 */
	char                       product_desc[32];     /*   157    32 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        auto_attach;          /*   192     4 */
	_Bool                      attached;             /*   196     1 */

	/* XXX 3 bytes hole, try to pack */

	int32_t                    state;                /*   200     4 */
	uint8_t                    setup_buf[8];         /*   204     8 */
	uint8_t                    data_buf[4096];       /*   212  4096 */
	/* --- cacheline 67 boundary (4288 bytes) was 20 bytes ago --- */
	int32_t                    remote_wakeup;        /*  4308     4 */
	int32_t                    setup_state;          /*  4312     4 */
	int32_t                    setup_len;            /*  4316     4 */
	int32_t                    setup_index;          /*  4320     4 */

	/* XXX 4 bytes hole, try to pack */

	USBEndpoint                ep_ctl;               /*  4328    40 */
	/* --- cacheline 68 boundary (4352 bytes) was 16 bytes ago --- */
	USBEndpoint                ep_in[15];            /*  4368   600 */
	/* --- cacheline 77 boundary (4928 bytes) was 40 bytes ago --- */
	USBEndpoint                ep_out[15];           /*  4968   600 */
	/* --- cacheline 87 boundary (5568 bytes) --- */
	struct {
		struct USBDescString * lh_first;         /*  5568     8 */
	} strings;                                       /*  5568     8 */
	const USBDesc  *           usb_desc;             /*  5576     8 */
	const USBDescDevice  *     device;               /*  5584     8 */
	int                        configuration;        /*  5592     4 */
	int                        ninterfaces;          /*  5596     4 */
	int                        altsetting[16];       /*  5600    64 */
	/* --- cacheline 88 boundary (5632 bytes) was 32 bytes ago --- */
	const USBDescConfig  *     config;               /*  5664     8 */
	const USBDescIface  *      ifaces[16];           /*  5672   128 */

	/* size: 5800, cachelines: 91, members: 30 */
	/* sum members: 5790, holes: 3, sum holes: 10 */
	/* last cacheline: 40 bytes */
};
struct USBPacket {
	int                        pid;                  /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   id;                   /*     8     8 */
	USBEndpoint *              ep;                   /*    16     8 */
	unsigned int               stream;               /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUIOVector               iov;                  /*    32    24 */
	uint64_t                   parameter;            /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      short_not_ok;         /*    64     1 */
	_Bool                      int_req;              /*    65     1 */

	/* XXX 2 bytes hole, try to pack */

	int                        status;               /*    68     4 */
	int                        actual_length;        /*    72     4 */
	USBPacketState             state;                /*    76     4 */
	USBCombinedPacket *        combined;             /*    80     8 */
	struct {
		struct USBPacket * tqe_next;             /*    88     8 */
		struct USBPacket * * tqe_prev;           /*    96     8 */
	} queue;                                         /*    88    16 */
	struct {
		struct USBPacket * tqe_next;             /*   104     8 */
		struct USBPacket * * tqe_prev;           /*   112     8 */
	} combined_entry;                                /*   104    16 */

	/* size: 120, cachelines: 2, members: 14 */
	/* sum members: 110, holes: 3, sum holes: 10 */
	/* last cacheline: 56 bytes */
};
struct USBCombinedPacket {
	USBPacket *                first;                /*     0     8 */
	struct packets_head        packets;              /*     8    16 */
	QEMUIOVector               iov;                  /*    24    24 */

	/* size: 48, cachelines: 1, members: 3 */
	/* last cacheline: 48 bytes */
};
struct USBEndpoint {
	uint8_t                    nr;                   /*     0     1 */
	uint8_t                    pid;                  /*     1     1 */
	uint8_t                    type;                 /*     2     1 */
	uint8_t                    ifnum;                /*     3     1 */
	int                        max_packet_size;      /*     4     4 */
	int                        max_streams;          /*     8     4 */
	_Bool                      pipeline;             /*    12     1 */
	_Bool                      halted;               /*    13     1 */

	/* XXX 2 bytes hole, try to pack */

	USBDevice *                dev;                  /*    16     8 */
	struct {
		struct USBPacket * tqh_first;            /*    24     8 */
		struct USBPacket * * tqh_last;           /*    32     8 */
	} queue;                                         /*    24    16 */

	/* size: 40, cachelines: 1, members: 10 */
	/* sum members: 38, holes: 1, sum holes: 2 */
	/* last cacheline: 40 bytes */
};
struct USBDescString {
	uint8_t                    index;                /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     str;                  /*     8     8 */
	struct {
		struct USBDescString * le_next;          /*    16     8 */
		struct USBDescString * * le_prev;        /*    24     8 */
	} next;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* sum members: 25, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct USBPortOps {
	void                       (*attach)(USBPort *); /*     0     8 */
	void                       (*detach)(USBPort *); /*     8     8 */
	void                       (*child_detach)(USBPort *, USBDevice *); /*    16     8 */
	void                       (*wakeup)(USBPort *); /*    24     8 */
	void                       (*complete)(USBPort *, USBPacket *); /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct packets_head {
	struct USBPacket *         tqh_first;            /*     0     8 */
	struct USBPacket * *       tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct vm_change_state_entry {
	VMChangeStateHandler *     cb;                   /*     0     8 */
	void *                     opaque;               /*     8     8 */
	struct {
		struct vm_change_state_entry * le_next;  /*    16     8 */
		struct vm_change_state_entry * * le_prev; /*    24     8 */
	} entries;                                       /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct bt_scatternet_s {
	struct bt_device_s *       slave;                /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct bt_device_s {
	int                        lt_addr;              /*     0     4 */
	bdaddr_t                   bd_addr;              /*     4     6 */

	/* XXX 2 bytes hole, try to pack */

	int                        mtu;                  /*    12     4 */
	int                        setup;                /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	struct bt_scatternet_s *   net;                  /*    24     8 */
	uint8_t                    key[16];              /*    32    16 */
	int                        key_present;          /*    48     4 */
	uint8_t                    class[3];             /*    52     3 */
	uint8_t                    reject_reason;        /*    55     1 */
	uint64_t                   lmp_caps;             /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	const char  *              lmp_name;             /*    64     8 */
	void                       (*lmp_connection_request)(struct bt_link_s *); /*    72     8 */
	void                       (*lmp_connection_complete)(struct bt_link_s *); /*    80     8 */
	void                       (*lmp_disconnect_master)(struct bt_link_s *); /*    88     8 */
	void                       (*lmp_disconnect_slave)(struct bt_link_s *); /*    96     8 */
	void                       (*lmp_acl_data)(struct bt_link_s *, const uint8_t  *, int, int); /*   104     8 */
	void                       (*lmp_acl_resp)(struct bt_link_s *, const uint8_t  *, int, int); /*   112     8 */
	void                       (*lmp_mode_change)(struct bt_link_s *); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	void                       (*handle_destroy)(struct bt_device_s *); /*   128     8 */
	struct bt_device_s *       next;                 /*   136     8 */
	int                        inquiry_scan;         /*   144     4 */
	int                        page_scan;            /*   148     4 */
	uint16_t                   clkoff;               /*   152     2 */

	/* size: 160, cachelines: 3, members: 23 */
	/* sum members: 148, holes: 2, sum holes: 6 */
	/* padding: 6 */
	/* last cacheline: 32 bytes */
};
struct bt_link_s {
	struct bt_device_s *       slave;                /*     0     8 */
	struct bt_device_s *       host;                 /*     8     8 */
	uint16_t                   handle;               /*    16     2 */
	uint16_t                   acl_interval;         /*    18     2 */
	enum {
		acl_active = 0,
		acl_hold = 1,
		acl_sniff = 2,
		acl_parked = 3,
	} acl_mode;                                      /*    20     4 */

	/* size: 24, cachelines: 1, members: 5 */
	/* last cacheline: 24 bytes */
};
struct SemihostingConfig {
	_Bool                      enabled;              /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	SemihostingTarget          target;               /*     4     4 */
	const char  * *            argv;                 /*     8     8 */
	int                        argc;                 /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              cmdline;              /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 25, holes: 2, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct vm_change_state_head {
	struct vm_change_state_entry * lh_first;         /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct QEMUResetEntry {
	struct {
		struct QEMUResetEntry * tqe_next;        /*     0     8 */
		struct QEMUResetEntry * * tqe_prev;      /*     8     8 */
	} entry;                                         /*     0    16 */
	QEMUResetHandler *         func;                 /*    16     8 */
	void *                     opaque;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct reset_handlers {
	struct QEMUResetEntry *    tqh_first;            /*     0     8 */
	struct QEMUResetEntry * *  tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct QEMUOption {
	const char  *              name;                 /*     0     8 */
	int                        flags;                /*     8     4 */
	int                        index;                /*    12     4 */
	uint32_t                   arch_mask;            /*    16     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct VGAInterfaceInfo {
	const char  *              opt_name;             /*     0     8 */
	const char  *              name;                 /*     8     8 */
	const char  *              class_names[2];       /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct device_config {
	enum {
		DEV_USB = 0,
		DEV_BT = 1,
		DEV_SERIAL = 2,
		DEV_PARALLEL = 3,
		DEV_VIRTCON = 4,
		DEV_DEBUGCON = 5,
		DEV_GDB = 6,
		DEV_SCLP = 7,
	} type;                                          /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              cmdline;              /*     8     8 */
	Location                   loc;                  /*    16    24 */
	struct {
		struct device_config * tqe_next;         /*    40     8 */
		struct device_config * * tqe_prev;       /*    48     8 */
	} next;                                          /*    40    16 */

	/* size: 56, cachelines: 1, members: 4 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct TPMInfo {
	char *                     id;                   /*     0     8 */
	TpmModel                   model;                /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	TpmTypeOptions *           options;              /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct TPMInfoList {
	TPMInfoList *              next;                 /*     0     8 */
	TPMInfo *                  value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct TPMPassthroughOptions {
	_Bool                      has_path;             /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     path;                 /*     8     8 */
	_Bool                      has_cancel_path;      /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     cancel_path;          /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 18, holes: 2, sum holes: 14 */
	/* last cacheline: 32 bytes */
};
struct TpmModelList {
	TpmModelList *             next;                 /*     0     8 */
	TpmModel                   value;                /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct TpmTypeList {
	TpmTypeList *              next;                 /*     0     8 */
	TpmType                    value;                /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct TpmTypeOptions {
	TpmTypeOptionsKind         type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		q_obj_TPMPassthroughOptions_wrapper passthrough; /*     8     8 */
	} u;                                             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct q_obj_TPMPassthroughOptions_wrapper {
	TPMPassthroughOptions *    data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct TPMBackend {
	Object                     parent;               /*     0    40 */
	_Bool                      opened;               /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     id;                   /*    48     8 */
	enum TpmModel              fe_model;             /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     path;                 /*    64     8 */
	char *                     cancel_path;          /*    72     8 */
	const TPMDriverOps  *      ops;                  /*    80     8 */
	struct {
		struct TPMBackend * le_next;             /*    88     8 */
		struct TPMBackend * * le_prev;           /*    96     8 */
	} list;                                          /*    88    16 */

	/* size: 104, cachelines: 2, members: 8 */
	/* sum members: 93, holes: 2, sum holes: 11 */
	/* last cacheline: 40 bytes */
};
struct TPMDriverOps {
	enum TpmType               type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const QemuOptDesc  *       opts;                 /*     8     8 */
	const char  *              (*desc)(void);        /*    16     8 */
	TPMBackend *               (*create)(QemuOpts *, const char  *); /*    24     8 */
	void                       (*destroy)(TPMBackend *); /*    32     8 */
	int                        (*init)(TPMBackend *, TPMState *, TPMRecvDataCB *); /*    40     8 */
	int                        (*startup_tpm)(TPMBackend *); /*    48     8 */
	_Bool                      (*had_startup_error)(TPMBackend *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	size_t                     (*realloc_buffer)(TPMSizedBuffer *); /*    64     8 */
	void                       (*deliver_request)(TPMBackend *); /*    72     8 */
	void                       (*reset)(TPMBackend *); /*    80     8 */
	void                       (*cancel_cmd)(TPMBackend *); /*    88     8 */
	_Bool                      (*get_tpm_established_flag)(TPMBackend *); /*    96     8 */
	int                        (*reset_tpm_established_flag)(TPMBackend *, uint8_t); /*   104     8 */
	TPMVersion                 (*get_tpm_version)(TPMBackend *); /*   112     8 */

	/* size: 120, cachelines: 2, members: 15 */
	/* sum members: 116, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct TPMSizedBuffer {
	uint32_t                   size;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  buffer;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct uint32List {
	uint32List *               next;                 /*     0     8 */
	uint32_t                   value;                /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct BlockDeviceStats {
	int64_t                    rd_bytes;             /*     0     8 */
	int64_t                    wr_bytes;             /*     8     8 */
	int64_t                    rd_operations;        /*    16     8 */
	int64_t                    wr_operations;        /*    24     8 */
	int64_t                    flush_operations;     /*    32     8 */
	int64_t                    flush_total_time_ns;  /*    40     8 */
	int64_t                    wr_total_time_ns;     /*    48     8 */
	int64_t                    rd_total_time_ns;     /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int64_t                    wr_highest_offset;    /*    64     8 */
	int64_t                    rd_merged;            /*    72     8 */
	int64_t                    wr_merged;            /*    80     8 */
	_Bool                      has_idle_time_ns;     /*    88     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    idle_time_ns;         /*    96     8 */
	int64_t                    failed_rd_operations; /*   104     8 */
	int64_t                    failed_wr_operations; /*   112     8 */
	int64_t                    failed_flush_operations; /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int64_t                    invalid_rd_operations; /*   128     8 */
	int64_t                    invalid_wr_operations; /*   136     8 */
	int64_t                    invalid_flush_operations; /*   144     8 */
	_Bool                      account_invalid;      /*   152     1 */
	_Bool                      account_failed;       /*   153     1 */

	/* XXX 6 bytes hole, try to pack */

	BlockDeviceTimedStatsList * timed_stats;         /*   160     8 */

	/* size: 168, cachelines: 3, members: 22 */
	/* sum members: 155, holes: 2, sum holes: 13 */
	/* last cacheline: 40 bytes */
};
struct BlockDeviceTimedStats {
	int64_t                    interval_length;      /*     0     8 */
	int64_t                    min_rd_latency_ns;    /*     8     8 */
	int64_t                    max_rd_latency_ns;    /*    16     8 */
	int64_t                    avg_rd_latency_ns;    /*    24     8 */
	int64_t                    min_wr_latency_ns;    /*    32     8 */
	int64_t                    max_wr_latency_ns;    /*    40     8 */
	int64_t                    avg_wr_latency_ns;    /*    48     8 */
	int64_t                    min_flush_latency_ns; /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int64_t                    max_flush_latency_ns; /*    64     8 */
	int64_t                    avg_flush_latency_ns; /*    72     8 */
	double                     avg_rd_queue_depth;   /*    80     8 */
	double                     avg_wr_queue_depth;   /*    88     8 */

	/* size: 96, cachelines: 2, members: 12 */
	/* last cacheline: 32 bytes */
};
struct BlockDeviceTimedStatsList {
	BlockDeviceTimedStatsList * next;                /*     0     8 */
	BlockDeviceTimedStats *    value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlockDirtyInfo {
	_Bool                      has_name;             /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     name;                 /*     8     8 */
	int64_t                    count;                /*    16     8 */
	uint32_t                   granularity;          /*    24     4 */
	DirtyBitmapStatus          status;               /*    28     4 */

	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 25, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct BlockDirtyInfoList {
	BlockDirtyInfoList *       next;                 /*     0     8 */
	BlockDirtyInfo *           value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlockInfo {
	char *                     device;               /*     0     8 */
	char *                     type;                 /*     8     8 */
	_Bool                      removable;            /*    16     1 */
	_Bool                      locked;               /*    17     1 */
	_Bool                      has_inserted;         /*    18     1 */

	/* XXX 5 bytes hole, try to pack */

	BlockDeviceInfo *          inserted;             /*    24     8 */
	_Bool                      has_tray_open;        /*    32     1 */
	_Bool                      tray_open;            /*    33     1 */
	_Bool                      has_io_status;        /*    34     1 */

	/* XXX 1 byte hole, try to pack */

	BlockDeviceIoStatus        io_status;            /*    36     4 */
	_Bool                      has_dirty_bitmaps;    /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	BlockDirtyInfoList *       dirty_bitmaps;        /*    48     8 */

	/* size: 56, cachelines: 1, members: 12 */
	/* sum members: 43, holes: 3, sum holes: 13 */
	/* last cacheline: 56 bytes */
};
struct BlockInfoList {
	BlockInfoList *            next;                 /*     0     8 */
	BlockInfo *                value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlockStats {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	_Bool                      has_node_name;        /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     node_name;            /*    24     8 */
	BlockDeviceStats *         stats;                /*    32     8 */
	_Bool                      has_parent;           /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	BlockStats *               parent;               /*    48     8 */
	_Bool                      has_backing;          /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	BlockStats *               backing;              /*    64     8 */

	/* size: 72, cachelines: 2, members: 9 */
	/* sum members: 44, holes: 4, sum holes: 28 */
	/* last cacheline: 8 bytes */
};
struct BlockStatsList {
	BlockStatsList *           next;                 /*     0     8 */
	BlockStats *               value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct CommandLineOptionInfo {
	char *                     option;               /*     0     8 */
	CommandLineParameterInfoList * parameters;       /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct CommandLineOptionInfoList {
	CommandLineOptionInfoList * next;                /*     0     8 */
	CommandLineOptionInfo *    value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct CommandLineParameterInfo {
	char *                     name;                 /*     0     8 */
	CommandLineParameterType   type;                 /*     8     4 */
	_Bool                      has_help;             /*    12     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     help;                 /*    16     8 */
	_Bool                      has_q_default;        /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     q_default;            /*    32     8 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 30, holes: 2, sum holes: 10 */
	/* last cacheline: 40 bytes */
};
struct CommandLineParameterInfoList {
	CommandLineParameterInfoList * next;             /*     0     8 */
	CommandLineParameterInfo * value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct CpuModelBaselineInfo {
	CpuModelInfo *             model;                /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct CpuModelCompareInfo {
	CpuModelCompareResult      result;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	strList *                  responsible_properties; /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct CpuModelExpansionInfo {
	CpuModelInfo *             model;                /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct CpuModelInfo {
	char *                     name;                 /*     0     8 */
	_Bool                      has_props;            /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	QObject *                  props;                /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct InputBtnEvent {
	InputButton                button;               /*     0     4 */
	_Bool                      down;                 /*     4     1 */

	/* size: 8, cachelines: 1, members: 2 */
	/* padding: 3 */
	/* last cacheline: 8 bytes */
};
struct InputEvent {
	InputEventKind             type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		q_obj_InputKeyEvent_wrapper key;         /*     8     8 */
		q_obj_InputBtnEvent_wrapper btn;         /*     8     8 */
		q_obj_InputMoveEvent_wrapper rel;        /*     8     8 */
		q_obj_InputMoveEvent_wrapper abs;        /*     8     8 */
	} u;                                             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct InputEventList {
	InputEventList *           next;                 /*     0     8 */
	InputEvent *               value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct InputKeyEvent {
	KeyValue *                 key;                  /*     0     8 */
	_Bool                      down;                 /*     8     1 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct InputMoveEvent {
	InputAxis                  axis;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct KeyValue {
	KeyValueKind               type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		q_obj_int_wrapper  number;               /*     8     8 */
		q_obj_QKeyCode_wrapper qcode;            /*     8     4 */
	} u;                                             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct KeyValueList {
	KeyValueList *             next;                 /*     0     8 */
	KeyValue *                 value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct KvmInfo {
	_Bool                      enabled;              /*     0     1 */
	_Bool                      present;              /*     1     1 */

	/* size: 2, cachelines: 1, members: 2 */
	/* last cacheline: 2 bytes */
};
struct MigrationCapabilityStatus {
	MigrationCapability        capability;           /*     0     4 */
	_Bool                      state;                /*     4     1 */

	/* size: 8, cachelines: 1, members: 2 */
	/* padding: 3 */
	/* last cacheline: 8 bytes */
};
struct MigrationCapabilityStatusList {
	MigrationCapabilityStatusList * next;            /*     0     8 */
	MigrationCapabilityStatus * value;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct MigrationInfo {
	_Bool                      has_status;           /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	MigrationStatus            status;               /*     4     4 */
	_Bool                      has_ram;              /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	MigrationStats *           ram;                  /*    16     8 */
	_Bool                      has_disk;             /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	MigrationStats *           disk;                 /*    32     8 */
	_Bool                      has_xbzrle_cache;     /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	XBZRLECacheStats *         xbzrle_cache;         /*    48     8 */
	_Bool                      has_total_time;       /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	int64_t                    total_time;           /*    64     8 */
	_Bool                      has_expected_downtime; /*    72     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    expected_downtime;    /*    80     8 */
	_Bool                      has_downtime;         /*    88     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    downtime;             /*    96     8 */
	_Bool                      has_setup_time;       /*   104     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    setup_time;           /*   112     8 */
	_Bool                      has_cpu_throttle_percentage; /*   120     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 2 boundary (128 bytes) --- */
	int64_t                    cpu_throttle_percentage; /*   128     8 */
	_Bool                      has_error_desc;       /*   136     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     error_desc;           /*   144     8 */

	/* size: 152, cachelines: 3, members: 20 */
	/* sum members: 86, holes: 10, sum holes: 66 */
	/* last cacheline: 24 bytes */
};
struct MigrationStats {
	int64_t                    transferred;          /*     0     8 */
	int64_t                    remaining;            /*     8     8 */
	int64_t                    total;                /*    16     8 */
	int64_t                    duplicate;            /*    24     8 */
	int64_t                    skipped;              /*    32     8 */
	int64_t                    normal;               /*    40     8 */
	int64_t                    normal_bytes;         /*    48     8 */
	int64_t                    dirty_pages_rate;     /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	double                     mbps;                 /*    64     8 */
	int64_t                    dirty_sync_count;     /*    72     8 */
	int64_t                    postcopy_requests;    /*    80     8 */

	/* size: 88, cachelines: 2, members: 11 */
	/* last cacheline: 24 bytes */
};
struct MouseInfo {
	char *                     name;                 /*     0     8 */
	int64_t                    index;                /*     8     8 */
	_Bool                      current;              /*    16     1 */
	_Bool                      absolute;             /*    17     1 */

	/* size: 24, cachelines: 1, members: 4 */
	/* padding: 6 */
	/* last cacheline: 24 bytes */
};
struct MouseInfoList {
	MouseInfoList *            next;                 /*     0     8 */
	MouseInfo *                value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct NameInfo {
	_Bool                      has_name;             /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     name;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 9, holes: 1, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct ObjectTypeInfo {
	char *                     name;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct ObjectTypeInfoList {
	ObjectTypeInfoList *       next;                 /*     0     8 */
	ObjectTypeInfo *           value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PciBridgeInfo {
	PciBusInfo *               bus;                  /*     0     8 */
	_Bool                      has_devices;          /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	PciDeviceInfoList *        devices;              /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct PciBusInfo {
	int64_t                    number;               /*     0     8 */
	int64_t                    secondary;            /*     8     8 */
	int64_t                    subordinate;          /*    16     8 */
	PciMemoryRange *           io_range;             /*    24     8 */
	PciMemoryRange *           memory_range;         /*    32     8 */
	PciMemoryRange *           prefetchable_range;   /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct PciDeviceClass {
	_Bool                      has_desc;             /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     desc;                 /*     8     8 */
	int64_t                    q_class;              /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct PciDeviceId {
	int64_t                    device;               /*     0     8 */
	int64_t                    vendor;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PciDeviceInfo {
	int64_t                    bus;                  /*     0     8 */
	int64_t                    slot;                 /*     8     8 */
	int64_t                    function;             /*    16     8 */
	PciDeviceClass *           class_info;           /*    24     8 */
	PciDeviceId *              id;                   /*    32     8 */
	_Bool                      has_irq;              /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    irq;                  /*    48     8 */
	char *                     qdev_id;              /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_pci_bridge;       /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	PciBridgeInfo *            pci_bridge;           /*    72     8 */
	PciMemoryRegionList *      regions;              /*    80     8 */

	/* size: 88, cachelines: 2, members: 11 */
	/* sum members: 74, holes: 2, sum holes: 14 */
	/* last cacheline: 24 bytes */
};
struct PciDeviceInfoList {
	PciDeviceInfoList *        next;                 /*     0     8 */
	PciDeviceInfo *            value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PciInfo {
	int64_t                    bus;                  /*     0     8 */
	PciDeviceInfoList *        devices;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PciInfoList {
	PciInfoList *              next;                 /*     0     8 */
	PciInfo *                  value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PciMemoryRange {
	int64_t                    base;                 /*     0     8 */
	int64_t                    limit;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PciMemoryRegion {
	int64_t                    bar;                  /*     0     8 */
	char *                     type;                 /*     8     8 */
	int64_t                    address;              /*    16     8 */
	int64_t                    size;                 /*    24     8 */
	_Bool                      has_prefetch;         /*    32     1 */
	_Bool                      prefetch;             /*    33     1 */
	_Bool                      has_mem_type_64;      /*    34     1 */
	_Bool                      mem_type_64;          /*    35     1 */

	/* size: 40, cachelines: 1, members: 8 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct PciMemoryRegionList {
	PciMemoryRegionList *      next;                 /*     0     8 */
	PciMemoryRegion *          value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct RockerOfDpaFlow {
	uint64_t                   cookie;               /*     0     8 */
	uint64_t                   hits;                 /*     8     8 */
	RockerOfDpaFlowKey *       key;                  /*    16     8 */
	RockerOfDpaFlowMask *      mask;                 /*    24     8 */
	RockerOfDpaFlowAction *    action;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct RockerOfDpaFlowAction {
	_Bool                      has_goto_tbl;         /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   goto_tbl;             /*     4     4 */
	_Bool                      has_group_id;         /*     8     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   group_id;             /*    12     4 */
	_Bool                      has_tunnel_lport;     /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   tunnel_lport;         /*    20     4 */
	_Bool                      has_vlan_id;          /*    24     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   vlan_id;              /*    26     2 */
	_Bool                      has_new_vlan_id;      /*    28     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   new_vlan_id;          /*    30     2 */
	_Bool                      has_out_pport;        /*    32     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   out_pport;            /*    36     4 */

	/* size: 40, cachelines: 1, members: 12 */
	/* sum members: 26, holes: 6, sum holes: 14 */
	/* last cacheline: 40 bytes */
};
struct RockerOfDpaFlowKey {
	uint32_t                   priority;             /*     0     4 */
	uint32_t                   tbl_id;               /*     4     4 */
	_Bool                      has_in_pport;         /*     8     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   in_pport;             /*    12     4 */
	_Bool                      has_tunnel_id;        /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   tunnel_id;            /*    20     4 */
	_Bool                      has_vlan_id;          /*    24     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   vlan_id;              /*    26     2 */
	_Bool                      has_eth_type;         /*    28     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   eth_type;             /*    30     2 */
	_Bool                      has_eth_src;          /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     eth_src;              /*    40     8 */
	_Bool                      has_eth_dst;          /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     eth_dst;              /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_ip_proto;         /*    64     1 */
	uint8_t                    ip_proto;             /*    65     1 */
	_Bool                      has_ip_tos;           /*    66     1 */
	uint8_t                    ip_tos;               /*    67     1 */
	_Bool                      has_ip_dst;           /*    68     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     ip_dst;               /*    72     8 */

	/* size: 80, cachelines: 2, members: 20 */
	/* sum members: 55, holes: 7, sum holes: 25 */
	/* last cacheline: 16 bytes */
};
struct RockerOfDpaFlowList {
	RockerOfDpaFlowList *      next;                 /*     0     8 */
	RockerOfDpaFlow *          value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct RockerOfDpaFlowMask {
	_Bool                      has_in_pport;         /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   in_pport;             /*     4     4 */
	_Bool                      has_tunnel_id;        /*     8     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   tunnel_id;            /*    12     4 */
	_Bool                      has_vlan_id;          /*    16     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   vlan_id;              /*    18     2 */
	_Bool                      has_eth_src;          /*    20     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     eth_src;              /*    24     8 */
	_Bool                      has_eth_dst;          /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     eth_dst;              /*    40     8 */
	_Bool                      has_ip_proto;         /*    48     1 */
	uint8_t                    ip_proto;             /*    49     1 */
	_Bool                      has_ip_tos;           /*    50     1 */
	uint8_t                    ip_tos;               /*    51     1 */

	/* size: 56, cachelines: 1, members: 14 */
	/* sum members: 35, holes: 5, sum holes: 17 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct RockerOfDpaGroup {
	uint32_t                   id;                   /*     0     4 */
	uint8_t                    type;                 /*     4     1 */
	_Bool                      has_vlan_id;          /*     5     1 */
	uint16_t                   vlan_id;              /*     6     2 */
	_Bool                      has_pport;            /*     8     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   pport;                /*    12     4 */
	_Bool                      has_index;            /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   index;                /*    20     4 */
	_Bool                      has_out_pport;        /*    24     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   out_pport;            /*    28     4 */
	_Bool                      has_group_id;         /*    32     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   group_id;             /*    36     4 */
	_Bool                      has_set_vlan_id;      /*    40     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   set_vlan_id;          /*    42     2 */
	_Bool                      has_pop_vlan;         /*    44     1 */
	uint8_t                    pop_vlan;             /*    45     1 */
	_Bool                      has_group_ids;        /*    46     1 */

	/* XXX 1 byte hole, try to pack */

	uint32List *               group_ids;            /*    48     8 */
	_Bool                      has_set_eth_src;      /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     set_eth_src;          /*    64     8 */
	_Bool                      has_set_eth_dst;      /*    72     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     set_eth_dst;          /*    80     8 */
	_Bool                      has_ttl_check;        /*    88     1 */
	uint8_t                    ttl_check;            /*    89     1 */

	/* size: 96, cachelines: 2, members: 24 */
	/* sum members: 62, holes: 8, sum holes: 28 */
	/* padding: 6 */
	/* last cacheline: 32 bytes */
};
struct RockerOfDpaGroupList {
	RockerOfDpaGroupList *     next;                 /*     0     8 */
	RockerOfDpaGroup *         value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct RockerPort {
	char *                     name;                 /*     0     8 */
	_Bool                      enabled;              /*     8     1 */
	_Bool                      link_up;              /*     9     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   speed;                /*    12     4 */
	RockerPortDuplex           duplex;               /*    16     4 */
	RockerPortAutoneg          autoneg;              /*    20     4 */

	/* size: 24, cachelines: 1, members: 6 */
	/* sum members: 22, holes: 1, sum holes: 2 */
	/* last cacheline: 24 bytes */
};
struct RockerPortList {
	RockerPortList *           next;                 /*     0     8 */
	RockerPort *               value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct RockerSwitch {
	char *                     name;                 /*     0     8 */
	uint64_t                   id;                   /*     8     8 */
	uint32_t                   ports;                /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct RxFilterInfoList {
	RxFilterInfoList *         next;                 /*     0     8 */
	RxFilterInfo *             value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct SpiceChannel {
	char *                     host;                 /*     0     8 */
	char *                     port;                 /*     8     8 */
	NetworkAddressFamily       family;               /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    connection_id;        /*    24     8 */
	int64_t                    channel_type;         /*    32     8 */
	int64_t                    channel_id;           /*    40     8 */
	_Bool                      tls;                  /*    48     1 */

	/* size: 56, cachelines: 1, members: 7 */
	/* sum members: 45, holes: 1, sum holes: 4 */
	/* padding: 7 */
	/* last cacheline: 56 bytes */
};
struct SpiceChannelList {
	SpiceChannelList *         next;                 /*     0     8 */
	SpiceChannel *             value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct SpiceInfo {
	_Bool                      enabled;              /*     0     1 */
	_Bool                      migrated;             /*     1     1 */
	_Bool                      has_host;             /*     2     1 */

	/* XXX 5 bytes hole, try to pack */

	char *                     host;                 /*     8     8 */
	_Bool                      has_port;             /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    port;                 /*    24     8 */
	_Bool                      has_tls_port;         /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    tls_port;             /*    40     8 */
	_Bool                      has_auth;             /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     auth;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_compiled_version; /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     compiled_version;     /*    72     8 */
	SpiceQueryMouseMode        mouse_mode;           /*    80     4 */
	_Bool                      has_channels;         /*    84     1 */

	/* XXX 3 bytes hole, try to pack */

	SpiceChannelList *         channels;             /*    88     8 */

	/* size: 96, cachelines: 2, members: 15 */
	/* sum members: 60, holes: 6, sum holes: 36 */
	/* last cacheline: 32 bytes */
};
struct UuidInfo {
	char *                     UUID;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct VersionInfo {
	VersionTriple *            qemu;                 /*     0     8 */
	char *                     package;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct VersionTriple {
	int64_t                    major;                /*     0     8 */
	int64_t                    minor;                /*     8     8 */
	int64_t                    micro;                /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct VncBasicInfo {
	char *                     host;                 /*     0     8 */
	char *                     service;              /*     8     8 */
	NetworkAddressFamily       family;               /*    16     4 */
	_Bool                      websocket;            /*    20     1 */

	/* size: 24, cachelines: 1, members: 4 */
	/* padding: 3 */
	/* last cacheline: 24 bytes */
};
struct VncBasicInfoList {
	VncBasicInfoList *         next;                 /*     0     8 */
	VncBasicInfo *             value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct VncClientInfo {
	char *                     host;                 /*     0     8 */
	char *                     service;              /*     8     8 */
	NetworkAddressFamily       family;               /*    16     4 */
	_Bool                      websocket;            /*    20     1 */
	_Bool                      has_x509_dname;       /*    21     1 */

	/* XXX 2 bytes hole, try to pack */

	char *                     x509_dname;           /*    24     8 */
	_Bool                      has_sasl_username;    /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     sasl_username;        /*    40     8 */

	/* size: 48, cachelines: 1, members: 8 */
	/* sum members: 39, holes: 2, sum holes: 9 */
	/* last cacheline: 48 bytes */
};
struct VncClientInfoList {
	VncClientInfoList *        next;                 /*     0     8 */
	VncClientInfo *            value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct VncInfo {
	_Bool                      enabled;              /*     0     1 */
	_Bool                      has_host;             /*     1     1 */

	/* XXX 6 bytes hole, try to pack */

	char *                     host;                 /*     8     8 */
	_Bool                      has_family;           /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	NetworkAddressFamily       family;               /*    20     4 */
	_Bool                      has_service;          /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     service;              /*    32     8 */
	_Bool                      has_auth;             /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     auth;                 /*    48     8 */
	_Bool                      has_clients;          /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	VncClientInfoList *        clients;              /*    64     8 */

	/* size: 72, cachelines: 2, members: 11 */
	/* sum members: 42, holes: 5, sum holes: 30 */
	/* last cacheline: 8 bytes */
};
struct VncInfo2 {
	char *                     id;                   /*     0     8 */
	VncBasicInfoList *         server;               /*     8     8 */
	VncClientInfoList *        clients;              /*    16     8 */
	VncPrimaryAuth             auth;                 /*    24     4 */
	_Bool                      has_vencrypt;         /*    28     1 */

	/* XXX 3 bytes hole, try to pack */

	VncVencryptSubAuth         vencrypt;             /*    32     4 */
	_Bool                      has_display;          /*    36     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     display;              /*    40     8 */

	/* size: 48, cachelines: 1, members: 8 */
	/* sum members: 42, holes: 2, sum holes: 6 */
	/* last cacheline: 48 bytes */
};
struct VncInfo2List {
	VncInfo2List *             next;                 /*     0     8 */
	VncInfo2 *                 value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct XBZRLECacheStats {
	int64_t                    cache_size;           /*     0     8 */
	int64_t                    bytes;                /*     8     8 */
	int64_t                    pages;                /*    16     8 */
	int64_t                    cache_miss;           /*    24     8 */
	double                     cache_miss_rate;      /*    32     8 */
	int64_t                    overflow;             /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct q_obj_InputBtnEvent_wrapper {
	InputBtnEvent *            data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_InputKeyEvent_wrapper {
	InputKeyEvent *            data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_InputMoveEvent_wrapper {
	InputMoveEvent *           data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_QKeyCode_wrapper {
	QKeyCode                   data;                 /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct q_obj_add_fd_arg {
	_Bool                      has_fdset_id;         /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    fdset_id;             /*     8     8 */
	_Bool                      has_opaque;           /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     opaque;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 18, holes: 2, sum holes: 14 */
	/* last cacheline: 32 bytes */
};
struct q_obj_add_client_arg {
	char *                     protocol;             /*     0     8 */
	char *                     fdname;               /*     8     8 */
	_Bool                      has_skipauth;         /*    16     1 */
	_Bool                      skipauth;             /*    17     1 */
	_Bool                      has_tls;              /*    18     1 */
	_Bool                      tls;                  /*    19     1 */

	/* size: 24, cachelines: 1, members: 6 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct q_obj_balloon_arg {
	int64_t                    value;                /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_block_commit_arg {
	_Bool                      has_job_id;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     job_id;               /*     8     8 */
	char *                     device;               /*    16     8 */
	_Bool                      has_base;             /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     base;                 /*    32     8 */
	_Bool                      has_top;              /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     top;                  /*    48     8 */
	_Bool                      has_backing_file;     /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     backing_file;         /*    64     8 */
	_Bool                      has_speed;            /*    72     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    speed;                /*    80     8 */

	/* size: 88, cachelines: 2, members: 11 */
	/* sum members: 53, holes: 5, sum holes: 35 */
	/* last cacheline: 24 bytes */
};
struct q_obj_block_job_cancel_arg {
	char *                     device;               /*     0     8 */
	_Bool                      has_force;            /*     8     1 */
	_Bool                      force;                /*     9     1 */

	/* size: 16, cachelines: 1, members: 3 */
	/* padding: 6 */
	/* last cacheline: 16 bytes */
};
struct q_obj_block_job_complete_arg {
	char *                     device;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_block_job_pause_arg {
	char *                     device;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_block_job_resume_arg {
	char *                     device;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_block_job_set_speed_arg {
	char *                     device;               /*     0     8 */
	int64_t                    speed;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_block_set_write_threshold_arg {
	char *                     node_name;            /*     0     8 */
	uint64_t                   write_threshold;      /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_block_stream_arg {
	_Bool                      has_job_id;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     job_id;               /*     8     8 */
	char *                     device;               /*    16     8 */
	_Bool                      has_base;             /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     base;                 /*    32     8 */
	_Bool                      has_base_node;        /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     base_node;            /*    48     8 */
	_Bool                      has_backing_file;     /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     backing_file;         /*    64     8 */
	_Bool                      has_speed;            /*    72     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    speed;                /*    80     8 */
	_Bool                      has_on_error;         /*    88     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockdevOnError            on_error;             /*    92     4 */

	/* size: 96, cachelines: 2, members: 13 */
	/* sum members: 58, holes: 6, sum holes: 38 */
	/* last cacheline: 32 bytes */
};
struct q_obj_block_passwd_arg {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	_Bool                      has_node_name;        /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     node_name;            /*    24     8 */
	char *                     password;             /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 26, holes: 2, sum holes: 14 */
	/* last cacheline: 40 bytes */
};
struct q_obj_block_resize_arg {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	_Bool                      has_node_name;        /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     node_name;            /*    24     8 */
	int64_t                    size;                 /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 26, holes: 2, sum holes: 14 */
	/* last cacheline: 40 bytes */
};
struct q_obj_blockdev_change_medium_arg {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	_Bool                      has_id;               /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     id;                   /*    24     8 */
	char *                     filename;             /*    32     8 */
	_Bool                      has_format;           /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     format;               /*    48     8 */
	_Bool                      has_read_only_mode;   /*    56     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockdevChangeReadOnlyMode read_only_mode;       /*    60     4 */

	/* size: 64, cachelines: 1, members: 9 */
	/* sum members: 40, holes: 4, sum holes: 24 */
};
struct q_obj_blockdev_close_tray_arg {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	_Bool                      has_id;               /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     id;                   /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 18, holes: 2, sum holes: 14 */
	/* last cacheline: 32 bytes */
};
struct q_obj_blockdev_mirror_arg {
	_Bool                      has_job_id;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     job_id;               /*     8     8 */
	char *                     device;               /*    16     8 */
	char *                     target;               /*    24     8 */
	_Bool                      has_replaces;         /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     replaces;             /*    40     8 */
	MirrorSyncMode             sync;                 /*    48     4 */
	_Bool                      has_speed;            /*    52     1 */

	/* XXX 3 bytes hole, try to pack */

	int64_t                    speed;                /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_granularity;      /*    64     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   granularity;          /*    68     4 */
	_Bool                      has_buf_size;         /*    72     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    buf_size;             /*    80     8 */
	_Bool                      has_on_source_error;  /*    88     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockdevOnError            on_source_error;      /*    92     4 */
	_Bool                      has_on_target_error;  /*    96     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockdevOnError            on_target_error;      /*   100     4 */

	/* size: 104, cachelines: 2, members: 17 */
	/* sum members: 71, holes: 7, sum holes: 33 */
	/* last cacheline: 40 bytes */
};
struct q_obj_blockdev_open_tray_arg {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	_Bool                      has_id;               /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     id;                   /*    24     8 */
	_Bool                      has_force;            /*    32     1 */
	_Bool                      force;                /*    33     1 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 20, holes: 2, sum holes: 14 */
	/* padding: 6 */
	/* last cacheline: 40 bytes */
};
struct q_obj_blockdev_snapshot_delete_internal_sync_arg {
	char *                     device;               /*     0     8 */
	_Bool                      has_id;               /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     id;                   /*    16     8 */
	_Bool                      has_name;             /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     name;                 /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 26, holes: 2, sum holes: 14 */
	/* last cacheline: 40 bytes */
};
struct q_obj_change_arg {
	char *                     device;               /*     0     8 */
	char *                     target;               /*     8     8 */
	_Bool                      has_arg;              /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     arg;                  /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 25, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct q_obj_change_backing_file_arg {
	char *                     device;               /*     0     8 */
	char *                     image_node_name;      /*     8     8 */
	char *                     backing_file;         /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct q_obj_change_vnc_password_arg {
	char *                     password;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_chardev_add_arg {
	char *                     id;                   /*     0     8 */
	ChardevBackend *           backend;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_chardev_remove_arg {
	char *                     id;                   /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_client_migrate_info_arg {
	char *                     protocol;             /*     0     8 */
	char *                     hostname;             /*     8     8 */
	_Bool                      has_port;             /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    port;                 /*    24     8 */
	_Bool                      has_tls_port;         /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    tls_port;             /*    40     8 */
	_Bool                      has_cert_subject;     /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     cert_subject;         /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
	/* sum members: 43, holes: 3, sum holes: 21 */
};
struct q_obj_closefd_arg {
	char *                     fdname;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_cpu_add_arg {
	int64_t                    id;                   /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_cpu_arg {
	int64_t                    index;                /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_device_list_properties_arg {
	char *                     q_typename;           /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_device_del_arg {
	char *                     id;                   /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_dump_guest_memory_arg {
	_Bool                      paging;               /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     protocol;             /*     8     8 */
	_Bool                      has_detach;           /*    16     1 */
	_Bool                      detach;               /*    17     1 */
	_Bool                      has_begin;            /*    18     1 */

	/* XXX 5 bytes hole, try to pack */

	int64_t                    begin;                /*    24     8 */
	_Bool                      has_length;           /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    length;               /*    40     8 */
	_Bool                      has_format;           /*    48     1 */

	/* XXX 3 bytes hole, try to pack */

	DumpGuestMemoryFormat      format;               /*    52     4 */

	/* size: 56, cachelines: 1, members: 10 */
	/* sum members: 34, holes: 4, sum holes: 22 */
	/* last cacheline: 56 bytes */
};
struct q_obj_dump_skeys_arg {
	char *                     filename;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_eject_arg {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	_Bool                      has_id;               /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     id;                   /*    24     8 */
	_Bool                      has_force;            /*    32     1 */
	_Bool                      force;                /*    33     1 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 20, holes: 2, sum holes: 14 */
	/* padding: 6 */
	/* last cacheline: 40 bytes */
};
struct q_obj_expire_password_arg {
	char *                     protocol;             /*     0     8 */
	char *                     time;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_getfd_arg {
	char *                     fdname;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_human_monitor_command_arg {
	char *                     command_line;         /*     0     8 */
	_Bool                      has_cpu_index;        /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    cpu_index;            /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct q_obj_input_send_event_arg {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	_Bool                      has_head;             /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    head;                 /*    24     8 */
	InputEventList *           events;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 26, holes: 2, sum holes: 14 */
	/* last cacheline: 40 bytes */
};
struct q_obj_int_wrapper {
	int64_t                    data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_memsave_arg {
	int64_t                    val;                  /*     0     8 */
	int64_t                    size;                 /*     8     8 */
	char *                     filename;             /*    16     8 */
	_Bool                      has_cpu_index;        /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    cpu_index;            /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 33, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
struct q_obj_migrate_arg {
	char *                     uri;                  /*     0     8 */
	_Bool                      has_blk;              /*     8     1 */
	_Bool                      blk;                  /*     9     1 */
	_Bool                      has_inc;              /*    10     1 */
	_Bool                      inc;                  /*    11     1 */
	_Bool                      has_detach;           /*    12     1 */
	_Bool                      detach;               /*    13     1 */

	/* size: 16, cachelines: 1, members: 7 */
	/* padding: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_migrate_incoming_arg {
	char *                     uri;                  /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_migrate_set_cache_size_arg {
	int64_t                    value;                /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_migrate_set_capabilities_arg {
	MigrationCapabilityStatusList * capabilities;    /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_migrate_set_downtime_arg {
	double                     value;                /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_migrate_set_speed_arg {
	int64_t                    value;                /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_nbd_server_add_arg {
	char *                     device;               /*     0     8 */
	_Bool                      has_writable;         /*     8     1 */
	_Bool                      writable;             /*     9     1 */

	/* size: 16, cachelines: 1, members: 3 */
	/* padding: 6 */
	/* last cacheline: 16 bytes */
};
struct q_obj_nbd_server_start_arg {
	SocketAddress *            addr;                 /*     0     8 */
	_Bool                      has_tls_creds;        /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     tls_creds;            /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct q_obj_netdev_del_arg {
	char *                     id;                   /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_object_add_arg {
	char *                     qom_type;             /*     0     8 */
	char *                     id;                   /*     8     8 */
	_Bool                      has_props;            /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	QObject *                  props;                /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 25, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct q_obj_object_del_arg {
	char *                     id;                   /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_pmemsave_arg {
	int64_t                    val;                  /*     0     8 */
	int64_t                    size;                 /*     8     8 */
	char *                     filename;             /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct q_obj_qom_get_arg {
	char *                     path;                 /*     0     8 */
	char *                     property;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_qom_list_arg {
	char *                     path;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_qom_list_types_arg {
	_Bool                      has_implements;       /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     implements;           /*     8     8 */
	_Bool                      has_abstract;         /*    16     1 */
	_Bool                      abstract;             /*    17     1 */

	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 11, holes: 1, sum holes: 7 */
	/* padding: 6 */
	/* last cacheline: 24 bytes */
};
struct q_obj_qom_set_arg {
	char *                     path;                 /*     0     8 */
	char *                     property;             /*     8     8 */
	QObject *                  value;                /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct q_obj_query_blockstats_arg {
	_Bool                      has_query_nodes;      /*     0     1 */
	_Bool                      query_nodes;          /*     1     1 */

	/* size: 2, cachelines: 1, members: 2 */
	/* last cacheline: 2 bytes */
};
struct q_obj_query_command_line_options_arg {
	_Bool                      has_option;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     option;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 9, holes: 1, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct q_obj_query_cpu_model_baseline_arg {
	CpuModelInfo *             modela;               /*     0     8 */
	CpuModelInfo *             modelb;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_query_cpu_model_comparison_arg {
	CpuModelInfo *             modela;               /*     0     8 */
	CpuModelInfo *             modelb;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_query_cpu_model_expansion_arg {
	CpuModelExpansionType      type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	CpuModelInfo *             model;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct q_obj_query_rocker_arg {
	char *                     name;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_query_rocker_of_dpa_flows_arg {
	char *                     name;                 /*     0     8 */
	_Bool                      has_tbl_id;           /*     8     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   tbl_id;               /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* sum members: 13, holes: 1, sum holes: 3 */
	/* last cacheline: 16 bytes */
};
struct q_obj_query_rocker_of_dpa_groups_arg {
	char *                     name;                 /*     0     8 */
	_Bool                      has_type;             /*     8     1 */
	uint8_t                    type;                 /*     9     1 */

	/* size: 16, cachelines: 1, members: 3 */
	/* padding: 6 */
	/* last cacheline: 16 bytes */
};
struct q_obj_query_rocker_ports_arg {
	char *                     name;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_query_rx_filter_arg {
	_Bool                      has_name;             /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     name;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 9, holes: 1, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct q_obj_remove_fd_arg {
	int64_t                    fdset_id;             /*     0     8 */
	_Bool                      has_fd;               /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    fd;                   /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct q_obj_ringbuf_read_arg {
	char *                     device;               /*     0     8 */
	int64_t                    size;                 /*     8     8 */
	_Bool                      has_format;           /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	DataFormat                 format;               /*    20     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 21, holes: 1, sum holes: 3 */
	/* last cacheline: 24 bytes */
};
struct q_obj_ringbuf_write_arg {
	char *                     device;               /*     0     8 */
	char *                     data;                 /*     8     8 */
	_Bool                      has_format;           /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	DataFormat                 format;               /*    20     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 21, holes: 1, sum holes: 3 */
	/* last cacheline: 24 bytes */
};
struct q_obj_screendump_arg {
	char *                     filename;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_send_key_arg {
	KeyValueList *             keys;                 /*     0     8 */
	_Bool                      has_hold_time;        /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    hold_time;            /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct q_obj_set_link_arg {
	char *                     name;                 /*     0     8 */
	_Bool                      up;                   /*     8     1 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct q_obj_set_password_arg {
	char *                     protocol;             /*     0     8 */
	char *                     password;             /*     8     8 */
	_Bool                      has_connected;        /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     connected;            /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 25, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct q_obj_trace_event_get_state_arg {
	char *                     name;                 /*     0     8 */
	_Bool                      has_vcpu;             /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    vcpu;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct q_obj_trace_event_set_state_arg {
	char *                     name;                 /*     0     8 */
	_Bool                      enable;               /*     8     1 */
	_Bool                      has_ignore_unavailable; /*     9     1 */
	_Bool                      ignore_unavailable;   /*    10     1 */
	_Bool                      has_vcpu;             /*    11     1 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    vcpu;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 6 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct q_obj_transaction_arg {
	TransactionActionList *    actions;              /*     0     8 */
	_Bool                      has_properties;       /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	TransactionProperties *    properties;           /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct q_obj_x_blockdev_change_arg {
	char *                     parent;               /*     0     8 */
	_Bool                      has_child;            /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     child;                /*    16     8 */
	_Bool                      has_node;             /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     node;                 /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 26, holes: 2, sum holes: 14 */
	/* last cacheline: 40 bytes */
};
struct q_obj_x_blockdev_del_arg {
	char *                     node_name;            /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_x_blockdev_insert_medium_arg {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	_Bool                      has_id;               /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     id;                   /*    24     8 */
	char *                     node_name;            /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 26, holes: 2, sum holes: 14 */
	/* last cacheline: 40 bytes */
};
struct q_obj_x_blockdev_remove_medium_arg {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	_Bool                      has_id;               /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     id;                   /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 18, holes: 2, sum holes: 14 */
	/* last cacheline: 32 bytes */
};
struct q_obj_xen_load_devices_state_arg {
	char *                     filename;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_xen_save_devices_state_arg {
	char *                     filename;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_xen_set_global_dirty_log_arg {
	_Bool                      enable;               /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
};
struct InterruptStatsProvider {
	Object                     parent;               /*     0    40 */

	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
struct InterruptStatsProviderClass {
	InterfaceClass             parent;               /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	_Bool                      (*get_statistics)(InterruptStatsProvider *, uint64_t * *, unsigned int *); /*   112     8 */
	void                       (*print_info)(InterruptStatsProvider *, Monitor *); /*   120     8 */

	/* size: 128, cachelines: 2, members: 3 */
};
struct HMPMigrationStatus {
	QEMUTimer *                timer;                /*     0     8 */
	Monitor *                  mon;                  /*     8     8 */
	_Bool                      is_block_migration;   /*    16     1 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct qemu_work_item {
	struct qemu_work_item *    next;                 /*     0     8 */
	run_on_cpu_func            func;                 /*     8     8 */
	run_on_cpu_data            data;                 /*    16     8 */
	_Bool                      free;                 /*    24     1 */
	_Bool                      exclusive;            /*    25     1 */
	_Bool                      done;                 /*    26     1 */

	/* size: 32, cachelines: 1, members: 6 */
	/* padding: 5 */
	/* last cacheline: 32 bytes */
};
struct AudioState {
	struct audio_driver *      drv;                  /*     0     8 */
	void *                     drv_opaque;           /*     8     8 */
	QEMUTimer *                ts;                   /*    16     8 */
	struct card_listhead       card_head;            /*    24     8 */
	struct hw_in_listhead      hw_head_in;           /*    32     8 */
	struct hw_out_listhead     hw_head_out;          /*    40     8 */
	struct cap_listhead        cap_head;             /*    48     8 */
	int                        nb_hw_voices_out;     /*    56     4 */
	int                        nb_hw_voices_in;      /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        vm_running;           /*    64     4 */

	/* size: 72, cachelines: 2, members: 10 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
struct audsettings {
	int                        freq;                 /*     0     4 */
	int                        nchannels;            /*     4     4 */
	audfmt_e                   fmt;                  /*     8     4 */
	int                        endianness;           /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct audio_capture_ops {
	void                       (*notify)(void *, audcnotification_e); /*     0     8 */
	void                       (*capture)(void *, void *, int); /*     8     8 */
	void                       (*destroy)(void *);   /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct SWVoiceOut {
	QEMUSoundCard *            card;                 /*     0     8 */
	struct audio_pcm_info      info;                 /*     8    32 */
	t_sample *                 conv;                 /*    40     8 */
	int64_t                    ratio;                /*    48     8 */
	struct st_sample *         buf;                  /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void *                     rate;                 /*    64     8 */
	int                        total_hw_samples_mixed; /*    72     4 */
	int                        active;               /*    76     4 */
	int                        empty;                /*    80     4 */

	/* XXX 4 bytes hole, try to pack */

	HWVoiceOut *               hw;                   /*    88     8 */
	char *                     name;                 /*    96     8 */
	struct mixeng_volume       vol;                  /*   104    24 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	struct audio_callback      callback;             /*   128    16 */
	struct {
		struct SWVoiceOut * le_next;             /*   144     8 */
		struct SWVoiceOut * * le_prev;           /*   152     8 */
	} entries;                                       /*   144    16 */

	/* size: 160, cachelines: 3, members: 14 */
	/* sum members: 156, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct CaptureVoiceOut {
	HWVoiceOut                 hw;                   /*     0   136 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	void *                     buf;                  /*   136     8 */
	struct cb_listhead         cb_head;              /*   144     8 */
	struct {
		struct CaptureVoiceOut * le_next;        /*   152     8 */
		struct CaptureVoiceOut * * le_prev;      /*   160     8 */
	} entries;                                       /*   152    16 */

	/* size: 168, cachelines: 3, members: 4 */
	/* last cacheline: 40 bytes */
};
struct SWVoiceIn {
	QEMUSoundCard *            card;                 /*     0     8 */
	int                        active;               /*     8     4 */
	struct audio_pcm_info      info;                 /*    12    32 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    ratio;                /*    48     8 */
	void *                     rate;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        total_hw_samples_acquired; /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	struct st_sample *         buf;                  /*    72     8 */
	f_sample *                 clip;                 /*    80     8 */
	HWVoiceIn *                hw;                   /*    88     8 */
	char *                     name;                 /*    96     8 */
	struct mixeng_volume       vol;                  /*   104    24 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	struct audio_callback      callback;             /*   128    16 */
	struct {
		struct SWVoiceIn * le_next;              /*   144     8 */
		struct SWVoiceIn * * le_prev;            /*   152     8 */
	} entries;                                       /*   144    16 */

	/* size: 160, cachelines: 3, members: 13 */
	/* sum members: 152, holes: 2, sum holes: 8 */
	/* last cacheline: 32 bytes */
};
struct QEMUSoundCard {
	char *                     name;                 /*     0     8 */
	struct {
		struct QEMUSoundCard * le_next;          /*     8     8 */
		struct QEMUSoundCard * * le_prev;        /*    16     8 */
	} entries;                                       /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
struct QEMUAudioTimeStamp {
	uint64_t                   old_ts;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct mixeng_volume {
	int                        mute;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    r;                    /*     8     8 */
	int64_t                    l;                    /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct st_sample {
	int64_t                    l;                    /*     0     8 */
	int64_t                    r;                    /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct audio_option {
	const char  *              name;                 /*     0     8 */
	audio_option_tag_e         tag;                  /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     valp;                 /*    16     8 */
	const char  *              descr;                /*    24     8 */
	int *                      overriddenp;          /*    32     8 */
	int                        overridden;           /*    40     4 */

	/* size: 48, cachelines: 1, members: 6 */
	/* sum members: 40, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct audio_callback {
	void *                     opaque;               /*     0     8 */
	audio_callback_fn          fn;                   /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct audio_pcm_info {
	int                        bits;                 /*     0     4 */
	int                        sign;                 /*     4     4 */
	int                        freq;                 /*     8     4 */
	int                        nchannels;            /*    12     4 */
	int                        align;                /*    16     4 */
	int                        shift;                /*    20     4 */
	int                        bytes_per_second;     /*    24     4 */
	int                        swap_endianness;      /*    28     4 */

	/* size: 32, cachelines: 1, members: 8 */
	/* last cacheline: 32 bytes */
};
struct SWVoiceCap {
	SWVoiceOut                 sw;                   /*     0   160 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	CaptureVoiceOut *          cap;                  /*   160     8 */
	struct {
		struct SWVoiceCap * le_next;             /*   168     8 */
		struct SWVoiceCap * * le_prev;           /*   176     8 */
	} entries;                                       /*   168    16 */

	/* size: 184, cachelines: 3, members: 3 */
	/* last cacheline: 56 bytes */
};
struct sw_out_listhead {
	struct SWVoiceOut *        lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct sw_cap_listhead {
	struct SWVoiceCap *        lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct HWVoiceOut {
	int                        enabled;              /*     0     4 */
	int                        poll_mode;            /*     4     4 */
	int                        pending_disable;      /*     8     4 */
	struct audio_pcm_info      info;                 /*    12    32 */

	/* XXX 4 bytes hole, try to pack */

	f_sample *                 clip;                 /*    48     8 */
	int                        rpos;                 /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	uint64_t                   ts_helper;            /*    64     8 */
	struct st_sample *         mix_buf;              /*    72     8 */
	int                        samples;              /*    80     4 */

	/* XXX 4 bytes hole, try to pack */

	struct sw_out_listhead     sw_head;              /*    88     8 */
	struct sw_cap_listhead     cap_head;             /*    96     8 */
	int                        ctl_caps;             /*   104     4 */

	/* XXX 4 bytes hole, try to pack */

	struct audio_pcm_ops *     pcm_ops;              /*   112     8 */
	struct {
		struct HWVoiceOut * le_next;             /*   120     8 */
		/* --- cacheline 2 boundary (128 bytes) --- */
		struct HWVoiceOut * * le_prev;           /*   128     8 */
	} entries;                                       /*   120    16 */

	/* size: 136, cachelines: 3, members: 14 */
	/* sum members: 120, holes: 4, sum holes: 16 */
	/* last cacheline: 8 bytes */
};
struct audio_pcm_ops {
	int                        (*init_out)(HWVoiceOut *, struct audsettings *, void *); /*     0     8 */
	void                       (*fini_out)(HWVoiceOut *); /*     8     8 */
	int                        (*run_out)(HWVoiceOut *, int); /*    16     8 */
	int                        (*write)(SWVoiceOut *, void *, int); /*    24     8 */
	int                        (*ctl_out)(HWVoiceOut *, int, ...); /*    32     8 */
	int                        (*init_in)(HWVoiceIn *, struct audsettings *, void *); /*    40     8 */
	void                       (*fini_in)(HWVoiceIn *); /*    48     8 */
	int                        (*run_in)(HWVoiceIn *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        (*read)(SWVoiceIn *, void *, int); /*    64     8 */
	int                        (*ctl_in)(HWVoiceIn *, int, ...); /*    72     8 */

	/* size: 80, cachelines: 2, members: 10 */
	/* last cacheline: 16 bytes */
};
struct sw_in_listhead {
	struct SWVoiceIn *         lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct HWVoiceIn {
	int                        enabled;              /*     0     4 */
	int                        poll_mode;            /*     4     4 */
	struct audio_pcm_info      info;                 /*     8    32 */
	t_sample *                 conv;                 /*    40     8 */
	int                        wpos;                 /*    48     4 */
	int                        total_samples_captured; /*    52     4 */
	uint64_t                   ts_helper;            /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	struct st_sample *         conv_buf;             /*    64     8 */
	int                        samples;              /*    72     4 */

	/* XXX 4 bytes hole, try to pack */

	struct sw_in_listhead      sw_head;              /*    80     8 */
	int                        ctl_caps;             /*    88     4 */

	/* XXX 4 bytes hole, try to pack */

	struct audio_pcm_ops *     pcm_ops;              /*    96     8 */
	struct {
		struct HWVoiceIn * le_next;              /*   104     8 */
		struct HWVoiceIn * * le_prev;            /*   112     8 */
	} entries;                                       /*   104    16 */

	/* size: 120, cachelines: 2, members: 13 */
	/* sum members: 112, holes: 2, sum holes: 8 */
	/* last cacheline: 56 bytes */
};
struct audio_driver {
	const char  *              name;                 /*     0     8 */
	const char  *              descr;                /*     8     8 */
	struct audio_option *      options;              /*    16     8 */
	void *                     (*init)(void);        /*    24     8 */
	void                       (*fini)(void *);      /*    32     8 */
	struct audio_pcm_ops *     pcm_ops;              /*    40     8 */
	int                        can_be_default;       /*    48     4 */
	int                        max_voices_out;       /*    52     4 */
	int                        max_voices_in;        /*    56     4 */
	int                        voice_size_out;       /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        voice_size_in;        /*    64     4 */
	int                        ctl_caps;             /*    68     4 */

	/* size: 72, cachelines: 2, members: 12 */
	/* last cacheline: 8 bytes */
};
struct capture_callback {
	struct audio_capture_ops   ops;                  /*     0    24 */
	void *                     opaque;               /*    24     8 */
	struct {
		struct capture_callback * le_next;       /*    32     8 */
		struct capture_callback * * le_prev;     /*    40     8 */
	} entries;                                       /*    32    16 */

	/* size: 48, cachelines: 1, members: 3 */
	/* last cacheline: 48 bytes */
};
struct cb_listhead {
	struct capture_callback *  lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct card_listhead {
	struct QEMUSoundCard *     lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct hw_in_listhead {
	struct HWVoiceIn *         lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct hw_out_listhead {
	struct HWVoiceOut *        lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct cap_listhead {
	struct CaptureVoiceOut *   lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct fixed_settings {
	int                        enabled;              /*     0     4 */
	int                        nb_voices;            /*     4     4 */
	int                        greedy;               /*     8     4 */
	struct audsettings         settings;             /*    12    16 */

	/* size: 28, cachelines: 1, members: 4 */
	/* last cacheline: 28 bytes */
};
struct NoVoiceOut {
	HWVoiceOut                 hw;                   /*     0   136 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	int64_t                    old_ticks;            /*   136     8 */

	/* size: 144, cachelines: 3, members: 2 */
	/* last cacheline: 16 bytes */
};
struct NoVoiceIn {
	HWVoiceIn                  hw;                   /*     0   120 */
	/* --- cacheline 1 boundary (64 bytes) was 56 bytes ago --- */
	int64_t                    old_ticks;            /*   120     8 */

	/* size: 128, cachelines: 2, members: 2 */
};
struct WAVVoiceOut {
	HWVoiceOut                 hw;                   /*     0   136 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	FILE *                     f;                    /*   136     8 */
	int64_t                    old_ticks;            /*   144     8 */
	void *                     pcm_buf;              /*   152     8 */
	int                        total_samples;        /*   160     4 */

	/* size: 168, cachelines: 3, members: 5 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct rate {
	uint64_t                   opos;                 /*     0     8 */
	uint64_t                   opos_inc;             /*     8     8 */
	uint32_t                   ipos;                 /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	struct st_sample           ilast;                /*    24    16 */

	/* size: 40, cachelines: 1, members: 4 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct audio_buf_info {
	int                        fragments;            /*     0     4 */
	int                        fragstotal;           /*     4     4 */
	int                        fragsize;             /*     8     4 */
	int                        bytes;                /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct count_info {
	int                        bytes;                /*     0     4 */
	int                        blocks;               /*     4     4 */
	int                        ptr;                  /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
struct OSSConf {
	int                        try_mmap;             /*     0     4 */
	int                        nfrags;               /*     4     4 */
	int                        fragsize;             /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              devpath_out;          /*    16     8 */
	const char  *              devpath_in;           /*    24     8 */
	int                        exclusive;            /*    32     4 */
	int                        policy;               /*    36     4 */

	/* size: 40, cachelines: 1, members: 7 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct OSSVoiceOut {
	HWVoiceOut                 hw;                   /*     0   136 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	void *                     pcm_buf;              /*   136     8 */
	int                        fd;                   /*   144     4 */
	int                        wpos;                 /*   148     4 */
	int                        nfrags;               /*   152     4 */
	int                        fragsize;             /*   156     4 */
	int                        mmapped;              /*   160     4 */
	int                        pending;              /*   164     4 */
	OSSConf *                  conf;                 /*   168     8 */

	/* size: 176, cachelines: 3, members: 9 */
	/* last cacheline: 48 bytes */
};
struct OSSVoiceIn {
	HWVoiceIn                  hw;                   /*     0   120 */
	/* --- cacheline 1 boundary (64 bytes) was 56 bytes ago --- */
	void *                     pcm_buf;              /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int                        fd;                   /*   128     4 */
	int                        nfrags;               /*   132     4 */
	int                        fragsize;             /*   136     4 */

	/* XXX 4 bytes hole, try to pack */

	OSSConf *                  conf;                 /*   144     8 */

	/* size: 152, cachelines: 3, members: 6 */
	/* sum members: 148, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct oss_params {
	int                        freq;                 /*     0     4 */
	audfmt_e                   fmt;                  /*     4     4 */
	int                        nchannels;            /*     8     4 */
	int                        nfrags;               /*    12     4 */
	int                        fragsize;             /*    16     4 */

	/* size: 20, cachelines: 1, members: 5 */
	/* last cacheline: 20 bytes */
};
struct RngRequest {
	EntropyReceiveFunc *       receive_entropy;      /*     0     8 */
	uint8_t *                  data;                 /*     8     8 */
	void *                     opaque;               /*    16     8 */
	size_t                     offset;               /*    24     8 */
	size_t                     size;                 /*    32     8 */
	struct {
		struct RngRequest * sqe_next;            /*    40     8 */
	} next;                                          /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct RngBackendClass {
	ObjectClass                parent_class;         /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	void                       (*request_entropy)(RngBackend *, RngRequest *); /*    96     8 */
	void                       (*opened)(RngBackend *, Error * *); /*   104     8 */

	/* size: 112, cachelines: 2, members: 3 */
	/* last cacheline: 48 bytes */
};
struct RngBackend {
	Object                     parent;               /*     0    40 */
	_Bool                      opened;               /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	struct requests            requests;             /*    48    16 */

	/* size: 64, cachelines: 1, members: 3 */
	/* sum members: 57, holes: 1, sum holes: 7 */
};
struct requests {
	struct RngRequest *        sqh_first;            /*     0     8 */
	struct RngRequest * *      sqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct RngEgd {
	RngBackend                 parent;               /*     0    64 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	CharBackend                chr;                  /*    64    48 */
	char *                     chr_name;             /*   112     8 */

	/* size: 120, cachelines: 2, members: 3 */
	/* last cacheline: 56 bytes */
};
struct RngRandom {
	RngBackend                 parent;               /*     0    64 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        fd;                   /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     filename;             /*    72     8 */

	/* size: 80, cachelines: 2, members: 3 */
	/* sum members: 76, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct QemuInputHandler {
	const char  *              name;                 /*     0     8 */
	uint32_t                   mask;                 /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	QemuInputHandlerEvent      event;                /*    16     8 */
	QemuInputHandlerSync       sync;                 /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct _GThreadPool {
	GFunc                      func;                 /*     0     8 */
	gpointer                   user_data;            /*     8     8 */
	gboolean                   exclusive;            /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct TPMBackendClass {
	ObjectClass                parent_class;         /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	const TPMDriverOps  *      ops;                  /*    96     8 */
	void                       (*opened)(TPMBackend *, Error * *); /*   104     8 */

	/* size: 112, cachelines: 2, members: 3 */
	/* last cacheline: 48 bytes */
};
struct TPMBackendThread {
	GThreadPool *              pool;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct HostMemoryBackendClass {
	ObjectClass                parent_class;         /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	void                       (*alloc)(HostMemoryBackend *, Error * *); /*    96     8 */

	/* size: 104, cachelines: 2, members: 2 */
	/* last cacheline: 40 bytes */
};
struct HostMemoryBackendFile {
	HostMemoryBackend          parent_obj;           /*     0   352 */
	/* --- cacheline 5 boundary (320 bytes) was 32 bytes ago --- */
	_Bool                      share;                /*   352     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     mem_path;             /*   360     8 */

	/* size: 368, cachelines: 6, members: 3 */
	/* sum members: 361, holes: 1, sum holes: 7 */
	/* last cacheline: 48 bytes */
};
struct CryptoDevBackendClass {
	ObjectClass                parent_class;         /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	void                       (*init)(CryptoDevBackend *, Error * *); /*    96     8 */
	void                       (*cleanup)(CryptoDevBackend *, Error * *); /*   104     8 */
	int64_t                    (*create_session)(CryptoDevBackend *, CryptoDevBackendSymSessionInfo *, uint32_t, Error * *); /*   112     8 */
	int                        (*close_session)(CryptoDevBackend *, uint64_t, uint32_t, Error * *); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int                        (*do_sym_op)(CryptoDevBackend *, CryptoDevBackendSymOpInfo *, uint32_t, Error * *); /*   128     8 */

	/* size: 136, cachelines: 3, members: 6 */
	/* last cacheline: 8 bytes */
};
struct QCryptoCipher {
	QCryptoCipherAlgorithm     alg;                  /*     0     4 */
	QCryptoCipherMode          mode;                 /*     4     4 */
	void *                     opaque;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct CryptoDevBackendBuiltin {
	CryptoDevBackend           parent_obj;           /*     0   616 */
	/* --- cacheline 9 boundary (576 bytes) was 40 bytes ago --- */
	CryptoDevBackendBuiltinSession * sessions[256];  /*   616  2048 */

	/* size: 2664, cachelines: 42, members: 2 */
	/* last cacheline: 40 bytes */
};
struct CryptoDevBackendBuiltinSession {
	QCryptoCipher *            cipher;               /*     0     8 */
	uint8_t                    direction;            /*     8     1 */
	uint8_t                    type;                 /*     9     1 */

	/* XXX 6 bytes hole, try to pack */

	struct {
		struct CryptoDevBackendBuiltinSession * tqe_next; /*    16     8 */
		struct CryptoDevBackendBuiltinSession * * tqe_prev; /*    24     8 */
	} next;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 26, holes: 1, sum holes: 6 */
	/* last cacheline: 32 bytes */
};
struct BlockJobDriver {
	size_t                     instance_size;        /*     0     8 */
	BlockJobType               job_type;             /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	void                       (*set_speed)(BlockJob *, int64_t, Error * *); /*    16     8 */
	void                       (*iostatus_reset)(BlockJob *); /*    24     8 */
	CoroutineEntry *           start;                /*    32     8 */
	void                       (*complete)(BlockJob *, Error * *); /*    40     8 */
	void                       (*commit)(BlockJob *); /*    48     8 */
	void                       (*abort)(BlockJob *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*clean)(BlockJob *); /*    64     8 */
	void                       (*pause)(BlockJob *); /*    72     8 */
	void                       (*resume)(BlockJob *); /*    80     8 */
	void                       (*attached_aio_context)(BlockJob *, AioContext *); /*    88     8 */
	void                       (*drain)(BlockJob *); /*    96     8 */

	/* size: 104, cachelines: 2, members: 13 */
	/* sum members: 100, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct StreamBlockJob {
	BlockJob                   common;               /*     0   168 */
	/* --- cacheline 2 boundary (128 bytes) was 40 bytes ago --- */
	RateLimit                  limit;                /*   168    40 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	BlockDriverState *         base;                 /*   208     8 */
	BlockdevOnError            on_error;             /*   216     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     backing_file_str;     /*   224     8 */
	int                        bs_flags;             /*   232     4 */

	/* size: 240, cachelines: 4, members: 6 */
	/* sum members: 232, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct dis_private {
	bfd_byte *                 max_fetched;          /*     0     8 */
	bfd_byte                   the_buffer[16];       /*     8    16 */
	bfd_vma                    insn_start;           /*    24     8 */
	int                        orig_sizeflag;        /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	sigjmp_buf                 bailout;              /*    40   200 */

	/* size: 240, cachelines: 4, members: 5 */
	/* sum members: 236, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct dis386 {
	const char  *              name;                 /*     0     8 */
	struct {
		op_rtn             rtn;                  /*     8     8 */
		int                bytemode;             /*    16     4 */
	} op[4]; /*     8    64 */

	/* size: 72, cachelines: 2, members: 2 */
	/* last cacheline: 8 bytes */
};
struct AcpiTableOptions {
	_Bool                      has_sig;              /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     sig;                  /*     8     8 */
	_Bool                      has_rev;              /*    16     1 */
	uint8_t                    rev;                  /*    17     1 */
	_Bool                      has_oem_id;           /*    18     1 */

	/* XXX 5 bytes hole, try to pack */

	char *                     oem_id;               /*    24     8 */
	_Bool                      has_oem_table_id;     /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     oem_table_id;         /*    40     8 */
	_Bool                      has_oem_rev;          /*    48     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   oem_rev;              /*    52     4 */
	_Bool                      has_asl_compiler_id;  /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     asl_compiler_id;      /*    64     8 */
	_Bool                      has_asl_compiler_rev; /*    72     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   asl_compiler_rev;     /*    76     4 */
	_Bool                      has_file;             /*    80     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     file;                 /*    88     8 */
	_Bool                      has_data;             /*    96     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     data;                 /*   104     8 */

	/* size: 112, cachelines: 2, members: 18 */
	/* sum members: 66, holes: 8, sum holes: 46 */
	/* last cacheline: 48 bytes */
};
struct acpi_table_header {
	uint16_t                   _length;              /*     0     2 */
	char                       sig[4];               /*     2     4 */
	uint32_t                   length;               /*     6     4 */
	uint8_t                    revision;             /*    10     1 */
	uint8_t                    checksum;             /*    11     1 */
	char                       oem_id[6];            /*    12     6 */
	char                       oem_table_id[8];      /*    18     8 */
	uint32_t                   oem_revision;         /*    26     4 */
	char                       asl_compiler_id[4];   /*    30     4 */
	uint32_t                   asl_compiler_revision; /*    34     4 */

	/* size: 38, cachelines: 1, members: 10 */
	/* last cacheline: 38 bytes */
} __attribute__((__packed__));
struct PMSMBus {
	I2CBus *                   smbus;                /*     0     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               io;                   /*    16   256 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	uint8_t                    smb_stat;             /*   272     1 */
	uint8_t                    smb_ctl;              /*   273     1 */
	uint8_t                    smb_cmd;              /*   274     1 */
	uint8_t                    smb_addr;             /*   275     1 */
	uint8_t                    smb_data0;            /*   276     1 */
	uint8_t                    smb_data1;            /*   277     1 */
	uint8_t                    smb_data[32];         /*   278    32 */
	uint8_t                    smb_index;            /*   310     1 */

	/* Force padding: */
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;

	/* size: 320, cachelines: 5, members: 10 */
	/* sum members: 303, holes: 1, sum holes: 8 */
	/* padding: 9 */
};
struct AcpiPciHpPciStatus {
	uint32_t                   up;                   /*     0     4 */
	uint32_t                   down;                 /*     4     4 */
	uint32_t                   hotplug_enable;       /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
struct AcpiPciHpState {
	AcpiPciHpPciStatus         acpi_pcihp_pci_status[256]; /*     0  3072 */
	/* --- cacheline 48 boundary (3072 bytes) --- */
	uint32_t                   hotplug_select;       /*  3072     4 */

	/* XXX 4 bytes hole, try to pack */

	PCIBus *                   root;                 /*  3080     8 */
	MemoryRegion               io;                   /*  3088   256 */
	/* --- cacheline 52 boundary (3328 bytes) was 16 bytes ago --- */
	_Bool                      legacy_piix;          /*  3344     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   io_base;              /*  3346     2 */
	uint16_t                   io_len;               /*  3348     2 */

	/* Force padding: */
	uint16_t                   :16;
	uint16_t                   :16;
	uint16_t                   :16;
	uint16_t                   :16;
	uint16_t                   :16;

	/* size: 3360, cachelines: 53, members: 7 */
	/* sum members: 3345, holes: 2, sum holes: 5 */
	/* padding: 10 */
	/* last cacheline: 32 bytes */
};
struct PIIX4PMState {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	MemoryRegion               io;                   /*  2288   256 */
	/* --- cacheline 39 boundary (2496 bytes) was 48 bytes ago --- */
	uint32_t                   io_base;              /*  2544     4 */

	/* XXX 12 bytes hole, try to pack */

	/* --- cacheline 40 boundary (2560 bytes) --- */
	MemoryRegion               io_gpe;               /*  2560   256 */
	/* --- cacheline 44 boundary (2816 bytes) --- */
	ACPIREGS                   ar;                   /*  2816   896 */
	/* --- cacheline 58 boundary (3712 bytes) --- */
	APMState                   apm;                  /*  3712   288 */
	/* --- cacheline 62 boundary (3968 bytes) was 32 bytes ago --- */
	PMSMBus                    smb;                  /*  4000   320 */
	/* --- cacheline 67 boundary (4288 bytes) was 32 bytes ago --- */
	uint32_t                   smb_io_base;          /*  4320     4 */

	/* XXX 4 bytes hole, try to pack */

	qemu_irq                   irq;                  /*  4328     8 */
	qemu_irq                   smi_irq;              /*  4336     8 */
	int                        smm_enabled;          /*  4344     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 68 boundary (4352 bytes) --- */
	Notifier                   machine_ready;        /*  4352    24 */
	Notifier                   powerdown_notifier;   /*  4376    24 */
	AcpiPciHpState             acpi_pci_hotplug;     /*  4400  3360 */
	/* --- cacheline 121 boundary (7744 bytes) was 16 bytes ago --- */
	_Bool                      use_acpi_pci_hotplug; /*  7760     1 */
	uint8_t                    disable_s3;           /*  7761     1 */
	uint8_t                    disable_s4;           /*  7762     1 */
	uint8_t                    s4_val;               /*  7763     1 */
	_Bool                      cpu_hotplug_legacy;   /*  7764     1 */

	/* XXX 11 bytes hole, try to pack */

	AcpiCpuHotplug             gpe_cpu;              /*  7776   304 */
	/* --- cacheline 126 boundary (8064 bytes) was 16 bytes ago --- */
	CPUHotplugState            cpuhp_state;          /*  8080   288 */
	/* --- cacheline 130 boundary (8320 bytes) was 48 bytes ago --- */
	MemHotplugState            acpi_memory_hotplug;  /*  8368   288 */

	/* size: 8656, cachelines: 136, members: 22 */
	/* sum members: 8625, holes: 4, sum holes: 31 */
	/* last cacheline: 16 bytes */
};
struct AcpiPciHpFind {
	int                        bsel;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	PCIBus *                   bus;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct NVDIMMDevice {
	PCDIMMDevice               parent_obj;           /*     0   136 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	uint64_t                   label_size;           /*   136     8 */
	void *                     label_data;           /*   144     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               nvdimm_mr;            /*   160   256 */

	/* size: 416, cachelines: 7, members: 4 */
	/* sum members: 408, holes: 1, sum holes: 8 */
	/* last cacheline: 32 bytes */
};
struct NVDIMMClass {
	PCDIMMDeviceClass          parent_class;         /*     0   216 */
	/* --- cacheline 3 boundary (192 bytes) was 24 bytes ago --- */
	void                       (*read_label_data)(NVDIMMDevice *, void *, uint64_t, uint64_t); /*   216     8 */
	void                       (*write_label_data)(NVDIMMDevice *, const void  *, uint64_t, uint64_t); /*   224     8 */

	/* size: 232, cachelines: 4, members: 3 */
	/* last cacheline: 40 bytes */
};
struct NvdimmNfitSpa {
	uint16_t                   type;                 /*     0     2 */
	uint16_t                   length;               /*     2     2 */
	uint16_t                   spa_index;            /*     4     2 */
	uint16_t                   flags;                /*     6     2 */
	uint32_t                   reserved;             /*     8     4 */
	uint32_t                   proximity_domain;     /*    12     4 */
	uint8_t                    type_guid[16];        /*    16    16 */
	uint64_t                   spa_base;             /*    32     8 */
	uint64_t                   spa_length;           /*    40     8 */
	uint64_t                   mem_attr;             /*    48     8 */

	/* size: 56, cachelines: 1, members: 10 */
	/* last cacheline: 56 bytes */
};
struct NvdimmNfitMemDev {
	uint16_t                   type;                 /*     0     2 */
	uint16_t                   length;               /*     2     2 */
	uint32_t                   nfit_handle;          /*     4     4 */
	uint16_t                   phys_id;              /*     8     2 */
	uint16_t                   region_id;            /*    10     2 */
	uint16_t                   spa_index;            /*    12     2 */
	uint16_t                   dcr_index;            /*    14     2 */
	uint64_t                   region_len;           /*    16     8 */
	uint64_t                   region_offset;        /*    24     8 */
	uint64_t                   region_dpa;           /*    32     8 */
	uint16_t                   interleave_index;     /*    40     2 */
	uint16_t                   interleave_ways;      /*    42     2 */
	uint16_t                   flags;                /*    44     2 */
	uint16_t                   reserved;             /*    46     2 */

	/* size: 48, cachelines: 1, members: 14 */
	/* last cacheline: 48 bytes */
};
struct NvdimmNfitControlRegion {
	uint16_t                   type;                 /*     0     2 */
	uint16_t                   length;               /*     2     2 */
	uint16_t                   dcr_index;            /*     4     2 */
	uint16_t                   vendor_id;            /*     6     2 */
	uint16_t                   device_id;            /*     8     2 */
	uint16_t                   revision_id;          /*    10     2 */
	uint16_t                   sub_vendor_id;        /*    12     2 */
	uint16_t                   sub_device_id;        /*    14     2 */
	uint16_t                   sub_revision_id;      /*    16     2 */
	uint8_t                    reserved[6];          /*    18     6 */
	uint32_t                   serial_number;        /*    24     4 */
	uint16_t                   fic;                  /*    28     2 */
	uint16_t                   num_bcw;              /*    30     2 */
	uint64_t                   bcw_size;             /*    32     8 */
	uint64_t                   cmd_offset;           /*    40     8 */
	uint64_t                   cmd_size;             /*    48     8 */
	uint64_t                   status_offset;        /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint64_t                   status_size;          /*    64     8 */
	uint16_t                   flags;                /*    72     2 */
	uint8_t                    reserved2[6];         /*    74     6 */

	/* size: 80, cachelines: 2, members: 20 */
	/* last cacheline: 16 bytes */
};
struct NvdimmDsmIn {
	uint32_t                   handle;               /*     0     4 */
	uint32_t                   revision;             /*     4     4 */
	uint32_t                   function;             /*     8     4 */
	union {
		uint8_t            arg3[4084];           /*    12  4084 */
	};                                               /*    12  4084 */

	/* size: 4096, cachelines: 64, members: 4 */
};
struct NvdimmDsmOut {
	uint32_t                   len;                  /*     0     4 */
	uint8_t                    data[4092];           /*     4  4092 */

	/* size: 4096, cachelines: 64, members: 2 */
};
struct NvdimmDsmFunc0Out {
	uint32_t                   len;                  /*     0     4 */
	uint32_t                   supported_func;       /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct NvdimmDsmFuncNoPayloadOut {
	uint32_t                   len;                  /*     0     4 */
	uint32_t                   func_ret_status;      /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct NvdimmFuncGetLabelSizeOut {
	uint32_t                   len;                  /*     0     4 */
	uint32_t                   func_ret_status;      /*     4     4 */
	uint32_t                   label_size;           /*     8     4 */
	uint32_t                   max_xfer;             /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct NvdimmFuncGetLabelDataIn {
	uint32_t                   offset;               /*     0     4 */
	uint32_t                   length;               /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct NvdimmFuncGetLabelDataOut {
	uint32_t                   len;                  /*     0     4 */
	uint32_t                   func_ret_status;      /*     4     4 */
	uint8_t                    out_buf[];            /*     8     0 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct NvdimmFuncSetLabelDataIn {
	uint32_t                   offset;               /*     0     4 */
	uint32_t                   length;               /*     4     4 */
	uint8_t                    in_buf[];             /*     8     0 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct NvdimmFuncReadFITIn {
	uint32_t                   offset;               /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct NvdimmFuncReadFITOut {
	uint32_t                   len;                  /*     0     4 */
	uint32_t                   func_ret_status;      /*     4     4 */
	uint8_t                    fit[];                /*     8     0 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct BiosLinkerLoaderEntry {
	uint32_t                   command;              /*     0     4 */
	union {
		struct {
			char       file[56];             /*     4    56 */
			uint32_t   align;                /*    60     4 */
			/* --- cacheline 1 boundary (64 bytes) --- */
			uint8_t    zone;                 /*    64     1 */
		} alloc;                                 /*     4    64 */
		struct {
			char       dest_file[56];        /*     4    56 */
			char       src_file[56];         /*    60    56 */
			/* --- cacheline 1 boundary (64 bytes) was 52 bytes ago --- */
			uint32_t   offset;               /*   116     4 */
			uint8_t    size;                 /*   120     1 */
		} pointer;                               /*     4   120 */
		struct {
			char       file[56];             /*     4    56 */
			uint32_t   offset;               /*    60     4 */
			/* --- cacheline 1 boundary (64 bytes) --- */
			uint32_t   start;                /*    64     4 */
			uint32_t   length;               /*    68     4 */
		} cksum;                                 /*     4    68 */
		char               pad[124];             /*     4   124 */
	};                                               /*     4   124 */

	/* size: 128, cachelines: 2, members: 2 */
};
struct BiosLinkerFileEntry {
	char *                     name;                 /*     0     8 */
	GArray *                   blob;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct AcpiRsdtDescriptorRev1 {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   length;               /*     4     4 */
	uint8_t                    revision;             /*     8     1 */
	uint8_t                    checksum;             /*     9     1 */
	uint8_t                    oem_id[6];            /*    10     6 */
	uint8_t                    oem_table_id[8];      /*    16     8 */
	uint32_t                   oem_revision;         /*    24     4 */
	uint8_t                    asl_compiler_id[4];   /*    28     4 */
	uint32_t                   asl_compiler_revision; /*    32     4 */
	uint32_t                   table_offset_entry[]; /*    36     0 */

	/* size: 36, cachelines: 1, members: 10 */
	/* last cacheline: 36 bytes */
};
struct IPMIFwInfo {
	const char  *              interface_name;       /*     0     8 */
	int                        interface_type;       /*     8     4 */
	uint8_t                    ipmi_spec_major_revision; /*    12     1 */
	uint8_t                    ipmi_spec_minor_revision; /*    13     1 */
	uint8_t                    i2c_slave_address;    /*    14     1 */

	/* XXX 1 byte hole, try to pack */

	uint32_t                   uuid;                 /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   base_address;         /*    24     8 */
	uint64_t                   register_length;      /*    32     8 */
	uint8_t                    register_spacing;     /*    40     1 */

	/* XXX 3 bytes hole, try to pack */

	enum {
		IPMI_MEMSPACE_IO = 0,
		IPMI_MEMSPACE_MEM32 = 1,
		IPMI_MEMSPACE_MEM64 = 2,
		IPMI_MEMSPACE_SMBUS = 3,
	} memspace;                                      /*    44     4 */
	int                        interrupt_number;     /*    48     4 */
	enum {
		IPMI_LEVEL_IRQ = 0,
		IPMI_EDGE_IRQ = 1,
	} irq_type;                                      /*    52     4 */

	/* size: 56, cachelines: 1, members: 12 */
	/* sum members: 48, holes: 3, sum holes: 8 */
	/* last cacheline: 56 bytes */
};
struct IPMIInterface {
	Object                     parent;               /*     0    40 */

	/* size: 40, cachelines: 1, members: 1 */
	/* last cacheline: 40 bytes */
};
struct IPMIInterfaceClass {
	InterfaceClass             parent;               /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	void                       (*init)(struct IPMIInterface *, Error * *); /*   112     8 */
	int                        (*do_hw_op)(struct IPMIInterface *, enum ipmi_op, int); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	void                       (*set_irq_enable)(struct IPMIInterface *, int); /*   128     8 */
	void                       (*handle_if_event)(struct IPMIInterface *); /*   136     8 */
	void                       (*set_atn)(struct IPMIInterface *, int, int); /*   144     8 */
	void                       (*reset)(struct IPMIInterface *, _Bool); /*   152     8 */
	void                       (*handle_rsp)(struct IPMIInterface *, uint8_t, unsigned char *, unsigned int); /*   160     8 */
	void *                     (*get_backend_data)(struct IPMIInterface *); /*   168     8 */
	void                       (*get_fwinfo)(struct IPMIInterface *, IPMIFwInfo *); /*   176     8 */

	/* size: 184, cachelines: 3, members: 10 */
	/* last cacheline: 56 bytes */
};
struct IsaDmaClass {
	InterfaceClass             parent;               /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	IsaDmaTransferMode         (*get_transfer_mode)(IsaDma *, int); /*   112     8 */
	_Bool                      (*has_autoinitialization)(IsaDma *, int); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int                        (*read_memory)(IsaDma *, int, void *, int, int); /*   128     8 */
	int                        (*write_memory)(IsaDma *, int, void *, int, int); /*   136     8 */
	void                       (*hold_DREQ)(IsaDma *, int); /*   144     8 */
	void                       (*release_DREQ)(IsaDma *, int); /*   152     8 */
	void                       (*schedule)(IsaDma *); /*   160     8 */
	void                       (*register_channel)(IsaDma *, int, IsaDmaTransferHandler, void *); /*   168     8 */

	/* size: 176, cachelines: 3, members: 9 */
	/* last cacheline: 48 bytes */
};
struct SB16State {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	QEMUSoundCard              card;                 /*   128    24 */
	qemu_irq                   pic;                  /*   152     8 */
	uint32_t                   irq;                  /*   160     4 */
	uint32_t                   dma;                  /*   164     4 */
	uint32_t                   hdma;                 /*   168     4 */
	uint32_t                   port;                 /*   172     4 */
	uint32_t                   ver;                  /*   176     4 */

	/* XXX 4 bytes hole, try to pack */

	IsaDma *                   isa_dma;              /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	IsaDma *                   isa_hdma;             /*   192     8 */
	int                        in_index;             /*   200     4 */
	int                        out_data_len;         /*   204     4 */
	int                        fmt_stereo;           /*   208     4 */
	int                        fmt_signed;           /*   212     4 */
	int                        fmt_bits;             /*   216     4 */
	audfmt_e                   fmt;                  /*   220     4 */
	int                        dma_auto;             /*   224     4 */
	int                        block_size;           /*   228     4 */
	int                        fifo;                 /*   232     4 */
	int                        freq;                 /*   236     4 */
	int                        time_const;           /*   240     4 */
	int                        speaker;              /*   244     4 */
	int                        needed_bytes;         /*   248     4 */
	int                        cmd;                  /*   252     4 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	int                        use_hdma;             /*   256     4 */
	int                        highspeed;            /*   260     4 */
	int                        can_write;            /*   264     4 */
	int                        v2x6;                 /*   268     4 */
	uint8_t                    csp_param;            /*   272     1 */
	uint8_t                    csp_value;            /*   273     1 */
	uint8_t                    csp_mode;             /*   274     1 */
	uint8_t                    csp_regs[256];        /*   275   256 */
	/* --- cacheline 8 boundary (512 bytes) was 19 bytes ago --- */
	uint8_t                    csp_index;            /*   531     1 */
	uint8_t                    csp_reg83[4];         /*   532     4 */
	int                        csp_reg83r;           /*   536     4 */
	int                        csp_reg83w;           /*   540     4 */
	uint8_t                    in2_data[10];         /*   544    10 */
	uint8_t                    out_data[50];         /*   554    50 */
	/* --- cacheline 9 boundary (576 bytes) was 28 bytes ago --- */
	uint8_t                    test_reg;             /*   604     1 */
	uint8_t                    last_read_byte;       /*   605     1 */

	/* XXX 2 bytes hole, try to pack */

	int                        nzero;                /*   608     4 */
	int                        left_till_irq;        /*   612     4 */
	int                        dma_running;          /*   616     4 */
	int                        bytes_per_second;     /*   620     4 */
	int                        align;                /*   624     4 */
	int                        audio_free;           /*   628     4 */
	SWVoiceOut *               voice;                /*   632     8 */
	/* --- cacheline 10 boundary (640 bytes) --- */
	QEMUTimer *                aux_ts;               /*   640     8 */
	int                        mixer_nreg;           /*   648     4 */
	uint8_t                    mixer_regs[256];      /*   652   256 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 14 boundary (896 bytes) was 16 bytes ago --- */
	PortioList                 portio_list;          /*   912    64 */

	/* size: 976, cachelines: 16, members: 51 */
	/* sum members: 966, holes: 3, sum holes: 10 */
	/* last cacheline: 16 bytes */
};
struct chan {
	uint32_t                   shift;                /*     0     4 */
	uint32_t                   leftover;             /*     4     4 */
	uint32_t                   scount;               /*     8     4 */
	uint32_t                   frame_addr;           /*    12     4 */
	uint32_t                   frame_cnt;            /*    16     4 */

	/* size: 20, cachelines: 1, members: 5 */
	/* last cacheline: 20 bytes */
};
struct ES1370State {
	PCIDevice                  dev;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	QEMUSoundCard              card;                 /*  2288    24 */

	/* XXX 8 bytes hole, try to pack */

	/* --- cacheline 36 boundary (2304 bytes) was 16 bytes ago --- */
	MemoryRegion               io;                   /*  2320   256 */
	/* --- cacheline 40 boundary (2560 bytes) was 16 bytes ago --- */
	struct chan                chan[3];              /*  2576    60 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 41 boundary (2624 bytes) was 16 bytes ago --- */
	SWVoiceOut *               dac_voice[2];         /*  2640    16 */
	SWVoiceIn *                adc_voice;            /*  2656     8 */
	uint32_t                   ctl;                  /*  2664     4 */
	uint32_t                   status;               /*  2668     4 */
	uint32_t                   mempage;              /*  2672     4 */
	uint32_t                   codec;                /*  2676     4 */
	uint32_t                   sctl;                 /*  2680     4 */

	/* size: 2688, cachelines: 42, members: 11 */
	/* sum members: 2672, holes: 2, sum holes: 12 */
	/* padding: 4 */
};
struct chan_bits {
	uint32_t                   ctl_en;               /*     0     4 */
	uint32_t                   stat_int;             /*     4     4 */
	uint32_t                   sctl_pause;           /*     8     4 */
	uint32_t                   sctl_inten;           /*    12     4 */
	uint32_t                   sctl_fmt;             /*    16     4 */
	uint32_t                   sctl_sh_fmt;          /*    20     4 */
	uint32_t                   sctl_loopsel;         /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	void                       (*calc_freq)(ES1370State *, uint32_t, uint32_t *, uint32_t *); /*    32     8 */

	/* size: 40, cachelines: 1, members: 8 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct BD {
	uint32_t                   addr;                 /*     0     4 */
	uint32_t                   ctl_len;              /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct AC97BusMasterRegs {
	uint32_t                   bdbar;                /*     0     4 */
	uint8_t                    civ;                  /*     4     1 */
	uint8_t                    lvi;                  /*     5     1 */
	uint16_t                   sr;                   /*     6     2 */
	uint16_t                   picb;                 /*     8     2 */
	uint8_t                    piv;                  /*    10     1 */
	uint8_t                    cr;                   /*    11     1 */
	unsigned int               bd_valid;             /*    12     4 */
	BD                         bd;                   /*    16     8 */

	/* size: 24, cachelines: 1, members: 9 */
	/* last cacheline: 24 bytes */
};
struct AC97LinkState {
	PCIDevice                  dev;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	QEMUSoundCard              card;                 /*  2288    24 */
	/* --- cacheline 36 boundary (2304 bytes) was 8 bytes ago --- */
	uint32_t                   use_broken_id;        /*  2312     4 */
	uint32_t                   glob_cnt;             /*  2316     4 */
	uint32_t                   glob_sta;             /*  2320     4 */
	uint32_t                   cas;                  /*  2324     4 */
	uint32_t                   last_samp;            /*  2328     4 */
	AC97BusMasterRegs          bm_regs[3];           /*  2332    72 */
	/* --- cacheline 37 boundary (2368 bytes) was 36 bytes ago --- */
	uint8_t                    mixer_data[256];      /*  2404   256 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 41 boundary (2624 bytes) was 40 bytes ago --- */
	SWVoiceIn *                voice_pi;             /*  2664     8 */
	SWVoiceOut *               voice_po;             /*  2672     8 */
	SWVoiceIn *                voice_mc;             /*  2680     8 */
	/* --- cacheline 42 boundary (2688 bytes) --- */
	int                        invalid_freq[3];      /*  2688    12 */
	uint8_t                    silence[128];         /*  2700   128 */
	/* --- cacheline 44 boundary (2816 bytes) was 12 bytes ago --- */
	int                        bup_flag;             /*  2828     4 */
	MemoryRegion               io_nam;               /*  2832   256 */
	/* --- cacheline 48 boundary (3072 bytes) was 16 bytes ago --- */
	MemoryRegion               io_nabm;              /*  3088   256 */

	/* size: 3344, cachelines: 53, members: 17 */
	/* sum members: 3340, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct fm_opl_slot {
	INT32                      TL;                   /*     0     4 */
	INT32                      TLL;                  /*     4     4 */
	UINT8                      KSR;                  /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	INT32 *                    AR;                   /*    16     8 */
	INT32 *                    DR;                   /*    24     8 */
	INT32                      SL;                   /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	INT32 *                    RR;                   /*    40     8 */
	UINT8                      ksl;                  /*    48     1 */
	UINT8                      ksr;                  /*    49     1 */

	/* XXX 2 bytes hole, try to pack */

	UINT32                     mul;                  /*    52     4 */
	UINT32                     Cnt;                  /*    56     4 */
	UINT32                     Incr;                 /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	UINT8                      eg_typ;               /*    64     1 */
	UINT8                      evm;                  /*    65     1 */

	/* XXX 2 bytes hole, try to pack */

	INT32                      evc;                  /*    68     4 */
	INT32                      eve;                  /*    72     4 */
	INT32                      evs;                  /*    76     4 */
	INT32                      evsa;                 /*    80     4 */
	INT32                      evsd;                 /*    84     4 */
	INT32                      evsr;                 /*    88     4 */
	UINT8                      ams;                  /*    92     1 */
	UINT8                      vib;                  /*    93     1 */

	/* XXX 2 bytes hole, try to pack */

	INT32 * *                  wavetable;            /*    96     8 */

	/* size: 104, cachelines: 2, members: 23 */
	/* sum members: 87, holes: 5, sum holes: 17 */
	/* last cacheline: 40 bytes */
};
struct fm_opl_channel {
	OPL_SLOT                   SLOT[2];              /*     0   208 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	UINT8                      CON;                  /*   208     1 */
	UINT8                      FB;                   /*   209     1 */

	/* XXX 6 bytes hole, try to pack */

	INT32 *                    connect1;             /*   216     8 */
	INT32 *                    connect2;             /*   224     8 */
	INT32                      op1_out[2];           /*   232     8 */
	UINT32                     block_fnum;           /*   240     4 */
	UINT8                      kcode;                /*   244     1 */

	/* XXX 3 bytes hole, try to pack */

	UINT32                     fc;                   /*   248     4 */
	UINT32                     ksl_base;             /*   252     4 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	UINT8                      keyon;                /*   256     1 */

	/* size: 264, cachelines: 5, members: 11 */
	/* sum members: 248, holes: 2, sum holes: 9 */
	/* padding: 7 */
	/* last cacheline: 8 bytes */
};
struct fm_opl_f {
	UINT8                      type;                 /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        clock;                /*     4     4 */
	int                        rate;                 /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	double                     freqbase;             /*    16     8 */
	double                     TimerBase;            /*    24     8 */
	UINT8                      address;              /*    32     1 */
	UINT8                      status;               /*    33     1 */
	UINT8                      statusmask;           /*    34     1 */

	/* XXX 1 byte hole, try to pack */

	UINT32                     mode;                 /*    36     4 */
	int                        T[2];                 /*    40     8 */
	UINT8                      st[2];                /*    48     2 */

	/* XXX 6 bytes hole, try to pack */

	OPL_CH *                   P_CH;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        max_ch;               /*    64     4 */
	UINT8                      rhythm;               /*    68     1 */
	UINT8                      portDirection;        /*    69     1 */
	UINT8                      portLatch;            /*    70     1 */

	/* XXX 1 byte hole, try to pack */

	OPL_PORTHANDLER_R          porthandler_r;        /*    72     8 */
	OPL_PORTHANDLER_W          porthandler_w;        /*    80     8 */
	int                        port_param;           /*    88     4 */

	/* XXX 4 bytes hole, try to pack */

	OPL_PORTHANDLER_R          keyboardhandler_r;    /*    96     8 */
	OPL_PORTHANDLER_W          keyboardhandler_w;    /*   104     8 */
	int                        keyboard_param;       /*   112     4 */
	INT32                      AR_TABLE[75];         /*   116   300 */
	/* --- cacheline 6 boundary (384 bytes) was 32 bytes ago --- */
	INT32                      DR_TABLE[75];         /*   416   300 */
	/* --- cacheline 11 boundary (704 bytes) was 12 bytes ago --- */
	UINT32                     FN_TABLE[1024];       /*   716  4096 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 75 boundary (4800 bytes) was 16 bytes ago --- */
	INT32 *                    ams_table;            /*  4816     8 */
	INT32 *                    vib_table;            /*  4824     8 */
	INT32                      amsCnt;               /*  4832     4 */
	INT32                      amsIncr;              /*  4836     4 */
	INT32                      vibCnt;               /*  4840     4 */
	INT32                      vibIncr;              /*  4844     4 */
	UINT8                      wavesel;              /*  4848     1 */

	/* XXX 7 bytes hole, try to pack */

	OPL_TIMERHANDLER           TimerHandler;         /*  4856     8 */
	/* --- cacheline 76 boundary (4864 bytes) --- */
	int                        TimerParam;           /*  4864     4 */

	/* XXX 4 bytes hole, try to pack */

	OPL_IRQHANDLER             IRQHandler;           /*  4872     8 */
	int                        IRQParam;             /*  4880     4 */

	/* XXX 4 bytes hole, try to pack */

	OPL_UPDATEHANDLER          UpdateHandler;        /*  4888     8 */
	int                        UpdateParam;          /*  4896     4 */

	/* size: 4904, cachelines: 77, members: 38 */
	/* sum members: 4862, holes: 10, sum holes: 38 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct _GUSEmuState {
	GUSbyte *                  himemaddr;            /*     0     8 */
	GUSbyte *                  gusdatapos;           /*     8     8 */
	uint32_t                   gusirq;               /*    16     4 */
	uint32_t                   gusdma;               /*    20     4 */
	unsigned int               timer1fraction;       /*    24     4 */
	unsigned int               timer2fraction;       /*    28     4 */
	void *                     opaque;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 7 */
	/* last cacheline: 40 bytes */
};
struct GUSState {
	ISADevice                  dev;                  /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	GUSEmuState                emu;                  /*   128    40 */
	QEMUSoundCard              card;                 /*   168    24 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	uint32_t                   freq;                 /*   192     4 */
	uint32_t                   port;                 /*   196     4 */
	int                        pos;                  /*   200     4 */
	int                        left;                 /*   204     4 */
	int                        shift;                /*   208     4 */
	int                        irqs;                 /*   212     4 */
	GUSsample *                mixbuf;               /*   216     8 */
	uint8_t                    himem[1052704];       /*   224 1052704 */
	/* --- cacheline 16452 boundary (1052928 bytes) --- */
	int                        samples;              /* 1052928     4 */

	/* XXX 4 bytes hole, try to pack */

	SWVoiceOut *               voice;                /* 1052936     8 */
	int64_t                    last_ticks;           /* 1052944     8 */
	qemu_irq                   pic;                  /* 1052952     8 */
	IsaDma *                   isa_dma;              /* 1052960     8 */
	PortioList                 portio_list1;         /* 1052968    64 */
	/* --- cacheline 16453 boundary (1052992 bytes) was 40 bytes ago --- */
	PortioList                 portio_list2;         /* 1053032    64 */

	/* size: 1053096, cachelines: 16455, members: 18 */
	/* sum members: 1053092, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct CSState {
	ISADevice                  dev;                  /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	QEMUSoundCard              card;                 /*   128    24 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               ioports;              /*   160   256 */
	/* --- cacheline 6 boundary (384 bytes) was 32 bytes ago --- */
	qemu_irq                   pic;                  /*   416     8 */
	uint32_t                   regs[16];             /*   424    64 */
	/* --- cacheline 7 boundary (448 bytes) was 40 bytes ago --- */
	uint8_t                    dregs[32];            /*   488    32 */
	/* --- cacheline 8 boundary (512 bytes) was 8 bytes ago --- */
	uint32_t                   irq;                  /*   520     4 */
	uint32_t                   dma;                  /*   524     4 */
	uint32_t                   port;                 /*   528     4 */

	/* XXX 4 bytes hole, try to pack */

	IsaDma *                   isa_dma;              /*   536     8 */
	int                        shift;                /*   544     4 */
	int                        dma_running;          /*   548     4 */
	int                        audio_free;           /*   552     4 */
	int                        transferred;          /*   556     4 */
	int                        aci_counter;          /*   560     4 */

	/* XXX 4 bytes hole, try to pack */

	SWVoiceOut *               voice;                /*   568     8 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	int16_t *                  tab;                  /*   576     8 */

	/* size: 592, cachelines: 10, members: 17 */
	/* sum members: 568, holes: 3, sum holes: 16 */
	/* padding: 8 */
	/* last cacheline: 16 bytes */
};
struct HDACodecBus {
	BusState                   qbus;                 /*     0   104 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	uint32_t                   next_cad;             /*   104     4 */

	/* XXX 4 bytes hole, try to pack */

	hda_codec_response_func    response;             /*   112     8 */
	hda_codec_xfer_func        xfer;                 /*   120     8 */

	/* size: 128, cachelines: 2, members: 4 */
	/* sum members: 124, holes: 1, sum holes: 4 */
};
struct HDACodecDevice {
	DeviceState                qdev;                 /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	uint32_t                   cad;                  /*   112     4 */

	/* size: 120, cachelines: 2, members: 2 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct HDACodecDeviceClass {
	DeviceClass                parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        (*init)(HDACodecDevice *); /*   192     8 */
	int                        (*exit)(HDACodecDevice *); /*   200     8 */
	void                       (*command)(HDACodecDevice *, uint32_t, uint32_t); /*   208     8 */
	void                       (*stream)(HDACodecDevice *, uint32_t, _Bool, _Bool); /*   216     8 */

	/* size: 224, cachelines: 4, members: 5 */
	/* last cacheline: 32 bytes */
};
struct IntelHDAStream {
	uint32_t                   ctl;                  /*     0     4 */
	uint32_t                   lpib;                 /*     4     4 */
	uint32_t                   cbl;                  /*     8     4 */
	uint32_t                   lvi;                  /*    12     4 */
	uint32_t                   fmt;                  /*    16     4 */
	uint32_t                   bdlp_lbase;           /*    20     4 */
	uint32_t                   bdlp_ubase;           /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	bpl *                      bpl;                  /*    32     8 */
	uint32_t                   bentries;             /*    40     4 */
	uint32_t                   bsize;                /*    44     4 */
	uint32_t                   be;                   /*    48     4 */
	uint32_t                   bp;                   /*    52     4 */

	/* size: 56, cachelines: 1, members: 12 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct IntelHDAState {
	PCIDevice                  pci;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	const char  *              name;                 /*  2288     8 */
	HDACodecBus                codecs;               /*  2296   128 */
	/* --- cacheline 37 boundary (2368 bytes) was 56 bytes ago --- */
	uint32_t                   g_ctl;                /*  2424     4 */
	uint32_t                   wake_en;              /*  2428     4 */
	/* --- cacheline 38 boundary (2432 bytes) --- */
	uint32_t                   state_sts;            /*  2432     4 */
	uint32_t                   int_ctl;              /*  2436     4 */
	uint32_t                   int_sts;              /*  2440     4 */
	uint32_t                   wall_clk;             /*  2444     4 */
	uint32_t                   corb_lbase;           /*  2448     4 */
	uint32_t                   corb_ubase;           /*  2452     4 */
	uint32_t                   corb_rp;              /*  2456     4 */
	uint32_t                   corb_wp;              /*  2460     4 */
	uint32_t                   corb_ctl;             /*  2464     4 */
	uint32_t                   corb_sts;             /*  2468     4 */
	uint32_t                   corb_size;            /*  2472     4 */
	uint32_t                   rirb_lbase;           /*  2476     4 */
	uint32_t                   rirb_ubase;           /*  2480     4 */
	uint32_t                   rirb_wp;              /*  2484     4 */
	uint32_t                   rirb_cnt;             /*  2488     4 */
	uint32_t                   rirb_ctl;             /*  2492     4 */
	/* --- cacheline 39 boundary (2496 bytes) --- */
	uint32_t                   rirb_sts;             /*  2496     4 */
	uint32_t                   rirb_size;            /*  2500     4 */
	uint32_t                   dp_lbase;             /*  2504     4 */
	uint32_t                   dp_ubase;             /*  2508     4 */
	uint32_t                   icw;                  /*  2512     4 */
	uint32_t                   irr;                  /*  2516     4 */
	uint32_t                   ics;                  /*  2520     4 */

	/* XXX 4 bytes hole, try to pack */

	IntelHDAStream             st[8];                /*  2528   448 */
	/* --- cacheline 46 boundary (2944 bytes) was 32 bytes ago --- */
	MemoryRegion               mmio;                 /*  2976   256 */
	/* --- cacheline 50 boundary (3200 bytes) was 32 bytes ago --- */
	uint32_t                   rirb_count;           /*  3232     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    wall_base_ns;         /*  3240     8 */
	const IntelHDAReg  *       last_reg;             /*  3248     8 */
	uint32_t                   last_val;             /*  3256     4 */
	uint32_t                   last_write;           /*  3260     4 */
	/* --- cacheline 51 boundary (3264 bytes) --- */
	uint32_t                   last_sec;             /*  3264     4 */
	uint32_t                   repeat_count;         /*  3268     4 */
	uint32_t                   debug;                /*  3272     4 */
	OnOffAuto                  msi;                  /*  3276     4 */
	_Bool                      old_msi_addr;         /*  3280     1 */

	/* Force padding: */
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;
	_Bool                      :8;

	/* size: 3296, cachelines: 52, members: 40 */
	/* sum members: 3273, holes: 2, sum holes: 8 */
	/* padding: 15 */
	/* last cacheline: 32 bytes */
};
struct IntelHDAReg {
	const char  *              name;                 /*     0     8 */
	uint32_t                   size;                 /*     8     4 */
	uint32_t                   reset;                /*    12     4 */
	uint32_t                   wmask;                /*    16     4 */
	uint32_t                   wclear;               /*    20     4 */
	uint32_t                   offset;               /*    24     4 */
	uint32_t                   shift;                /*    28     4 */
	uint32_t                   stream;               /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	void                       (*whandler)(IntelHDAState *, const IntelHDAReg  *, uint32_t); /*    40     8 */
	void                       (*rhandler)(IntelHDAState *, const IntelHDAReg  *); /*    48     8 */

	/* size: 56, cachelines: 1, members: 10 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct bpl {
	uint64_t                   addr;                 /*     0     8 */
	uint32_t                   len;                  /*     8     4 */
	uint32_t                   flags;                /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct desc_param {
	uint32_t                   id;                   /*     0     4 */
	uint32_t                   val;                  /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct desc_node {
	uint32_t                   nid;                  /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              name;                 /*     8     8 */
	const desc_param  *        params;               /*    16     8 */
	uint32_t                   nparams;              /*    24     4 */
	uint32_t                   config;               /*    28     4 */
	uint32_t                   pinctl;               /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	uint32_t *                 conn;                 /*    40     8 */
	uint32_t                   stindex;              /*    48     4 */

	/* size: 56, cachelines: 1, members: 8 */
	/* sum members: 44, holes: 2, sum holes: 8 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct desc_codec {
	const char  *              name;                 /*     0     8 */
	uint32_t                   iid;                  /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	const desc_node  *         nodes;                /*    16     8 */
	uint32_t                   nnodes;               /*    24     4 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 24, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct HDAAudioState {
	HDACodecDevice             hda;                  /*     0   120 */
	/* --- cacheline 1 boundary (64 bytes) was 56 bytes ago --- */
	const char  *              name;                 /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	QEMUSoundCard              card;                 /*   128    24 */
	const desc_codec  *        desc;                 /*   152     8 */
	HDAAudioStream             st[4];                /*   160  1344 */
	/* --- cacheline 23 boundary (1472 bytes) was 32 bytes ago --- */
	_Bool                      running_compat[16];   /*  1504    16 */
	_Bool                      running_real[32];     /*  1520    32 */
	/* --- cacheline 24 boundary (1536 bytes) was 16 bytes ago --- */
	uint32_t                   debug;                /*  1552     4 */
	_Bool                      mixer;                /*  1556     1 */

	/* size: 1560, cachelines: 25, members: 9 */
	/* padding: 3 */
	/* last cacheline: 24 bytes */
};
struct HDAAudioStream {
	HDAAudioState *            state;                /*     0     8 */
	const desc_node  *         node;                 /*     8     8 */
	_Bool                      output;               /*    16     1 */
	_Bool                      running;              /*    17     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   stream;               /*    20     4 */
	uint32_t                   channel;              /*    24     4 */
	uint32_t                   format;               /*    28     4 */
	uint32_t                   gain_left;            /*    32     4 */
	uint32_t                   gain_right;           /*    36     4 */
	_Bool                      mute_left;            /*    40     1 */
	_Bool                      mute_right;           /*    41     1 */

	/* XXX 2 bytes hole, try to pack */

	struct audsettings         as;                   /*    44    16 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	union {
		SWVoiceIn *        in;                   /*    64     8 */
		SWVoiceOut *       out;                  /*    64     8 */
	} voice;                                         /*    64     8 */
	uint8_t                    buf[256];             /*    72   256 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	uint32_t                   bpos;                 /*   328     4 */

	/* size: 336, cachelines: 6, members: 15 */
	/* sum members: 324, holes: 3, sum holes: 8 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct partition {
	uint8_t                    boot_ind;             /*     0     1 */
	uint8_t                    head;                 /*     1     1 */
	uint8_t                    sector;               /*     2     1 */
	uint8_t                    cyl;                  /*     3     1 */
	uint8_t                    sys_ind;              /*     4     1 */
	uint8_t                    end_head;             /*     5     1 */
	uint8_t                    end_sector;           /*     6     1 */
	uint8_t                    end_cyl;              /*     7     1 */
	uint32_t                   start_sect;           /*     8     4 */
	uint32_t                   nr_sects;             /*    12     4 */

	/* size: 16, cachelines: 1, members: 10 */
	/* last cacheline: 16 bytes */
};
struct FDCtrl {
	MemoryRegion               iomem;                /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	qemu_irq                   irq;                  /*   256     8 */
	QEMUTimer *                result_timer;         /*   264     8 */
	int                        dma_chann;            /*   272     4 */
	uint8_t                    phase;                /*   276     1 */

	/* XXX 3 bytes hole, try to pack */

	IsaDma *                   dma;                  /*   280     8 */
	uint8_t                    version;              /*   288     1 */
	uint8_t                    sra;                  /*   289     1 */
	uint8_t                    srb;                  /*   290     1 */
	uint8_t                    dor;                  /*   291     1 */
	uint8_t                    dor_vmstate;          /*   292     1 */
	uint8_t                    tdr;                  /*   293     1 */
	uint8_t                    dsr;                  /*   294     1 */
	uint8_t                    msr;                  /*   295     1 */
	uint8_t                    cur_drv;              /*   296     1 */
	uint8_t                    status0;              /*   297     1 */
	uint8_t                    status1;              /*   298     1 */
	uint8_t                    status2;              /*   299     1 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  fifo;                 /*   304     8 */
	int32_t                    fifo_size;            /*   312     4 */
	uint32_t                   data_pos;             /*   316     4 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	uint32_t                   data_len;             /*   320     4 */
	uint8_t                    data_state;           /*   324     1 */
	uint8_t                    data_dir;             /*   325     1 */
	uint8_t                    eot;                  /*   326     1 */
	uint8_t                    precomp_trk;          /*   327     1 */
	uint8_t                    config;               /*   328     1 */
	uint8_t                    lock;                 /*   329     1 */
	uint8_t                    pwrd;                 /*   330     1 */

	/* XXX 5 bytes hole, try to pack */

	FloppyBus                  bus;                  /*   336   112 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	uint8_t                    num_floppies;         /*   448     1 */

	/* XXX 7 bytes hole, try to pack */

	FDrive                     drives[2];            /*   456    80 */
	/* --- cacheline 8 boundary (512 bytes) was 24 bytes ago --- */
	struct {
		BlockBackend *     blk;                  /*   536     8 */
		FloppyDriveType    type;                 /*   544     4 */
	} qdev_for_drives[2]; /*   536    32 */
	int                        reset_sensei;         /*   568     4 */
	uint32_t                   check_media_rate;     /*   572     4 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	FloppyDriveType            fallback;             /*   576     4 */
	uint8_t                    timer0;               /*   580     1 */
	uint8_t                    timer1;               /*   581     1 */

	/* XXX 2 bytes hole, try to pack */

	PortioList                 portio_list;          /*   584    64 */

	/* size: 656, cachelines: 11, members: 39 */
	/* sum members: 627, holes: 5, sum holes: 21 */
	/* padding: 8 */
	/* last cacheline: 16 bytes */
};
struct FDrive {
	FDCtrl *                   fdctrl;               /*     0     8 */
	BlockBackend *             blk;                  /*     8     8 */
	FloppyDriveType            drive;                /*    16     4 */
	uint8_t                    perpendicular;        /*    20     1 */
	uint8_t                    head;                 /*    21     1 */
	uint8_t                    track;                /*    22     1 */
	uint8_t                    sect;                 /*    23     1 */
	FloppyDriveType            disk;                 /*    24     4 */
	FDiskFlags                 flags;                /*    28     4 */
	uint8_t                    last_sect;            /*    32     1 */
	uint8_t                    max_track;            /*    33     1 */
	uint16_t                   bps;                  /*    34     2 */
	uint8_t                    ro;                   /*    36     1 */
	uint8_t                    media_changed;        /*    37     1 */
	uint8_t                    media_rate;           /*    38     1 */
	_Bool                      media_validated;      /*    39     1 */

	/* size: 40, cachelines: 1, members: 16 */
	/* last cacheline: 40 bytes */
};
struct FloppyBus {
	BusState                   bus;                  /*     0   104 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	FDCtrl *                   fdc;                  /*   104     8 */

	/* size: 112, cachelines: 2, members: 2 */
	/* last cacheline: 48 bytes */
};
struct FDFormat {
	FloppyDriveType            drive;                /*     0     4 */
	uint8_t                    last_sect;            /*     4     1 */
	uint8_t                    max_track;            /*     5     1 */
	uint8_t                    max_head;             /*     6     1 */

	/* XXX 1 byte hole, try to pack */

	FDriveRate                 rate;                 /*     8     4 */

	/* size: 12, cachelines: 1, members: 5 */
	/* sum members: 11, holes: 1, sum holes: 1 */
	/* last cacheline: 12 bytes */
};
struct FloppyDrive {
	DeviceState                qdev;                 /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	uint32_t                   unit;                 /*   112     4 */

	/* XXX 4 bytes hole, try to pack */

	BlockConf                  conf;                 /*   120    56 */
	/* --- cacheline 2 boundary (128 bytes) was 48 bytes ago --- */
	FloppyDriveType            type;                 /*   176     4 */

	/* size: 184, cachelines: 3, members: 4 */
	/* sum members: 176, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct FDCtrlSysBus {
	SysBusDevice               parent_obj;           /*     0   768 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	struct FDCtrl              state;                /*   768   656 */

	/* XXX last struct has 8 bytes of padding */

	/* size: 1424, cachelines: 23, members: 2 */
	/* paddings: 1, sum paddings: 8 */
	/* last cacheline: 16 bytes */
};
struct FDCtrlISABus {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint32_t                   iobase;               /*   128     4 */
	uint32_t                   irq;                  /*   132     4 */
	uint32_t                   dma;                  /*   136     4 */

	/* XXX 4 bytes hole, try to pack */

	struct FDCtrl              state;                /*   144   656 */

	/* XXX last struct has 8 bytes of padding */

	/* --- cacheline 12 boundary (768 bytes) was 32 bytes ago --- */
	int32_t                    bootindexA;           /*   800     4 */
	int32_t                    bootindexB;           /*   804     4 */

	/* size: 816, cachelines: 13, members: 7 */
	/* sum members: 804, holes: 1, sum holes: 4 */
	/* padding: 8 */
	/* paddings: 1, sum paddings: 8 */
	/* last cacheline: 48 bytes */
};
struct FDCtrlCommand {
	uint8_t                    value;                /*     0     1 */
	uint8_t                    mask;                 /*     1     1 */

	/* XXX 6 bytes hole, try to pack */

	const char  *              name;                 /*     8     8 */
	int                        parameters;           /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	void                       (*handler)(FDCtrl *, int); /*    24     8 */
	int                        direction;            /*    32     4 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 26, holes: 2, sum holes: 10 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct pflash_t {
	SysBusDevice               parent_obj;           /*     0   768 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	BlockBackend *             blk;                  /*   768     8 */
	uint32_t                   nb_blocs;             /*   776     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   sector_len;           /*   784     8 */
	uint8_t                    bank_width;           /*   792     1 */
	uint8_t                    device_width;         /*   793     1 */
	uint8_t                    max_device_width;     /*   794     1 */

	/* XXX 1 byte hole, try to pack */

	uint32_t                   features;             /*   796     4 */
	uint8_t                    wcycle;               /*   800     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        ro;                   /*   804     4 */
	uint8_t                    cmd;                  /*   808     1 */
	uint8_t                    status;               /*   809     1 */
	uint16_t                   ident0;               /*   810     2 */
	uint16_t                   ident1;               /*   812     2 */
	uint16_t                   ident2;               /*   814     2 */
	uint16_t                   ident3;               /*   816     2 */
	uint8_t                    cfi_len;              /*   818     1 */
	uint8_t                    cfi_table[82];        /*   819    82 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 14 boundary (896 bytes) was 8 bytes ago --- */
	uint64_t                   counter;              /*   904     8 */
	unsigned int               writeblock_size;      /*   912     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUTimer *                timer;                /*   920     8 */
	MemoryRegion               mem;                  /*   928   256 */
	/* --- cacheline 18 boundary (1152 bytes) was 32 bytes ago --- */
	char *                     name;                 /*  1184     8 */
	void *                     storage;              /*  1192     8 */
	VMChangeStateEntry *       vmstate;              /*  1200     8 */

	/* size: 1216, cachelines: 19, members: 25 */
	/* sum members: 1193, holes: 5, sum holes: 15 */
	/* padding: 8 */
};
struct NvmeBar {
	uint64_t                   cap;                  /*     0     8 */
	uint32_t                   vs;                   /*     8     4 */
	uint32_t                   intms;                /*    12     4 */
	uint32_t                   intmc;                /*    16     4 */
	uint32_t                   cc;                   /*    20     4 */
	uint32_t                   rsvd1;                /*    24     4 */
	uint32_t                   csts;                 /*    28     4 */
	uint32_t                   nssrc;                /*    32     4 */
	uint32_t                   aqa;                  /*    36     4 */
	uint64_t                   asq;                  /*    40     8 */
	uint64_t                   acq;                  /*    48     8 */

	/* size: 56, cachelines: 1, members: 11 */
	/* last cacheline: 56 bytes */
};
struct NvmeCmd {
	uint8_t                    opcode;               /*     0     1 */
	uint8_t                    fuse;                 /*     1     1 */
	uint16_t                   cid;                  /*     2     2 */
	uint32_t                   nsid;                 /*     4     4 */
	uint64_t                   res1;                 /*     8     8 */
	uint64_t                   mptr;                 /*    16     8 */
	uint64_t                   prp1;                 /*    24     8 */
	uint64_t                   prp2;                 /*    32     8 */
	uint32_t                   cdw10;                /*    40     4 */
	uint32_t                   cdw11;                /*    44     4 */
	uint32_t                   cdw12;                /*    48     4 */
	uint32_t                   cdw13;                /*    52     4 */
	uint32_t                   cdw14;                /*    56     4 */
	uint32_t                   cdw15;                /*    60     4 */

	/* size: 64, cachelines: 1, members: 14 */
};
struct NvmeDeleteQ {
	uint8_t                    opcode;               /*     0     1 */
	uint8_t                    flags;                /*     1     1 */
	uint16_t                   cid;                  /*     2     2 */
	uint32_t                   rsvd1[9];             /*     4    36 */
	uint16_t                   qid;                  /*    40     2 */
	uint16_t                   rsvd10;               /*    42     2 */
	uint32_t                   rsvd11[5];            /*    44    20 */

	/* size: 64, cachelines: 1, members: 7 */
};
struct NvmeCreateCq {
	uint8_t                    opcode;               /*     0     1 */
	uint8_t                    flags;                /*     1     1 */
	uint16_t                   cid;                  /*     2     2 */
	uint32_t                   rsvd1[5];             /*     4    20 */
	uint64_t                   prp1;                 /*    24     8 */
	uint64_t                   rsvd8;                /*    32     8 */
	uint16_t                   cqid;                 /*    40     2 */
	uint16_t                   qsize;                /*    42     2 */
	uint16_t                   cq_flags;             /*    44     2 */
	uint16_t                   irq_vector;           /*    46     2 */
	uint32_t                   rsvd12[4];            /*    48    16 */

	/* size: 64, cachelines: 1, members: 11 */
};
struct NvmeCreateSq {
	uint8_t                    opcode;               /*     0     1 */
	uint8_t                    flags;                /*     1     1 */
	uint16_t                   cid;                  /*     2     2 */
	uint32_t                   rsvd1[5];             /*     4    20 */
	uint64_t                   prp1;                 /*    24     8 */
	uint64_t                   rsvd8;                /*    32     8 */
	uint16_t                   sqid;                 /*    40     2 */
	uint16_t                   qsize;                /*    42     2 */
	uint16_t                   sq_flags;             /*    44     2 */
	uint16_t                   cqid;                 /*    46     2 */
	uint32_t                   rsvd12[4];            /*    48    16 */

	/* size: 64, cachelines: 1, members: 11 */
};
struct NvmeIdentify {
	uint8_t                    opcode;               /*     0     1 */
	uint8_t                    flags;                /*     1     1 */
	uint16_t                   cid;                  /*     2     2 */
	uint32_t                   nsid;                 /*     4     4 */
	uint64_t                   rsvd2[2];             /*     8    16 */
	uint64_t                   prp1;                 /*    24     8 */
	uint64_t                   prp2;                 /*    32     8 */
	uint32_t                   cns;                  /*    40     4 */
	uint32_t                   rsvd11[5];            /*    44    20 */

	/* size: 64, cachelines: 1, members: 9 */
};
struct NvmeRwCmd {
	uint8_t                    opcode;               /*     0     1 */
	uint8_t                    flags;                /*     1     1 */
	uint16_t                   cid;                  /*     2     2 */
	uint32_t                   nsid;                 /*     4     4 */
	uint64_t                   rsvd2;                /*     8     8 */
	uint64_t                   mptr;                 /*    16     8 */
	uint64_t                   prp1;                 /*    24     8 */
	uint64_t                   prp2;                 /*    32     8 */
	uint64_t                   slba;                 /*    40     8 */
	uint16_t                   nlb;                  /*    48     2 */
	uint16_t                   control;              /*    50     2 */
	uint32_t                   dsmgmt;               /*    52     4 */
	uint32_t                   reftag;               /*    56     4 */
	uint16_t                   apptag;               /*    60     2 */
	uint16_t                   appmask;              /*    62     2 */

	/* size: 64, cachelines: 1, members: 15 */
};
struct NvmeCqe {
	uint32_t                   result;               /*     0     4 */
	uint32_t                   rsvd;                 /*     4     4 */
	uint16_t                   sq_head;              /*     8     2 */
	uint16_t                   sq_id;                /*    10     2 */
	uint16_t                   cid;                  /*    12     2 */
	uint16_t                   status;               /*    14     2 */

	/* size: 16, cachelines: 1, members: 6 */
	/* last cacheline: 16 bytes */
};
struct NvmePSD {
	uint16_t                   mp;                   /*     0     2 */
	uint16_t                   reserved;             /*     2     2 */
	uint32_t                   enlat;                /*     4     4 */
	uint32_t                   exlat;                /*     8     4 */
	uint8_t                    rrt;                  /*    12     1 */
	uint8_t                    rrl;                  /*    13     1 */
	uint8_t                    rwt;                  /*    14     1 */
	uint8_t                    rwl;                  /*    15     1 */
	uint8_t                    resv[16];             /*    16    16 */

	/* size: 32, cachelines: 1, members: 9 */
	/* last cacheline: 32 bytes */
};
struct NvmeIdCtrl {
	uint16_t                   vid;                  /*     0     2 */
	uint16_t                   ssvid;                /*     2     2 */
	uint8_t                    sn[20];               /*     4    20 */
	uint8_t                    mn[40];               /*    24    40 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint8_t                    fr[8];                /*    64     8 */
	uint8_t                    rab;                  /*    72     1 */
	uint8_t                    ieee[3];              /*    73     3 */
	uint8_t                    cmic;                 /*    76     1 */
	uint8_t                    mdts;                 /*    77     1 */
	uint8_t                    rsvd255[178];         /*    78   178 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint16_t                   oacs;                 /*   256     2 */
	uint8_t                    acl;                  /*   258     1 */
	uint8_t                    aerl;                 /*   259     1 */
	uint8_t                    frmw;                 /*   260     1 */
	uint8_t                    lpa;                  /*   261     1 */
	uint8_t                    elpe;                 /*   262     1 */
	uint8_t                    npss;                 /*   263     1 */
	uint8_t                    rsvd511[248];         /*   264   248 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	uint8_t                    sqes;                 /*   512     1 */
	uint8_t                    cqes;                 /*   513     1 */
	uint16_t                   rsvd515;              /*   514     2 */
	uint32_t                   nn;                   /*   516     4 */
	uint16_t                   oncs;                 /*   520     2 */
	uint16_t                   fuses;                /*   522     2 */
	uint8_t                    fna;                  /*   524     1 */
	uint8_t                    vwc;                  /*   525     1 */
	uint16_t                   awun;                 /*   526     2 */
	uint16_t                   awupf;                /*   528     2 */
	uint8_t                    rsvd703[174];         /*   530   174 */
	/* --- cacheline 11 boundary (704 bytes) --- */
	uint8_t                    rsvd2047[1344];       /*   704  1344 */
	/* --- cacheline 32 boundary (2048 bytes) --- */
	NvmePSD                    psd[32];              /*  2048  1024 */
	/* --- cacheline 48 boundary (3072 bytes) --- */
	uint8_t                    vs[1024];             /*  3072  1024 */

	/* size: 4096, cachelines: 64, members: 32 */
};
struct NvmeLBAF {
	uint16_t                   ms;                   /*     0     2 */
	uint8_t                    ds;                   /*     2     1 */
	uint8_t                    rp;                   /*     3     1 */

	/* size: 4, cachelines: 1, members: 3 */
	/* last cacheline: 4 bytes */
};
struct NvmeIdNs {
	uint64_t                   nsze;                 /*     0     8 */
	uint64_t                   ncap;                 /*     8     8 */
	uint64_t                   nuse;                 /*    16     8 */
	uint8_t                    nsfeat;               /*    24     1 */
	uint8_t                    nlbaf;                /*    25     1 */
	uint8_t                    flbas;                /*    26     1 */
	uint8_t                    mc;                   /*    27     1 */
	uint8_t                    dpc;                  /*    28     1 */
	uint8_t                    dps;                  /*    29     1 */
	uint8_t                    res30[98];            /*    30    98 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	NvmeLBAF                   lbaf[16];             /*   128    64 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	uint8_t                    res192[192];          /*   192   192 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	uint8_t                    vs[3712];             /*   384  3712 */

	/* size: 4096, cachelines: 64, members: 13 */
};
struct NvmeRequest {
	struct NvmeSQueue *        sq;                   /*     0     8 */
	BlockAIOCB *               aiocb;                /*     8     8 */
	uint16_t                   status;               /*    16     2 */
	_Bool                      has_sg;               /*    18     1 */

	/* XXX 1 byte hole, try to pack */

	NvmeCqe                    cqe;                  /*    20    16 */

	/* XXX 4 bytes hole, try to pack */

	BlockAcctCookie            acct;                 /*    40    24 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	QEMUSGList                 qsg;                  /*    64    40 */
	struct {
		struct NvmeRequest * tqe_next;           /*   104     8 */
		struct NvmeRequest * * tqe_prev;         /*   112     8 */
	} entry;                                         /*   104    16 */

	/* size: 120, cachelines: 2, members: 8 */
	/* sum members: 115, holes: 2, sum holes: 5 */
	/* last cacheline: 56 bytes */
};
struct NvmeSQueue {
	struct NvmeCtrl *          ctrl;                 /*     0     8 */
	uint16_t                   sqid;                 /*     8     2 */
	uint16_t                   cqid;                 /*    10     2 */
	uint32_t                   head;                 /*    12     4 */
	uint32_t                   tail;                 /*    16     4 */
	uint32_t                   size;                 /*    20     4 */
	uint64_t                   dma_addr;             /*    24     8 */
	QEMUTimer *                timer;                /*    32     8 */
	NvmeRequest *              io_req;               /*    40     8 */
	struct sq_req_list         req_list;             /*    48    16 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	struct out_req_list        out_req_list;         /*    64    16 */
	struct {
		struct NvmeSQueue * tqe_next;            /*    80     8 */
		struct NvmeSQueue * * tqe_prev;          /*    88     8 */
	} entry;                                         /*    80    16 */

	/* size: 96, cachelines: 2, members: 12 */
	/* last cacheline: 32 bytes */
};
struct sq_req_list {
	struct NvmeRequest *       tqh_first;            /*     0     8 */
	struct NvmeRequest * *     tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct out_req_list {
	struct NvmeRequest *       tqh_first;            /*     0     8 */
	struct NvmeRequest * *     tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct NvmeCtrl {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	MemoryRegion               iomem;                /*  2288   256 */
	/* --- cacheline 39 boundary (2496 bytes) was 48 bytes ago --- */
	NvmeBar                    bar;                  /*  2544    56 */
	/* --- cacheline 40 boundary (2560 bytes) was 40 bytes ago --- */
	BlockConf                  conf;                 /*  2600    56 */
	/* --- cacheline 41 boundary (2624 bytes) was 32 bytes ago --- */
	uint32_t                   page_size;            /*  2656     4 */
	uint16_t                   page_bits;            /*  2660     2 */
	uint16_t                   max_prp_ents;         /*  2662     2 */
	uint16_t                   cqe_size;             /*  2664     2 */
	uint16_t                   sqe_size;             /*  2666     2 */
	uint32_t                   reg_size;             /*  2668     4 */
	uint32_t                   num_namespaces;       /*  2672     4 */
	uint32_t                   num_queues;           /*  2676     4 */
	uint32_t                   max_q_ents;           /*  2680     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 42 boundary (2688 bytes) --- */
	uint64_t                   ns_size;              /*  2688     8 */
	char *                     serial;               /*  2696     8 */
	NvmeNamespace *            namespaces;           /*  2704     8 */
	NvmeSQueue * *             sq;                   /*  2712     8 */
	NvmeCQueue * *             cq;                   /*  2720     8 */
	NvmeSQueue                 admin_sq;             /*  2728    96 */
	/* --- cacheline 44 boundary (2816 bytes) was 8 bytes ago --- */
	NvmeCQueue                 admin_cq;             /*  2824    80 */
	/* --- cacheline 45 boundary (2880 bytes) was 24 bytes ago --- */
	NvmeIdCtrl                 id_ctrl;              /*  2904  4096 */

	/* size: 7008, cachelines: 110, members: 21 */
	/* sum members: 6996, holes: 1, sum holes: 4 */
	/* padding: 8 */
	/* last cacheline: 32 bytes */
};
struct sq_list {
	struct NvmeSQueue *        tqh_first;            /*     0     8 */
	struct NvmeSQueue * *      tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct cq_req_list {
	struct NvmeRequest *       tqh_first;            /*     0     8 */
	struct NvmeRequest * *     tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct NvmeCQueue {
	struct NvmeCtrl *          ctrl;                 /*     0     8 */
	uint8_t                    phase;                /*     8     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   cqid;                 /*    10     2 */
	uint16_t                   irq_enabled;          /*    12     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   head;                 /*    16     4 */
	uint32_t                   tail;                 /*    20     4 */
	uint32_t                   vector;               /*    24     4 */
	uint32_t                   size;                 /*    28     4 */
	uint64_t                   dma_addr;             /*    32     8 */
	QEMUTimer *                timer;                /*    40     8 */
	struct sq_list             sq_list;              /*    48    16 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	struct cq_req_list         req_list;             /*    64    16 */

	/* size: 80, cachelines: 2, members: 12 */
	/* sum members: 77, holes: 2, sum holes: 3 */
	/* last cacheline: 16 bytes */
};
struct NvmeNamespace {
	NvmeIdNs                   id_ns;                /*     0  4096 */

	/* size: 4096, cachelines: 64, members: 1 */
};
struct bt_vlan_s {
	struct bt_scatternet_s     net;                  /*     0     8 */
	int                        id;                   /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	struct bt_vlan_s *         next;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct bt_l2cap_device_s {
	struct bt_device_s         device;               /*     0   160 */

	/* XXX last struct has 6 bytes of padding */

	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	struct bt_l2cap_psm_s *    first_psm;            /*   160     8 */

	/* size: 168, cachelines: 3, members: 2 */
	/* paddings: 1, sum paddings: 6 */
	/* last cacheline: 40 bytes */
};
struct bt_l2cap_psm_s {
	int                        psm;                  /*     0     4 */
	int                        min_mtu;              /*     4     4 */
	int                        (*new_channel)(struct bt_l2cap_device_s *, struct bt_l2cap_conn_params_s *); /*     8     8 */
	struct bt_l2cap_psm_s *    next;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct bt_l2cap_conn_params_s {
	uint8_t *                  (*sdu_out)(struct bt_l2cap_conn_params_s *, int); /*     0     8 */
	void                       (*sdu_submit)(struct bt_l2cap_conn_params_s *); /*     8     8 */
	int                        remote_mtu;           /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     opaque;               /*    24     8 */
	void                       (*sdu_in)(void *, const uint8_t  *, int); /*    32     8 */
	void                       (*close)(void *);     /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* sum members: 44, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct l2cap_chan_s {
	struct bt_l2cap_conn_params_s params;            /*     0    48 */
	void                       (*frame_in)(struct l2cap_chan_s *, uint16_t, const l2cap_hdr  *, int); /*    48     8 */
	int                        mps;                  /*    56     4 */
	int                        min_mtu;              /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	struct l2cap_instance_s *  l2cap;                /*    64     8 */
	uint16_t                   remote_cid;           /*    72     2 */

	/* XXX 2 bytes hole, try to pack */

	int                        config_req_id;        /*    76     4 */
	int                        config;               /*    80     4 */
	int                        mode;                 /*    84     4 */
	uint8_t                    sdu[65536];           /*    88 65536 */
	/* --- cacheline 1025 boundary (65600 bytes) was 24 bytes ago --- */
	int                        len_cur;              /* 65624     4 */
	int                        len_total;            /* 65628     4 */
	int                        rexmit;               /* 65632     4 */
	int                        monitor_timeout;      /* 65636     4 */
	QEMUTimer *                monitor_timer;        /* 65640     8 */
	QEMUTimer *                retransmission_timer; /* 65648     8 */

	/* size: 65656, cachelines: 1026, members: 16 */
	/* sum members: 65654, holes: 1, sum holes: 2 */
	/* last cacheline: 56 bytes */
};
struct l2cap_instance_s {
	struct bt_link_s *         link;                 /*     0     8 */
	struct bt_l2cap_device_s * dev;                  /*     8     8 */
	int                        role;                 /*    16     4 */
	uint8_t                    frame_in[65539];      /*    20 65539 */

	/* XXX 1 byte hole, try to pack */

	/* --- cacheline 1024 boundary (65536 bytes) was 24 bytes ago --- */
	int                        frame_in_len;         /* 65560     4 */
	uint8_t                    frame_out[65539];     /* 65564 65539 */

	/* XXX 1 byte hole, try to pack */

	/* --- cacheline 2048 boundary (131072 bytes) was 32 bytes ago --- */
	int                        frame_out_len;        /* 131104     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUTimer *                rtx;                  /* 131112     8 */
	QEMUTimer *                ertx;                 /* 131120     8 */
	int                        last_id;              /* 131128     4 */
	int                        next_id;              /* 131132     4 */
	/* --- cacheline 2049 boundary (131136 bytes) --- */
	struct l2cap_chan_s *      cid[256];             /* 131136  2048 */
	/* --- cacheline 2081 boundary (133184 bytes) --- */
	struct l2cap_chan_s        signalling_ch;        /* 133184 65656 */
	/* --- cacheline 3106 boundary (198784 bytes) was 56 bytes ago --- */
	struct l2cap_chan_s        group_ch;             /* 198840 65656 */

	/* size: 264496, cachelines: 4133, members: 14 */
	/* sum members: 264490, holes: 3, sum holes: 6 */
	/* last cacheline: 48 bytes */
};
struct slave_l2cap_instance_s {
	struct bt_link_s           link;                 /*     0    24 */
	struct l2cap_instance_s    l2cap;                /*    24 264496 */

	/* size: 264520, cachelines: 4134, members: 2 */
	/* last cacheline: 8 bytes */
};
struct sdp_service_attribute_s {
	int                        match;                /*     0     4 */
	int                        attribute_id;         /*     4     4 */
	int                        len;                  /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     pair;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct sdp_service_record_s {
	int                        match;                /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	int *                      uuid;                 /*     8     8 */
	int                        uuids;                /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	struct sdp_service_attribute_s * attribute_list; /*    24     8 */
	int                        attributes;           /*    32     4 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 28, holes: 2, sum holes: 8 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct bt_l2cap_sdp_state_s {
	struct bt_l2cap_conn_params_s * channel;         /*     0     8 */
	struct sdp_service_record_s * service_list;      /*     8     8 */
	int                        services;             /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct sdp_def_data_element_s {
	uint8_t                    type;                 /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	union {
		uint32_t           uint;                 /*     8     4 */
		const char  *      str;                  /*     8     8 */
		struct sdp_def_data_element_s * list;    /*     8     8 */
	} value;                                         /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 9, holes: 1, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct sdp_def_attribute_s {
	uint16_t                   id;                   /*     0     2 */

	/* XXX 6 bytes hole, try to pack */

	struct sdp_def_data_element_s data;              /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* sum members: 18, holes: 1, sum holes: 6 */
	/* last cacheline: 24 bytes */
};
struct sdp_def_service_s {
	uint16_t                   class_uuid;           /*     0     2 */

	/* XXX 6 bytes hole, try to pack */

	struct sdp_def_attribute_s attributes[];         /*     8     0 */

	/* size: 8, cachelines: 1, members: 2 */
	/* sum members: 2, holes: 1, sum holes: 6 */
	/* last cacheline: 8 bytes */
};
struct hci_acl_hdr {
	uint16_t                   handle;               /*     0     2 */
	uint16_t                   dlen;                 /*     2     2 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
struct bt_hci_master_link_s {
	struct bt_link_s *         link;                 /*     0     8 */
	void                       (*lmp_acl_data)(struct bt_link_s *, const uint8_t  *, int, int); /*     8     8 */
	QEMUTimer *                acl_mode_timer;       /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct bt_hci_s {
	uint8_t *                  (*evt_packet)(void *); /*     0     8 */
	void                       (*evt_submit)(void *, int); /*     8     8 */
	void *                     opaque;               /*    16     8 */
	uint8_t                    evt_buf[256];         /*    24   256 */
	/* --- cacheline 4 boundary (256 bytes) was 24 bytes ago --- */
	uint8_t                    acl_buf[4096];        /*   280  4096 */
	/* --- cacheline 68 boundary (4352 bytes) was 24 bytes ago --- */
	int                        acl_len;              /*  4376     4 */
	uint16_t                   asb_handle;           /*  4380     2 */
	uint16_t                   psb_handle;           /*  4382     2 */
	int                        last_cmd;             /*  4384     4 */

	/* XXX 4 bytes hole, try to pack */

	struct bt_device_s *       conn_req_host;        /*  4392     8 */
	struct {
		int                inquire;              /*  4400     4 */
		int                periodic;             /*  4404     4 */
		int                responses_left;       /*  4408     4 */
		int                responses;            /*  4412     4 */
		/* --- cacheline 69 boundary (4416 bytes) --- */
		QEMUTimer *        inquiry_done;         /*  4416     8 */
		QEMUTimer *        inquiry_next;         /*  4424     8 */
		int                inquiry_length;       /*  4432     4 */
		int                inquiry_period;       /*  4436     4 */
		int                inquiry_mode;         /*  4440     4 */

		/* XXX 4 bytes hole, try to pack */

		struct bt_hci_master_link_s handle[16];  /*  4448   384 */
		/* --- cacheline 75 boundary (4800 bytes) was 32 bytes ago --- */
		uint32_t           role_bmp;             /*  4832     4 */
		int                last_handle;          /*  4836     4 */
		int                connecting;           /*  4840     4 */
		bdaddr_t           awaiting_bdaddr[16];  /*  4844    96 */
	} lm;                                            /*  4400   544 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 77 boundary (4928 bytes) was 16 bytes ago --- */
	uint8_t                    event_mask[8];        /*  4944     8 */
	uint16_t                   voice_setting;        /*  4952     2 */
	uint16_t                   conn_accept_tout;     /*  4954     2 */

	/* XXX 4 bytes hole, try to pack */

	QEMUTimer *                conn_accept_timer;    /*  4960     8 */
	struct HCIInfo             info;                 /*  4968    56 */
	/* --- cacheline 78 boundary (4992 bytes) was 32 bytes ago --- */
	struct bt_device_s         device;               /*  5024   160 */

	/* XXX last struct has 6 bytes of padding */

	/* --- cacheline 81 boundary (5184 bytes) --- */
	Error *                    replay_blocker;       /*  5184     8 */

	/* size: 5192, cachelines: 82, members: 18 */
	/* sum members: 5184, holes: 2, sum holes: 8 */
	/* paddings: 2, sum paddings: 10 */
	/* last cacheline: 8 bytes */
};
struct bt_hci_link_s {
	struct bt_link_s           btlink;               /*     0    24 */
	uint16_t                   handle;               /*    24     2 */

	/* size: 32, cachelines: 1, members: 2 */
	/* padding: 6 */
	/* last cacheline: 32 bytes */
};
struct HIDPointerEvent {
	int32_t                    xdx;                  /*     0     4 */
	int32_t                    ydy;                  /*     4     4 */
	int32_t                    dz;                   /*     8     4 */
	int32_t                    buttons_state;        /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct HIDState {
	union {
		HIDMouseState      ptr;                  /*     0   260 */
		HIDKeyboardState   kbd;                  /*     0    88 */
	};                                               /*     0   260 */
	/* --- cacheline 4 boundary (256 bytes) was 4 bytes ago --- */
	uint32_t                   head;                 /*   260     4 */
	uint32_t                   n;                    /*   264     4 */
	int                        kind;                 /*   268     4 */
	int32_t                    protocol;             /*   272     4 */
	uint8_t                    idle;                 /*   276     1 */
	_Bool                      idle_pending;         /*   277     1 */

	/* XXX 2 bytes hole, try to pack */

	QEMUTimer *                idle_timer;           /*   280     8 */
	HIDEventFunc               event;                /*   288     8 */
	QemuInputHandlerState *    s;                    /*   296     8 */

	/* size: 304, cachelines: 5, members: 10 */
	/* sum members: 302, holes: 1, sum holes: 2 */
	/* last cacheline: 48 bytes */
};
struct HIDMouseState {
	HIDPointerEvent            queue[16];            /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	int                        mouse_grabbed;        /*   256     4 */

	/* size: 260, cachelines: 5, members: 2 */
	/* last cacheline: 4 bytes */
};
struct HIDKeyboardState {
	uint32_t                   keycodes[16];         /*     0    64 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint16_t                   modifiers;            /*    64     2 */
	uint8_t                    leds;                 /*    66     1 */
	uint8_t                    key[16];              /*    67    16 */

	/* XXX 1 byte hole, try to pack */

	int32_t                    keys;                 /*    84     4 */

	/* size: 88, cachelines: 2, members: 5 */
	/* sum members: 87, holes: 1, sum holes: 1 */
	/* last cacheline: 24 bytes */
};
struct bt_hid_device_s {
	struct bt_l2cap_device_s   btdev;                /*     0   168 */
	/* --- cacheline 2 boundary (128 bytes) was 40 bytes ago --- */
	struct bt_l2cap_conn_params_s * control;         /*   168     8 */
	struct bt_l2cap_conn_params_s * interrupt;       /*   176     8 */
	HIDState                   hid;                  /*   184   304 */
	/* --- cacheline 7 boundary (448 bytes) was 40 bytes ago --- */
	int                        proto;                /*   488     4 */
	int                        connected;            /*   492     4 */
	int                        data_type;            /*   496     4 */
	int                        intr_state;           /*   500     4 */
	struct {
		int                len;                  /*   504     4 */
		uint8_t            buffer[1024];         /*   508  1024 */
	} dataother;                                     /*   504  1028 */
	/* --- cacheline 23 boundary (1472 bytes) was 60 bytes ago --- */
	struct {
		int                len;                  /*  1532     4 */
		/* --- cacheline 24 boundary (1536 bytes) --- */
		uint8_t            buffer[1024];         /*  1536  1024 */
	} datain;                                        /*  1532  1028 */
	/* --- cacheline 40 boundary (2560 bytes) --- */
	struct {
		int                len;                  /*  2560     4 */
		uint8_t            buffer[1024];         /*  2564  1024 */
	} dataout;                                       /*  2560  1028 */
	/* --- cacheline 56 boundary (3584 bytes) was 4 bytes ago --- */
	struct {
		int                len;                  /*  3588     4 */
		uint8_t            buffer[1024];         /*  3592  1024 */
	} feature;                                       /*  3588  1028 */
	/* --- cacheline 72 boundary (4608 bytes) was 8 bytes ago --- */
	struct {
		int                len;                  /*  4616     4 */
		uint8_t            buffer[1024];         /*  4620  1024 */
	} intrdataout;                                   /*  4616  1028 */
	/* --- cacheline 88 boundary (5632 bytes) was 12 bytes ago --- */
	enum {
		bt_state_ready = 0,
		bt_state_transaction = 1,
		bt_state_suspend = 2,
	} state;                                         /*  5644     4 */

	/* size: 5648, cachelines: 89, members: 14 */
	/* last cacheline: 16 bytes */
};
struct hci_command_hdr {
	uint16_t                   opcode;               /*     0     2 */
	uint8_t                    plen;                 /*     2     1 */

	/* size: 3, cachelines: 1, members: 2 */
	/* last cacheline: 3 bytes */
} __attribute__((__packed__));
struct hci_event_hdr {
	uint8_t                    evt;                  /*     0     1 */
	uint8_t                    plen;                 /*     1     1 */

	/* size: 2, cachelines: 1, members: 2 */
	/* last cacheline: 2 bytes */
};
struct hci_sco_hdr {
	uint16_t                   handle;               /*     0     2 */
	uint8_t                    dlen;                 /*     2     1 */

	/* size: 3, cachelines: 1, members: 2 */
	/* last cacheline: 3 bytes */
} __attribute__((__packed__));
struct csrhci_s {
	int                        enable;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	qemu_irq *                 pins;                 /*     8     8 */
	int                        pin_state;            /*    16     4 */
	int                        modem_state;          /*    20     4 */
	CharDriverState            chr;                  /*    24   232 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	int                        out_start;            /*   256     4 */
	int                        out_len;              /*   260     4 */
	int                        out_size;             /*   264     4 */
	uint8_t                    outfifo[8192];        /*   268  8192 */
	/* --- cacheline 132 boundary (8448 bytes) was 12 bytes ago --- */
	uint8_t                    inpkt[4096];          /*  8460  4096 */
	/* --- cacheline 196 boundary (12544 bytes) was 12 bytes ago --- */
	enum {
		CSR_HDR_LEN = 0,
		CSR_DATA_LEN = 1,
		CSR_DATA = 2,
	} in_state;                                      /* 12556     4 */
	int                        in_len;               /* 12560     4 */
	int                        in_hdr;               /* 12564     4 */
	int                        in_needed;            /* 12568     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUTimer *                out_tm;               /* 12576     8 */
	int64_t                    baud_delay;           /* 12584     8 */
	bdaddr_t                   bd_addr;              /* 12592     6 */

	/* XXX 2 bytes hole, try to pack */

	struct HCIInfo *           hci;                  /* 12600     8 */

	/* size: 12608, cachelines: 197, members: 18 */
	/* sum members: 12598, holes: 3, sum holes: 10 */
};
struct IPackDevice {
	DeviceState                parent_obj;           /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	int32_t                    slot;                 /*   112     4 */

	/* XXX 4 bytes hole, try to pack */

	qemu_irq *                 irq;                  /*   120     8 */

	/* size: 128, cachelines: 2, members: 3 */
	/* sum members: 124, holes: 1, sum holes: 4 */
};
struct IPackDeviceClass {
	DeviceClass                parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	DeviceRealize              realize;              /*   192     8 */
	DeviceUnrealize            unrealize;            /*   200     8 */
	uint16_t                   (*io_read)(IPackDevice *, uint8_t); /*   208     8 */
	void                       (*io_write)(IPackDevice *, uint8_t, uint16_t); /*   216     8 */
	uint16_t                   (*id_read)(IPackDevice *, uint8_t); /*   224     8 */
	void                       (*id_write)(IPackDevice *, uint8_t, uint16_t); /*   232     8 */
	uint16_t                   (*int_read)(IPackDevice *, uint8_t); /*   240     8 */
	void                       (*int_write)(IPackDevice *, uint8_t, uint16_t); /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint16_t                   (*mem_read16)(IPackDevice *, uint32_t); /*   256     8 */
	void                       (*mem_write16)(IPackDevice *, uint32_t, uint16_t); /*   264     8 */
	uint8_t                    (*mem_read8)(IPackDevice *, uint32_t); /*   272     8 */
	void                       (*mem_write8)(IPackDevice *, uint32_t, uint8_t); /*   280     8 */

	/* size: 288, cachelines: 5, members: 13 */
	/* last cacheline: 32 bytes */
};
struct IPOctalState {
	IPackDevice                parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	SCC2698Channel             ch[8];                /*   128   576 */
	/* --- cacheline 11 boundary (704 bytes) --- */
	SCC2698Block               blk[4];               /*   704     8 */
	uint8_t                    irq_vector;           /*   712     1 */

	/* size: 720, cachelines: 12, members: 4 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct SCC2698Channel {
	IPOctalState *             ipoctal;              /*     0     8 */
	CharBackend                dev;                  /*     8    48 */
	_Bool                      rx_enabled;           /*    56     1 */
	uint8_t                    mr[2];                /*    57     2 */
	uint8_t                    mr_idx;               /*    59     1 */
	uint8_t                    sr;                   /*    60     1 */
	uint8_t                    rhr[3];               /*    61     3 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint8_t                    rhr_idx;              /*    64     1 */
	uint8_t                    rx_pending;           /*    65     1 */

	/* size: 72, cachelines: 2, members: 9 */
	/* padding: 6 */
	/* last cacheline: 8 bytes */
};
struct SCC2698Block {
	uint8_t                    imr;                  /*     0     1 */
	uint8_t                    isr;                  /*     1     1 */

	/* size: 2, cachelines: 1, members: 2 */
	/* last cacheline: 2 bytes */
};
struct ParallelState {
	MemoryRegion               iomem;                /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint8_t                    dataw;                /*   256     1 */
	uint8_t                    datar;                /*   257     1 */
	uint8_t                    status;               /*   258     1 */
	uint8_t                    control;              /*   259     1 */

	/* XXX 4 bytes hole, try to pack */

	qemu_irq                   irq;                  /*   264     8 */
	int                        irq_pending;          /*   272     4 */

	/* XXX 4 bytes hole, try to pack */

	CharBackend                chr;                  /*   280    48 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	int                        hw_driver;            /*   328     4 */
	int                        epp_timeout;          /*   332     4 */
	uint32_t                   last_read_offset;     /*   336     4 */
	int                        it_shift;             /*   340     4 */
	PortioList                 portio_list;          /*   344    64 */

	/* size: 416, cachelines: 7, members: 13 */
	/* sum members: 400, holes: 2, sum holes: 8 */
	/* padding: 8 */
	/* last cacheline: 32 bytes */
};
struct ISAParallelState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint32_t                   index;                /*   128     4 */
	uint32_t                   iobase;               /*   132     4 */
	uint32_t                   isairq;               /*   136     4 */

	/* XXX 4 bytes hole, try to pack */

	ParallelState              state;                /*   144   416 */

	/* size: 560, cachelines: 9, members: 5 */
	/* sum members: 556, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct SerialState {
	uint16_t                   divider;              /*     0     2 */
	uint8_t                    rbr;                  /*     2     1 */
	uint8_t                    thr;                  /*     3     1 */
	uint8_t                    tsr;                  /*     4     1 */
	uint8_t                    ier;                  /*     5     1 */
	uint8_t                    iir;                  /*     6     1 */
	uint8_t                    lcr;                  /*     7     1 */
	uint8_t                    mcr;                  /*     8     1 */
	uint8_t                    lsr;                  /*     9     1 */
	uint8_t                    msr;                  /*    10     1 */
	uint8_t                    scr;                  /*    11     1 */
	uint8_t                    fcr;                  /*    12     1 */
	uint8_t                    fcr_vmstate;          /*    13     1 */

	/* XXX 2 bytes hole, try to pack */

	int                        thr_ipending;         /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	qemu_irq                   irq;                  /*    24     8 */
	CharBackend                chr;                  /*    32    48 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	int                        last_break_enable;    /*    80     4 */
	int                        it_shift;             /*    84     4 */
	int                        baudbase;             /*    88     4 */
	uint32_t                   tsr_retry;            /*    92     4 */
	guint                      watch_tag;            /*    96     4 */
	uint32_t                   wakeup;               /*   100     4 */
	uint64_t                   last_xmit_ts;         /*   104     8 */
	Fifo8                      recv_fifo;            /*   112    24 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	Fifo8                      xmit_fifo;            /*   136    24 */
	uint8_t                    recv_fifo_itl;        /*   160     1 */

	/* XXX 7 bytes hole, try to pack */

	QEMUTimer *                fifo_timeout_timer;   /*   168     8 */
	int                        timeout_ipending;     /*   176     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   char_transmit_time;   /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        poll_msl;             /*   192     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUTimer *                modem_status_poll;    /*   200     8 */
	MemoryRegion               io;                   /*   208   256 */

	/* size: 464, cachelines: 8, members: 32 */
	/* sum members: 443, holes: 5, sum holes: 21 */
	/* last cacheline: 16 bytes */
};
struct ISASerialState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint32_t                   index;                /*   128     4 */
	uint32_t                   iobase;               /*   132     4 */
	uint32_t                   isairq;               /*   136     4 */

	/* XXX 4 bytes hole, try to pack */

	SerialState                state;                /*   144   464 */

	/* size: 608, cachelines: 10, members: 5 */
	/* sum members: 604, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct PCISerialState {
	PCIDevice                  dev;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	SerialState                state;                /*  2288   464 */
	/* --- cacheline 43 boundary (2752 bytes) --- */
	uint8_t                    prog_if;              /*  2752     1 */

	/* Force padding: */
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;

	/* size: 2768, cachelines: 44, members: 3 */
	/* padding: 15 */
	/* last cacheline: 16 bytes */
};
struct PCIMultiSerialState {
	PCIDevice                  dev;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	MemoryRegion               iobar;                /*  2288   256 */
	/* --- cacheline 39 boundary (2496 bytes) was 48 bytes ago --- */
	uint32_t                   ports;                /*  2544     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     name[4];              /*  2552    32 */

	/* XXX 8 bytes hole, try to pack */

	/* --- cacheline 40 boundary (2560 bytes) was 32 bytes ago --- */
	SerialState                state[4];             /*  2592  1856 */
	/* --- cacheline 69 boundary (4416 bytes) was 32 bytes ago --- */
	uint32_t                   level[4];             /*  4448    16 */
	qemu_irq *                 irqs;                 /*  4464     8 */
	uint8_t                    prog_if;              /*  4472     1 */

	/* size: 4480, cachelines: 70, members: 8 */
	/* sum members: 4461, holes: 2, sum holes: 12 */
	/* padding: 7 */
};
struct VirtConsole {
	VirtIOSerialPort           parent_obj;           /*     0   208 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	CharBackend                chr;                  /*   208    48 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	guint                      watch;                /*   256     4 */

	/* size: 264, cachelines: 5, members: 3 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
struct DebugconState {
	MemoryRegion               io;                   /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	CharBackend                chr;                  /*   256    48 */
	uint32_t                   readback;             /*   304     4 */

	/* Force padding: */
	uint32_t                   :32;
	uint32_t                   :32;
	uint32_t                   :32;

	/* size: 320, cachelines: 5, members: 3 */
	/* padding: 12 */
};
struct ISADebugconState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint32_t                   iobase;               /*   128     4 */

	/* XXX 12 bytes hole, try to pack */

	DebugconState              state;                /*   144   320 */

	/* size: 464, cachelines: 8, members: 3 */
	/* sum members: 452, holes: 1, sum holes: 12 */
	/* last cacheline: 16 bytes */
};
struct DeviceListener {
	void                       (*realize)(DeviceListener *, DeviceState *); /*     0     8 */
	void                       (*unrealize)(DeviceListener *, DeviceState *); /*     8     8 */
	struct {
		struct DeviceListener * tqe_next;        /*    16     8 */
		struct DeviceListener * * tqe_prev;      /*    24     8 */
	} link;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct device_listeners {
	struct DeviceListener *    tqh_first;            /*     0     8 */
	struct DeviceListener * *  tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct IRQState {
	Object                     parent_obj;           /*     0    40 */
	qemu_irq_handler           handler;              /*    40     8 */
	void *                     opaque;               /*    48     8 */
	int                        n;                    /*    56     4 */

	/* size: 64, cachelines: 1, members: 4 */
	/* padding: 4 */
};
struct SysBusFind {
	void *                     opaque;               /*     0     8 */
	FindSysbusDeviceFunc *     func;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct uboot_image_header {
	uint32_t                   ih_magic;             /*     0     4 */
	uint32_t                   ih_hcrc;              /*     4     4 */
	uint32_t                   ih_time;              /*     8     4 */
	uint32_t                   ih_size;              /*    12     4 */
	uint32_t                   ih_load;              /*    16     4 */
	uint32_t                   ih_ep;                /*    20     4 */
	uint32_t                   ih_dcrc;              /*    24     4 */
	uint8_t                    ih_os;                /*    28     1 */
	uint8_t                    ih_arch;              /*    29     1 */
	uint8_t                    ih_type;              /*    30     1 */
	uint8_t                    ih_comp;              /*    31     1 */
	uint8_t                    ih_name[32];          /*    32    32 */

	/* size: 64, cachelines: 1, members: 12 */
};
struct z_stream_s {
	Bytef *                    next_in;              /*     0     8 */
	uInt                       avail_in;             /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	uLong                      total_in;             /*    16     8 */
	Bytef *                    next_out;             /*    24     8 */
	uInt                       avail_out;            /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	uLong                      total_out;            /*    40     8 */
	char *                     msg;                  /*    48     8 */
	struct internal_state *    state;                /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	alloc_func                 zalloc;               /*    64     8 */
	free_func                  zfree;                /*    72     8 */
	voidpf                     opaque;               /*    80     8 */
	int                        data_type;            /*    88     4 */

	/* XXX 4 bytes hole, try to pack */

	uLong                      adler;                /*    96     8 */
	uLong                      reserved;             /*   104     8 */

	/* size: 112, cachelines: 2, members: 14 */
	/* sum members: 100, holes: 3, sum holes: 12 */
	/* last cacheline: 48 bytes */
};
struct internal_state {
	int                        dummy;                /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct exec {
	uint32_t                   a_info;               /*     0     4 */
	uint32_t                   a_text;               /*     4     4 */
	uint32_t                   a_data;               /*     8     4 */
	uint32_t                   a_bss;                /*    12     4 */
	uint32_t                   a_syms;               /*    16     4 */
	uint32_t                   a_entry;              /*    20     4 */
	uint32_t                   a_trsize;             /*    24     4 */
	uint32_t                   a_drsize;             /*    28     4 */

	/* size: 32, cachelines: 1, members: 8 */
	/* last cacheline: 32 bytes */
};
struct elf32_rela {
	Elf32_Addr                 r_offset;             /*     0     4 */
	Elf32_Word                 r_info;               /*     4     4 */
	Elf32_Sword                r_addend;             /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
struct elf64_rela {
	Elf64_Addr                 r_offset;             /*     0     8 */
	Elf64_Xword                r_info;               /*     8     8 */
	Elf64_Sxword               r_addend;             /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct Rom {
	char *                     name;                 /*     0     8 */
	char *                     path;                 /*     8     8 */
	size_t                     romsize;              /*    16     8 */
	size_t                     datasize;             /*    24     8 */
	uint8_t *                  data;                 /*    32     8 */
	MemoryRegion *             mr;                   /*    40     8 */
	AddressSpace *             as;                   /*    48     8 */
	int                        isrom;                /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     fw_dir;               /*    64     8 */
	char *                     fw_file;              /*    72     8 */
	hwaddr                     addr;                 /*    80     8 */
	struct {
		struct Rom *       tqe_next;             /*    88     8 */
		struct Rom * *     tqe_prev;             /*    96     8 */
	} next;                                          /*    88    16 */

	/* size: 104, cachelines: 2, members: 12 */
	/* sum members: 100, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct RegisterInfo {
	DeviceState                parent_obj;           /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	void *                     data;                 /*   112     8 */
	int                        data_size;            /*   120     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 2 boundary (128 bytes) --- */
	const RegisterAccessInfo  * access;              /*   128     8 */
	void *                     opaque;               /*   136     8 */

	/* size: 144, cachelines: 3, members: 5 */
	/* sum members: 140, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct RegisterAccessInfo {
	const char  *              name;                 /*     0     8 */
	uint64_t                   ro;                   /*     8     8 */
	uint64_t                   w1c;                  /*    16     8 */
	uint64_t                   reset;                /*    24     8 */
	uint64_t                   cor;                  /*    32     8 */
	uint64_t                   rsvd;                 /*    40     8 */
	uint64_t                   unimp;                /*    48     8 */
	uint64_t                   (*pre_write)(RegisterInfo *, uint64_t); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*post_write)(RegisterInfo *, uint64_t); /*    64     8 */
	uint64_t                   (*post_read)(RegisterInfo *, uint64_t); /*    72     8 */
	hwaddr                     addr;                 /*    80     8 */

	/* size: 88, cachelines: 2, members: 11 */
	/* last cacheline: 24 bytes */
};
struct RegisterInfoArray {
	MemoryRegion               mem;                  /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	int                        num_elements;         /*   256     4 */

	/* XXX 4 bytes hole, try to pack */

	RegisterInfo * *           r;                    /*   264     8 */
	_Bool                      debug;                /*   272     1 */

	/* XXX 7 bytes hole, try to pack */

	const char  *              prefix;               /*   280     8 */

	/* size: 288, cachelines: 5, members: 5 */
	/* sum members: 277, holes: 2, sum holes: 11 */
	/* last cacheline: 32 bytes */
};
struct OrIRQState {
	DeviceState                parent_obj;           /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	qemu_irq                   out_irq;              /*   112     8 */
	qemu_irq *                 in_irqs;              /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	_Bool                      levels[16];           /*   128    16 */
	uint16_t                   num_lines;            /*   144     2 */

	/* size: 152, cachelines: 3, members: 5 */
	/* padding: 6 */
	/* last cacheline: 24 bytes */
};
struct CirrusVGAState {
	VGACommonState             vga;                  /*     0 68336 */
	/* --- cacheline 1067 boundary (68288 bytes) was 48 bytes ago --- */
	MemoryRegion               cirrus_vga_io;        /* 68336   256 */
	/* --- cacheline 1071 boundary (68544 bytes) was 48 bytes ago --- */
	MemoryRegion               cirrus_linear_io;     /* 68592   256 */
	/* --- cacheline 1075 boundary (68800 bytes) was 48 bytes ago --- */
	MemoryRegion               cirrus_linear_bitblt_io; /* 68848   256 */
	/* --- cacheline 1079 boundary (69056 bytes) was 48 bytes ago --- */
	MemoryRegion               cirrus_mmio_io;       /* 69104   256 */
	/* --- cacheline 1083 boundary (69312 bytes) was 48 bytes ago --- */
	MemoryRegion               pci_bar;              /* 69360   256 */
	/* --- cacheline 1087 boundary (69568 bytes) was 48 bytes ago --- */
	_Bool                      linear_vram;          /* 69616     1 */

	/* XXX 15 bytes hole, try to pack */

	/* --- cacheline 1088 boundary (69632 bytes) --- */
	MemoryRegion               low_mem_container;    /* 69632   256 */
	/* --- cacheline 1092 boundary (69888 bytes) --- */
	MemoryRegion               low_mem;              /* 69888   256 */
	/* --- cacheline 1096 boundary (70144 bytes) --- */
	MemoryRegion               cirrus_bank[2];       /* 70144   512 */
	/* --- cacheline 1104 boundary (70656 bytes) --- */
	uint32_t                   cirrus_addr_mask;     /* 70656     4 */
	uint32_t                   linear_mmio_mask;     /* 70660     4 */
	uint8_t                    cirrus_shadow_gr0;    /* 70664     1 */
	uint8_t                    cirrus_shadow_gr1;    /* 70665     1 */
	uint8_t                    cirrus_hidden_dac_lockindex; /* 70666     1 */
	uint8_t                    cirrus_hidden_dac_data; /* 70667     1 */
	uint32_t                   cirrus_bank_base[2];  /* 70668     8 */
	uint32_t                   cirrus_bank_limit[2]; /* 70676     8 */
	uint8_t                    cirrus_hidden_palette[48]; /* 70684    48 */
	/* --- cacheline 1105 boundary (70720 bytes) was 12 bytes ago --- */
	int                        cirrus_blt_pixelwidth; /* 70732     4 */
	int                        cirrus_blt_width;     /* 70736     4 */
	int                        cirrus_blt_height;    /* 70740     4 */
	int                        cirrus_blt_dstpitch;  /* 70744     4 */
	int                        cirrus_blt_srcpitch;  /* 70748     4 */
	uint32_t                   cirrus_blt_fgcol;     /* 70752     4 */
	uint32_t                   cirrus_blt_bgcol;     /* 70756     4 */
	uint32_t                   cirrus_blt_dstaddr;   /* 70760     4 */
	uint32_t                   cirrus_blt_srcaddr;   /* 70764     4 */
	uint8_t                    cirrus_blt_mode;      /* 70768     1 */
	uint8_t                    cirrus_blt_modeext;   /* 70769     1 */

	/* XXX 6 bytes hole, try to pack */

	cirrus_bitblt_rop_t        cirrus_rop;           /* 70776     8 */
	/* --- cacheline 1106 boundary (70784 bytes) --- */
	uint8_t                    cirrus_bltbuf[8192];  /* 70784  8192 */
	/* --- cacheline 1234 boundary (78976 bytes) --- */
	uint8_t *                  cirrus_srcptr;        /* 78976     8 */
	uint8_t *                  cirrus_srcptr_end;    /* 78984     8 */
	uint32_t                   cirrus_srccounter;    /* 78992     4 */
	int                        last_hw_cursor_size;  /* 78996     4 */
	int                        last_hw_cursor_x;     /* 79000     4 */
	int                        last_hw_cursor_y;     /* 79004     4 */
	int                        last_hw_cursor_y_start; /* 79008     4 */
	int                        last_hw_cursor_y_end; /* 79012     4 */
	int                        real_vram_size;       /* 79016     4 */
	int                        device_id;            /* 79020     4 */
	int                        bustype;              /* 79024     4 */

	/* Force padding: */
	int                        :32;
	int                        :32;
	int                        :32;

	/* size: 79040, cachelines: 1235, members: 43 */
	/* sum members: 79007, holes: 2, sum holes: 21 */
	/* padding: 12 */
};
struct PCICirrusVGAState {
	PCIDevice                  dev;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	CirrusVGAState             cirrus_vga;           /*  2288 79040 */

	/* size: 81328, cachelines: 1271, members: 2 */
	/* last cacheline: 48 bytes */
};
struct ISACirrusVGAState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	CirrusVGAState             cirrus_vga;           /*   128 79040 */

	/* size: 79168, cachelines: 1237, members: 2 */
};
struct PCIVGAState {
	PCIDevice                  dev;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	VGACommonState             vga;                  /*  2288 68336 */
	/* --- cacheline 1103 boundary (70592 bytes) was 32 bytes ago --- */
	uint32_t                   flags;                /* 70624     4 */

	/* XXX 12 bytes hole, try to pack */

	MemoryRegion               mmio;                 /* 70640   256 */
	/* --- cacheline 1107 boundary (70848 bytes) was 48 bytes ago --- */
	MemoryRegion               mrs[3];               /* 70896   768 */

	/* size: 71664, cachelines: 1120, members: 5 */
	/* sum members: 71652, holes: 1, sum holes: 12 */
	/* last cacheline: 48 bytes */
};
struct ISAVGAState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	struct VGACommonState      state;                /*   128 68336 */

	/* XXX last struct has 15 bytes of padding */

	/* --- cacheline 1069 boundary (68416 bytes) was 48 bytes ago --- */
	PortioList                 portio_vga;           /* 68464    64 */
	/* --- cacheline 1070 boundary (68480 bytes) was 48 bytes ago --- */
	PortioList                 portio_vbe;           /* 68528    64 */

	/* size: 68592, cachelines: 1072, members: 4 */
	/* paddings: 1, sum paddings: 15 */
	/* last cacheline: 48 bytes */
};
struct PixelFormat {
	uint8_t                    bits_per_pixel;       /*     0     1 */
	uint8_t                    bytes_per_pixel;      /*     1     1 */
	uint8_t                    depth;                /*     2     1 */

	/* XXX 1 byte hole, try to pack */

	uint32_t                   rmask;                /*     4     4 */
	uint32_t                   gmask;                /*     8     4 */
	uint32_t                   bmask;                /*    12     4 */
	uint32_t                   amask;                /*    16     4 */
	uint8_t                    rshift;               /*    20     1 */
	uint8_t                    gshift;               /*    21     1 */
	uint8_t                    bshift;               /*    22     1 */
	uint8_t                    ashift;               /*    23     1 */
	uint8_t                    rmax;                 /*    24     1 */
	uint8_t                    gmax;                 /*    25     1 */
	uint8_t                    bmax;                 /*    26     1 */
	uint8_t                    amax;                 /*    27     1 */
	uint8_t                    rbits;                /*    28     1 */
	uint8_t                    gbits;                /*    29     1 */
	uint8_t                    bbits;                /*    30     1 */
	uint8_t                    abits;                /*    31     1 */

	/* size: 32, cachelines: 1, members: 19 */
	/* sum members: 31, holes: 1, sum holes: 1 */
	/* last cacheline: 32 bytes */
};
struct vmsvga_rect_s {
	int                        x;                    /*     0     4 */
	int                        y;                    /*     4     4 */
	int                        w;                    /*     8     4 */
	int                        h;                    /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct vmsvga_state_s {
	VGACommonState             vga;                  /*     0 68336 */
	/* --- cacheline 1067 boundary (68288 bytes) was 48 bytes ago --- */
	int                        invalidated;          /* 68336     4 */
	int                        enable;               /* 68340     4 */
	int                        config;               /* 68344     4 */
	struct {
		int                id;                   /* 68348     4 */
		/* --- cacheline 1068 boundary (68352 bytes) --- */
		int                x;                    /* 68352     4 */
		int                y;                    /* 68356     4 */
		int                on;                   /* 68360     4 */
	} cursor;                                        /* 68348    16 */
	int                        index;                /* 68364     4 */
	int                        scratch_size;         /* 68368     4 */

	/* XXX 4 bytes hole, try to pack */

	uint32_t *                 scratch;              /* 68376     8 */
	int                        new_width;            /* 68384     4 */
	int                        new_height;           /* 68388     4 */
	int                        new_depth;            /* 68392     4 */
	uint32_t                   guest;                /* 68396     4 */
	uint32_t                   svgaid;               /* 68400     4 */
	int                        syncing;              /* 68404     4 */

	/* XXX 8 bytes hole, try to pack */

	/* --- cacheline 1069 boundary (68416 bytes) --- */
	MemoryRegion               fifo_ram;             /* 68416   256 */
	/* --- cacheline 1073 boundary (68672 bytes) --- */
	uint8_t *                  fifo_ptr;             /* 68672     8 */
	unsigned int               fifo_size;            /* 68680     4 */

	/* XXX 4 bytes hole, try to pack */

	uint32_t *                 fifo;                 /* 68688     8 */
	uint32_t                   fifo_min;             /* 68696     4 */
	uint32_t                   fifo_max;             /* 68700     4 */
	uint32_t                   fifo_next;            /* 68704     4 */
	uint32_t                   fifo_stop;            /* 68708     4 */
	struct vmsvga_rect_s       redraw_fifo[512];     /* 68712  8192 */
	/* --- cacheline 1201 boundary (76864 bytes) was 40 bytes ago --- */
	int                        redraw_fifo_first;    /* 76904     4 */
	int                        redraw_fifo_last;     /* 76908     4 */

	/* size: 76912, cachelines: 1202, members: 25 */
	/* sum members: 76896, holes: 3, sum holes: 16 */
	/* last cacheline: 48 bytes */
};
struct pci_vmsvga_state_s {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	struct vmsvga_state_s      chip;                 /*  2288 76912 */
	/* --- cacheline 1237 boundary (79168 bytes) was 32 bytes ago --- */
	MemoryRegion               io_bar;               /* 79200   256 */

	/* size: 79456, cachelines: 1242, members: 3 */
	/* last cacheline: 32 bytes */
};
struct vmsvga_cursor_definition_s {
	uint32_t                   width;                /*     0     4 */
	uint32_t                   height;               /*     4     4 */
	int                        id;                   /*     8     4 */
	uint32_t                   bpp;                  /*    12     4 */
	int                        hot_x;                /*    16     4 */
	int                        hot_y;                /*    20     4 */
	uint32_t                   mask[1024];           /*    24  4096 */
	/* --- cacheline 64 boundary (4096 bytes) was 24 bytes ago --- */
	uint32_t                   image[4096];          /*  4120 16384 */

	/* size: 20504, cachelines: 321, members: 8 */
	/* last cacheline: 24 bytes */
};
struct I8257Regs {
	int                        now[2];               /*     0     8 */
	uint16_t                   base[2];              /*     8     4 */
	uint8_t                    mode;                 /*    12     1 */
	uint8_t                    page;                 /*    13     1 */
	uint8_t                    pageh;                /*    14     1 */
	uint8_t                    dack;                 /*    15     1 */
	uint8_t                    eop;                  /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	IsaDmaTransferHandler      transfer_handler;     /*    24     8 */
	void *                     opaque;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 9 */
	/* sum members: 33, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
struct I8257State {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int32_t                    base;                 /*   128     4 */
	int32_t                    page_base;            /*   132     4 */
	int32_t                    pageh_base;           /*   136     4 */
	int32_t                    dshift;               /*   140     4 */
	uint8_t                    status;               /*   144     1 */
	uint8_t                    command;              /*   145     1 */
	uint8_t                    mask;                 /*   146     1 */
	uint8_t                    flip_flop;            /*   147     1 */

	/* XXX 4 bytes hole, try to pack */

	I8257Regs                  regs[4];              /*   152   160 */

	/* XXX 8 bytes hole, try to pack */

	/* --- cacheline 5 boundary (320 bytes) --- */
	MemoryRegion               channel_io;           /*   320   256 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	MemoryRegion               cont_io;              /*   576   256 */
	/* --- cacheline 13 boundary (832 bytes) --- */
	QEMUBH *                   dma_bh;               /*   832     8 */
	_Bool                      dma_bh_scheduled;     /*   840     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        running;              /*   844     4 */
	PortioList                 portio_page;          /*   848    64 */
	/* --- cacheline 14 boundary (896 bytes) was 16 bytes ago --- */
	PortioList                 portio_pageh;         /*   912    64 */

	/* size: 976, cachelines: 16, members: 17 */
	/* sum members: 961, holes: 3, sum holes: 15 */
	/* last cacheline: 16 bytes */
};
struct I2CBus {
	BusState                   qbus;                 /*     0   104 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	struct {
		struct I2CNode *   lh_first;             /*   104     8 */
	} current_devs;                                  /*   104     8 */
	uint8_t                    saved_address;        /*   112     1 */
	_Bool                      broadcast;            /*   113     1 */

	/* size: 120, cachelines: 2, members: 4 */
	/* padding: 6 */
	/* last cacheline: 56 bytes */
};
struct I2CSlave {
	DeviceState                qdev;                 /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	uint8_t                    address;              /*   112     1 */

	/* size: 120, cachelines: 2, members: 2 */
	/* padding: 7 */
	/* last cacheline: 56 bytes */
};
struct I2CSlaveClass {
	DeviceClass                parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        (*init)(I2CSlave *);  /*   192     8 */
	int                        (*send)(I2CSlave *, uint8_t); /*   200     8 */
	int                        (*recv)(I2CSlave *);  /*   208     8 */
	void                       (*event)(I2CSlave *, enum i2c_event); /*   216     8 */

	/* size: 224, cachelines: 4, members: 5 */
	/* last cacheline: 32 bytes */
};
struct I2CNode {
	I2CSlave *                 elt;                  /*     0     8 */
	struct {
		struct I2CNode *   le_next;              /*     8     8 */
		struct I2CNode * * le_prev;              /*    16     8 */
	} next;                                          /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
struct SMBusDevice {
	I2CSlave                   i2c;                  /*     0   120 */
	/* --- cacheline 1 boundary (64 bytes) was 56 bytes ago --- */
	int                        mode;                 /*   120     4 */
	int                        data_len;             /*   124     4 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint8_t                    data_buf[34];         /*   128    34 */
	uint8_t                    command;              /*   162     1 */

	/* size: 168, cachelines: 3, members: 5 */
	/* padding: 5 */
	/* last cacheline: 40 bytes */
};
struct SMBusDeviceClass {
	I2CSlaveClass              parent_class;         /*     0   224 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	int                        (*init)(SMBusDevice *); /*   224     8 */
	void                       (*quick_cmd)(SMBusDevice *, uint8_t); /*   232     8 */
	void                       (*send_byte)(SMBusDevice *, uint8_t); /*   240     8 */
	uint8_t                    (*receive_byte)(SMBusDevice *); /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	void                       (*write_data)(SMBusDevice *, uint8_t, uint8_t *, int); /*   256     8 */
	uint8_t                    (*read_data)(SMBusDevice *, uint8_t, int); /*   264     8 */

	/* size: 272, cachelines: 5, members: 7 */
	/* last cacheline: 16 bytes */
};
struct SMBusEEPROMDevice {
	SMBusDevice                smbusdev;             /*     0   168 */
	/* --- cacheline 2 boundary (128 bytes) was 40 bytes ago --- */
	void *                     data;                 /*   168     8 */
	uint8_t                    offset;               /*   176     1 */

	/* size: 184, cachelines: 3, members: 3 */
	/* padding: 7 */
	/* last cacheline: 56 bytes */
};
struct ICH9SMBState {
	PCIDevice                  dev;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	PMSMBus                    smb;                  /*  2288   320 */

	/* size: 2608, cachelines: 41, members: 2 */
	/* last cacheline: 48 bytes */
};
struct TrimAIOCB {
	BlockAIOCB                 common;               /*     0    40 */
	BlockBackend *             blk;                  /*    40     8 */
	QEMUBH *                   bh;                   /*    48     8 */
	int                        ret;                  /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	QEMUIOVector *             qiov;                 /*    64     8 */
	BlockAIOCB *               aiocb;                /*    72     8 */
	int                        i;                    /*    80     4 */
	int                        j;                    /*    84     4 */

	/* size: 88, cachelines: 2, members: 8 */
	/* sum members: 84, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct AtapiCmd {
	void                       (*handler)(IDEState *, uint8_t *); /*     0     8 */
	int                        flags;                /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct IDEDeviceClass {
	DeviceClass                parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        (*init)(IDEDevice *); /*   192     8 */

	/* size: 200, cachelines: 4, members: 2 */
	/* last cacheline: 8 bytes */
};
struct IDEDrive {
	IDEDevice                  dev;                  /*     0   216 */

	/* size: 216, cachelines: 4, members: 1 */
	/* last cacheline: 24 bytes */
};
struct BMDMAState {
	IDEDMA                     dma;                  /*     0    56 */
	uint8_t                    cmd;                  /*    56     1 */
	uint8_t                    status;               /*    57     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   addr;                 /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	IDEBus *                   bus;                  /*    64     8 */
	uint32_t                   cur_addr;             /*    72     4 */
	uint32_t                   cur_prd_last;         /*    76     4 */
	uint32_t                   cur_prd_addr;         /*    80     4 */
	uint32_t                   cur_prd_len;          /*    84     4 */
	BlockCompletionFunc *      dma_cb;               /*    88     8 */
	MemoryRegion               addr_ioport;          /*    96   256 */
	/* --- cacheline 5 boundary (320 bytes) was 32 bytes ago --- */
	MemoryRegion               extra_io;             /*   352   256 */
	/* --- cacheline 9 boundary (576 bytes) was 32 bytes ago --- */
	qemu_irq                   irq;                  /*   608     8 */
	uint8_t                    migration_compat_status; /*   616     1 */
	uint8_t                    migration_retry_unit; /*   617     1 */

	/* XXX 6 bytes hole, try to pack */

	int64_t                    migration_retry_sector_num; /*   624     8 */
	uint32_t                   migration_retry_nsector; /*   632     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 10 boundary (640 bytes) --- */
	struct PCIIDEState *       pci_dev;              /*   640     8 */

	/* size: 656, cachelines: 11, members: 18 */
	/* sum members: 636, holes: 3, sum holes: 12 */
	/* padding: 8 */
	/* last cacheline: 16 bytes */
};
struct PCIIDEState {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	IDEBus                     bus[2];               /*  2288  4544 */
	/* --- cacheline 106 boundary (6784 bytes) was 48 bytes ago --- */
	BMDMAState                 bmdma[2];             /*  6832  1312 */
	/* --- cacheline 127 boundary (8128 bytes) was 16 bytes ago --- */
	uint32_t                   secondary;            /*  8144     4 */

	/* XXX 12 bytes hole, try to pack */

	MemoryRegion               bmdma_bar;            /*  8160   256 */
	/* --- cacheline 131 boundary (8384 bytes) was 32 bytes ago --- */
	CMD646BAR                  cmd646_bar[2];        /*  8416  1056 */

	/* size: 9472, cachelines: 148, members: 6 */
	/* sum members: 9460, holes: 1, sum holes: 12 */
};
struct CMD646BAR {
	MemoryRegion               cmd;                  /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	MemoryRegion               data;                 /*   256   256 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	IDEBus *                   bus;                  /*   512     8 */
	struct PCIIDEState *       pci_dev;              /*   520     8 */

	/* size: 528, cachelines: 9, members: 4 */
	/* last cacheline: 16 bytes */
};
struct ISAIDEState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	IDEBus                     bus;                  /*   128  2272 */
	/* --- cacheline 37 boundary (2368 bytes) was 32 bytes ago --- */
	uint32_t                   iobase;               /*  2400     4 */
	uint32_t                   iobase2;              /*  2404     4 */
	uint32_t                   isairq;               /*  2408     4 */

	/* XXX 4 bytes hole, try to pack */

	qemu_irq                   irq;                  /*  2416     8 */

	/* size: 2424, cachelines: 38, members: 6 */
	/* sum members: 2420, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct AllwinnerAHCIState {
	SysbusAHCIState            parent_obj;           /*     0  1376 */
	/* --- cacheline 21 boundary (1344 bytes) was 32 bytes ago --- */
	MemoryRegion               mmio;                 /*  1376   256 */
	/* --- cacheline 25 boundary (1600 bytes) was 32 bytes ago --- */
	uint32_t                   regs[32];             /*  1632   128 */

	/* size: 1760, cachelines: 28, members: 3 */
	/* last cacheline: 32 bytes */
};
struct AHCI_SG {
	uint64_t                   addr;                 /*     0     8 */
	uint32_t                   reserved;             /*     8     4 */
	uint32_t                   flags_size;           /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct NCQFrame {
	uint8_t                    fis_type;             /*     0     1 */
	uint8_t                    c;                    /*     1     1 */
	uint8_t                    command;              /*     2     1 */
	uint8_t                    sector_count_low;     /*     3     1 */
	uint8_t                    lba0;                 /*     4     1 */
	uint8_t                    lba1;                 /*     5     1 */
	uint8_t                    lba2;                 /*     6     1 */
	uint8_t                    fua;                  /*     7     1 */
	uint8_t                    lba3;                 /*     8     1 */
	uint8_t                    lba4;                 /*     9     1 */
	uint8_t                    lba5;                 /*    10     1 */
	uint8_t                    sector_count_high;    /*    11     1 */
	uint8_t                    tag;                  /*    12     1 */
	uint8_t                    prio;                 /*    13     1 */
	uint8_t                    icc;                  /*    14     1 */
	uint8_t                    control;              /*    15     1 */
	uint8_t                    aux0;                 /*    16     1 */
	uint8_t                    aux1;                 /*    17     1 */
	uint8_t                    aux2;                 /*    18     1 */
	uint8_t                    aux3;                 /*    19     1 */

	/* size: 20, cachelines: 1, members: 20 */
	/* last cacheline: 20 bytes */
};
struct SDBFIS {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    flags;                /*     1     1 */
	uint8_t                    status;               /*     2     1 */
	uint8_t                    error;                /*     3     1 */
	uint32_t                   payload;              /*     4     4 */

	/* size: 8, cachelines: 1, members: 5 */
	/* last cacheline: 8 bytes */
};
struct SysbusAHCIState {
	SysBusDevice               parent_obj;           /*     0   768 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	AHCIState                  ahci;                 /*   768   592 */
	/* --- cacheline 21 boundary (1344 bytes) was 16 bytes ago --- */
	uint32_t                   num_ports;            /*  1360     4 */

	/* Force padding: */
	uint32_t                   :32;
	uint32_t                   :32;
	uint32_t                   :32;

	/* size: 1376, cachelines: 22, members: 3 */
	/* padding: 12 */
	/* last cacheline: 32 bytes */
};
struct KBDState {
	uint8_t                    write_cmd;            /*     0     1 */
	uint8_t                    status;               /*     1     1 */
	uint8_t                    mode;                 /*     2     1 */
	uint8_t                    outport;              /*     3     1 */
	_Bool                      outport_present;      /*     4     1 */
	uint8_t                    pending;              /*     5     1 */

	/* XXX 2 bytes hole, try to pack */

	void *                     kbd;                  /*     8     8 */
	void *                     mouse;                /*    16     8 */
	qemu_irq                   irq_kbd;              /*    24     8 */
	qemu_irq                   irq_mouse;            /*    32     8 */
	qemu_irq                   a20_out;              /*    40     8 */
	hwaddr                     mask;                 /*    48     8 */

	/* size: 56, cachelines: 1, members: 12 */
	/* sum members: 54, holes: 1, sum holes: 2 */
	/* last cacheline: 56 bytes */
};
struct ISAKBDState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	KBDState                   kbd;                  /*   128    56 */

	/* XXX 8 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) --- */
	MemoryRegion               io[2];                /*   192   512 */

	/* size: 704, cachelines: 11, members: 3 */
	/* sum members: 696, holes: 1, sum holes: 8 */
};
struct VMMouseState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint32_t                   queue[1024];          /*   128  4096 */
	/* --- cacheline 66 boundary (4224 bytes) --- */
	int32_t                    queue_size;           /*  4224     4 */
	uint16_t                   nb_queue;             /*  4228     2 */
	uint16_t                   status;               /*  4230     2 */
	uint8_t                    absolute;             /*  4232     1 */

	/* XXX 7 bytes hole, try to pack */

	QEMUPutMouseEntry *        entry;                /*  4240     8 */
	void *                     ps2_mouse;            /*  4248     8 */

	/* size: 4256, cachelines: 67, members: 8 */
	/* sum members: 4249, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct virtio_input_absinfo {
	uint32_t                   min;                  /*     0     4 */
	uint32_t                   max;                  /*     4     4 */
	uint32_t                   fuzz;                 /*     8     4 */
	uint32_t                   flat;                 /*    12     4 */
	uint32_t                   res;                  /*    16     4 */

	/* size: 20, cachelines: 1, members: 5 */
	/* last cacheline: 20 bytes */
};
struct virtio_input_devids {
	uint16_t                   bustype;              /*     0     2 */
	uint16_t                   vendor;               /*     2     2 */
	uint16_t                   product;              /*     4     2 */
	uint16_t                   version;              /*     6     2 */

	/* size: 8, cachelines: 1, members: 4 */
	/* last cacheline: 8 bytes */
};
struct virtio_input_config {
	uint8_t                    select;               /*     0     1 */
	uint8_t                    subsel;               /*     1     1 */
	uint8_t                    size;                 /*     2     1 */
	uint8_t                    reserved[5];          /*     3     5 */
	union {
		char               string[128];          /*     8   128 */
		uint8_t            bitmap[128];          /*     8   128 */
		struct virtio_input_absinfo abs;         /*     8    20 */
		struct virtio_input_devids ids;          /*     8     8 */
	} u;                                             /*     8   128 */

	/* size: 136, cachelines: 3, members: 5 */
	/* last cacheline: 8 bytes */
};
struct virtio_input_event {
	uint16_t                   type;                 /*     0     2 */
	uint16_t                   code;                 /*     2     2 */
	uint32_t                   value;                /*     4     4 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct VirtIOInput {
	VirtIODevice               parent_obj;           /*     0   224 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	uint8_t                    cfg_select;           /*   224     1 */
	uint8_t                    cfg_subsel;           /*   225     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   cfg_size;             /*   228     4 */
	struct {
		struct VirtIOInputConfig * tqh_first;    /*   232     8 */
		struct VirtIOInputConfig * * tqh_last;   /*   240     8 */
	} cfg_list;                                      /*   232    16 */
	VirtQueue *                evt;                  /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	VirtQueue *                sts;                  /*   256     8 */
	char *                     serial;               /*   264     8 */
	virtio_input_event *       queue;                /*   272     8 */
	uint32_t                   qindex;               /*   280     4 */
	uint32_t                   qsize;                /*   284     4 */
	_Bool                      active;               /*   288     1 */

	/* size: 296, cachelines: 5, members: 12 */
	/* sum members: 287, holes: 1, sum holes: 2 */
	/* padding: 7 */
	/* last cacheline: 40 bytes */
};
struct VirtIOInputClass {
	VirtioDeviceClass          parent;               /*     0   336 */
	/* --- cacheline 5 boundary (320 bytes) was 16 bytes ago --- */
	DeviceRealize              realize;              /*   336     8 */
	DeviceUnrealize            unrealize;            /*   344     8 */
	void                       (*change_active)(VirtIOInput *); /*   352     8 */
	void                       (*handle_status)(VirtIOInput *, virtio_input_event *); /*   360     8 */

	/* size: 368, cachelines: 6, members: 5 */
	/* last cacheline: 48 bytes */
};
struct VirtIOInputConfig {
	virtio_input_config        config;               /*     0   136 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	struct {
		struct VirtIOInputConfig * tqe_next;     /*   136     8 */
		struct VirtIOInputConfig * * tqe_prev;   /*   144     8 */
	} node;                                          /*   136    16 */

	/* size: 152, cachelines: 3, members: 2 */
	/* last cacheline: 24 bytes */
};
struct VirtIOInputHID {
	VirtIOInput                parent_obj;           /*     0   296 */
	/* --- cacheline 4 boundary (256 bytes) was 40 bytes ago --- */
	char *                     display;              /*   296     8 */
	uint32_t                   head;                 /*   304     4 */

	/* XXX 4 bytes hole, try to pack */

	QemuInputHandler *         handler;              /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	QemuInputHandlerState *    hs;                   /*   320     8 */
	int                        ledstate;             /*   328     4 */

	/* size: 336, cachelines: 6, members: 6 */
	/* sum members: 328, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct VirtIOInputHost {
	VirtIOInput                parent_obj;           /*     0   296 */
	/* --- cacheline 4 boundary (256 bytes) was 40 bytes ago --- */
	char *                     evdev;                /*   296     8 */
	int                        fd;                   /*   304     4 */

	/* size: 312, cachelines: 5, members: 3 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct input_event {
	struct timeval             time;                 /*     0    16 */
	uint16_t                   type;                 /*    16     2 */
	uint16_t                   code;                 /*    18     2 */
	int32_t                    value;                /*    20     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct input_id {
	uint16_t                   bustype;              /*     0     2 */
	uint16_t                   vendor;               /*     2     2 */
	uint16_t                   product;              /*     4     2 */
	uint16_t                   version;              /*     6     2 */

	/* size: 8, cachelines: 1, members: 4 */
	/* last cacheline: 8 bytes */
};
struct input_absinfo {
	int32_t                    value;                /*     0     4 */
	int32_t                    minimum;              /*     4     4 */
	int32_t                    maximum;              /*     8     4 */
	int32_t                    fuzz;                 /*    12     4 */
	int32_t                    flat;                 /*    16     4 */
	int32_t                    resolution;           /*    20     4 */

	/* size: 24, cachelines: 1, members: 6 */
	/* last cacheline: 24 bytes */
};
struct PICClass {
	PICCommonClass             parent_class;         /*     0   208 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	DeviceRealize              parent_realize;       /*   208     8 */

	/* size: 216, cachelines: 4, members: 2 */
	/* last cacheline: 24 bytes */
};
struct IPackBus {
	BusState                   parent_obj;           /*     0   104 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	uint8_t                    n_slots;              /*   104     1 */
	uint8_t                    free_slot;            /*   105     1 */

	/* XXX 6 bytes hole, try to pack */

	qemu_irq_handler           set_irq;              /*   112     8 */

	/* size: 120, cachelines: 2, members: 4 */
	/* sum members: 114, holes: 1, sum holes: 6 */
	/* last cacheline: 56 bytes */
};
struct IPMIBmc {
	DeviceState                parent;               /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	uint8_t                    slave_addr;           /*   112     1 */

	/* XXX 7 bytes hole, try to pack */

	IPMIInterface *            intf;                 /*   120     8 */

	/* size: 128, cachelines: 2, members: 3 */
	/* sum members: 121, holes: 1, sum holes: 7 */
};
struct IPMIBmcClass {
	DeviceClass                parent;               /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	void                       (*handle_reset)(struct IPMIBmc *); /*   192     8 */
	void                       (*handle_command)(struct IPMIBmc *, uint8_t *, unsigned int, unsigned int, uint8_t); /*   200     8 */

	/* size: 208, cachelines: 4, members: 3 */
	/* last cacheline: 16 bytes */
};
struct ipmi_sdr_header {
	uint8_t                    rec_id[2];            /*     0     2 */
	uint8_t                    sdr_version;          /*     2     1 */
	uint8_t                    rec_type;             /*     3     1 */
	uint8_t                    rec_length;           /*     4     1 */

	/* size: 5, cachelines: 1, members: 4 */
	/* last cacheline: 5 bytes */
};
struct ipmi_sdr_compact {
	struct ipmi_sdr_header     header;               /*     0     5 */
	uint8_t                    sensor_owner_id;      /*     5     1 */
	uint8_t                    sensor_owner_lun;     /*     6     1 */
	uint8_t                    sensor_owner_number;  /*     7     1 */
	uint8_t                    entity_id;            /*     8     1 */
	uint8_t                    entity_instance;      /*     9     1 */
	uint8_t                    sensor_init;          /*    10     1 */
	uint8_t                    sensor_caps;          /*    11     1 */
	uint8_t                    sensor_type;          /*    12     1 */
	uint8_t                    reading_type;         /*    13     1 */
	uint8_t                    assert_mask[2];       /*    14     2 */
	uint8_t                    deassert_mask[2];     /*    16     2 */
	uint8_t                    discrete_mask[2];     /*    18     2 */
	uint8_t                    sensor_unit1;         /*    20     1 */
	uint8_t                    sensor_unit2;         /*    21     1 */
	uint8_t                    sensor_unit3;         /*    22     1 */
	uint8_t                    sensor_direction[2];  /*    23     2 */
	uint8_t                    positive_threshold;   /*    25     1 */
	uint8_t                    negative_threshold;   /*    26     1 */
	uint8_t                    reserved[3];          /*    27     3 */
	uint8_t                    oem;                  /*    30     1 */
	uint8_t                    id_str_len;           /*    31     1 */
	uint8_t                    id_string[16];        /*    32    16 */

	/* size: 48, cachelines: 1, members: 23 */
	/* last cacheline: 48 bytes */
};
struct ipmi_time {
	long int                   tv_sec;               /*     0     8 */
	long int                   tv_nsec;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct IPMISel {
	uint8_t                    sel[128][16];         /*     0  2048 */
	/* --- cacheline 32 boundary (2048 bytes) --- */
	unsigned int               next_free;            /*  2048     4 */

	/* XXX 4 bytes hole, try to pack */

	long int                   time_offset;          /*  2056     8 */
	uint16_t                   reservation;          /*  2064     2 */
	uint8_t                    last_addition[4];     /*  2066     4 */
	uint8_t                    last_clear[4];        /*  2070     4 */
	uint8_t                    overflow;             /*  2074     1 */

	/* size: 2080, cachelines: 33, members: 7 */
	/* sum members: 2071, holes: 1, sum holes: 4 */
	/* padding: 5 */
	/* last cacheline: 32 bytes */
};
struct IPMISdr {
	uint8_t                    sdr[16384];           /*     0 16384 */
	/* --- cacheline 256 boundary (16384 bytes) --- */
	unsigned int               next_free;            /* 16384     4 */
	uint16_t                   next_rec_id;          /* 16388     2 */
	uint16_t                   reservation;          /* 16390     2 */
	uint8_t                    last_addition[4];     /* 16392     4 */
	uint8_t                    last_clear[4];        /* 16396     4 */
	uint8_t                    overflow;             /* 16400     1 */

	/* size: 16404, cachelines: 257, members: 7 */
	/* padding: 3 */
	/* last cacheline: 20 bytes */
};
struct IPMISensor {
	uint8_t                    status;               /*     0     1 */
	uint8_t                    reading;              /*     1     1 */
	uint16_t                   states_suppt;         /*     2     2 */
	uint16_t                   assert_suppt;         /*     4     2 */
	uint16_t                   deassert_suppt;       /*     6     2 */
	uint16_t                   states;               /*     8     2 */
	uint16_t                   assert_states;        /*    10     2 */
	uint16_t                   deassert_states;      /*    12     2 */
	uint16_t                   assert_enable;        /*    14     2 */
	uint16_t                   deassert_enable;      /*    16     2 */
	uint8_t                    sensor_type;          /*    18     1 */
	uint8_t                    evt_reading_type_code; /*    19     1 */

	/* size: 20, cachelines: 1, members: 12 */
	/* last cacheline: 20 bytes */
};
struct IPMIBmcSim {
	IPMIBmc                    parent;               /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	QEMUTimer *                timer;                /*   128     8 */
	uint8_t                    bmc_global_enables;   /*   136     1 */
	uint8_t                    msg_flags;            /*   137     1 */
	_Bool                      watchdog_initialized; /*   138     1 */
	uint8_t                    watchdog_use;         /*   139     1 */
	uint8_t                    watchdog_action;      /*   140     1 */
	uint8_t                    watchdog_pretimeout;  /*   141     1 */
	_Bool                      watchdog_expired;     /*   142     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   watchdog_timeout;     /*   144     2 */
	_Bool                      watchdog_running;     /*   146     1 */
	_Bool                      watchdog_preaction_ran; /*   147     1 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    watchdog_expiry;      /*   152     8 */
	uint8_t                    device_id;            /*   160     1 */
	uint8_t                    ipmi_version;         /*   161     1 */
	uint8_t                    device_rev;           /*   162     1 */
	uint8_t                    fwrev1;               /*   163     1 */
	uint8_t                    fwrev2;               /*   164     1 */
	uint8_t                    mfg_id[3];            /*   165     3 */
	uint8_t                    product_id[2];        /*   168     2 */
	uint8_t                    restart_cause;        /*   170     1 */
	uint8_t                    acpi_power_state[2];  /*   171     2 */
	uint8_t                    uuid[16];             /*   173    16 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) --- */
	IPMISel                    sel;                  /*   192  2080 */
	/* --- cacheline 35 boundary (2240 bytes) was 32 bytes ago --- */
	IPMISdr                    sdr;                  /*  2272 16404 */
	/* --- cacheline 291 boundary (18624 bytes) was 52 bytes ago --- */
	IPMISensor                 sensors[20];          /* 18676   400 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 298 boundary (19072 bytes) was 8 bytes ago --- */
	const IPMINetfn  *         netfns[32];           /* 19080   256 */
	/* --- cacheline 302 boundary (19328 bytes) was 8 bytes ago --- */
	uint8_t                    evtbuf[16];           /* 19336    16 */
	struct {
		struct IPMIRcvBufEntry * tqh_first;      /* 19352     8 */
		struct IPMIRcvBufEntry * * tqh_last;     /* 19360     8 */
	} rcvbufs;                                       /* 19352    16 */

	/* size: 19368, cachelines: 303, members: 29 */
	/* sum members: 19356, holes: 4, sum holes: 12 */
	/* last cacheline: 40 bytes */
};
struct RspBuffer {
	uint8_t                    buffer[300];          /*     0   300 */
	/* --- cacheline 4 boundary (256 bytes) was 44 bytes ago --- */
	unsigned int               len;                  /*   300     4 */

	/* size: 304, cachelines: 5, members: 2 */
	/* last cacheline: 48 bytes */
};
struct IPMICmdHandler {
	void                       (*cmd_handler)(IPMIBmcSim *, uint8_t *, unsigned int, RspBuffer *); /*     0     8 */
	unsigned int               cmd_len_min;          /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct IPMINetfn {
	unsigned int               cmd_nums;             /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const IPMICmdHandler  *    cmd_handlers;         /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct IPMIRcvBufEntry {
	struct {
		struct IPMIRcvBufEntry * tqe_next;       /*     0     8 */
		struct IPMIRcvBufEntry * * tqe_prev;     /*     8     8 */
	} entry;                                         /*     0    16 */
	uint8_t                    len;                  /*    16     1 */
	uint8_t                    buf[300];             /*    17   300 */

	/* size: 320, cachelines: 5, members: 3 */
	/* padding: 3 */
};
struct IPMIBmcExtern {
	IPMIBmc                    parent;               /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	CharBackend                chr;                  /*   128    48 */
	_Bool                      connected;            /*   176     1 */
	unsigned char              inbuf[302];           /*   177   302 */

	/* XXX 1 byte hole, try to pack */

	/* --- cacheline 7 boundary (448 bytes) was 32 bytes ago --- */
	unsigned int               inpos;                /*   480     4 */
	_Bool                      in_escape;            /*   484     1 */
	_Bool                      in_too_many;          /*   485     1 */
	_Bool                      waiting_rsp;          /*   486     1 */
	_Bool                      sending_cmd;          /*   487     1 */
	unsigned char              outbuf[605];          /*   488   605 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 17 boundary (1088 bytes) was 8 bytes ago --- */
	unsigned int               outpos;               /*  1096     4 */
	unsigned int               outlen;               /*  1100     4 */
	struct QEMUTimer *         extern_timer;         /*  1104     8 */
	_Bool                      send_reset;           /*  1112     1 */

	/* size: 1120, cachelines: 18, members: 14 */
	/* sum members: 1109, holes: 2, sum holes: 4 */
	/* padding: 7 */
	/* last cacheline: 32 bytes */
};
struct IPMIKCS {
	IPMIBmc *                  bmc;                  /*     0     8 */
	_Bool                      do_wake;              /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	qemu_irq                   irq;                  /*    16     8 */
	uint32_t                   io_base;              /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	long unsigned int          io_length;            /*    32     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               io;                   /*    48   256 */
	/* --- cacheline 4 boundary (256 bytes) was 48 bytes ago --- */
	_Bool                      obf_irq_set;          /*   304     1 */
	_Bool                      atn_irq_set;          /*   305     1 */
	_Bool                      use_irq;              /*   306     1 */
	_Bool                      irqs_enabled;         /*   307     1 */
	uint8_t                    outmsg[300];          /*   308   300 */
	/* --- cacheline 9 boundary (576 bytes) was 32 bytes ago --- */
	uint32_t                   outpos;               /*   608     4 */
	uint32_t                   outlen;               /*   612     4 */
	uint8_t                    inmsg[300];           /*   616   300 */
	/* --- cacheline 14 boundary (896 bytes) was 20 bytes ago --- */
	uint32_t                   inlen;                /*   916     4 */
	_Bool                      write_end;            /*   920     1 */
	uint8_t                    status_reg;           /*   921     1 */
	uint8_t                    data_out_reg;         /*   922     1 */

	/* XXX 1 byte hole, try to pack */

	int16_t                    data_in_reg;          /*   924     2 */
	int16_t                    cmd_reg;              /*   926     2 */
	uint8_t                    waiting_rsp;          /*   928     1 */

	/* Force padding: */
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;

	/* size: 944, cachelines: 15, members: 21 */
	/* sum members: 909, holes: 4, sum holes: 20 */
	/* padding: 15 */
	/* last cacheline: 48 bytes */
};
struct ISAIPMIKCSDevice {
	ISADevice                  dev;                  /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int32_t                    isairq;               /*   128     4 */

	/* XXX 12 bytes hole, try to pack */

	IPMIKCS                    kcs;                  /*   144   944 */
	/* --- cacheline 17 boundary (1088 bytes) --- */
	uint32_t                   uuid;                 /*  1088     4 */

	/* Force padding: */
	uint32_t                   :32;
	uint32_t                   :32;
	uint32_t                   :32;

	/* size: 1104, cachelines: 18, members: 4 */
	/* sum members: 1080, holes: 1, sum holes: 12 */
	/* padding: 12 */
	/* last cacheline: 16 bytes */
};
struct IPMIBT {
	IPMIBmc *                  bmc;                  /*     0     8 */
	_Bool                      do_wake;              /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	qemu_irq                   irq;                  /*    16     8 */
	uint32_t                   io_base;              /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	long unsigned int          io_length;            /*    32     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               io;                   /*    48   256 */
	/* --- cacheline 4 boundary (256 bytes) was 48 bytes ago --- */
	_Bool                      obf_irq_set;          /*   304     1 */
	_Bool                      atn_irq_set;          /*   305     1 */
	_Bool                      use_irq;              /*   306     1 */
	_Bool                      irqs_enabled;         /*   307     1 */
	uint8_t                    outmsg[300];          /*   308   300 */
	/* --- cacheline 9 boundary (576 bytes) was 32 bytes ago --- */
	uint32_t                   outpos;               /*   608     4 */
	uint32_t                   outlen;               /*   612     4 */
	uint8_t                    inmsg[300];           /*   616   300 */
	/* --- cacheline 14 boundary (896 bytes) was 20 bytes ago --- */
	uint32_t                   inlen;                /*   916     4 */
	uint8_t                    control_reg;          /*   920     1 */
	uint8_t                    mask_reg;             /*   921     1 */
	uint8_t                    waiting_rsp;          /*   922     1 */
	uint8_t                    waiting_seq;          /*   923     1 */

	/* size: 928, cachelines: 15, members: 19 */
	/* sum members: 905, holes: 3, sum holes: 19 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct ISAIPMIBTDevice {
	ISADevice                  dev;                  /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int32_t                    isairq;               /*   128     4 */

	/* XXX 12 bytes hole, try to pack */

	IPMIBT                     bt;                   /*   144   928 */
	/* --- cacheline 16 boundary (1024 bytes) was 48 bytes ago --- */
	uint32_t                   uuid;                 /*  1072     4 */

	/* Force padding: */
	uint32_t                   :32;
	uint32_t                   :32;
	uint32_t                   :32;

	/* size: 1088, cachelines: 17, members: 4 */
	/* sum members: 1064, holes: 1, sum holes: 12 */
	/* padding: 12 */
};
struct pc_dimms_capacity {
	uint64_t                   size;                 /*     0     8 */
	Error * *                  errp;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct AppleSMCData {
	uint8_t                    len;                  /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	const char  *              key;                  /*     8     8 */
	const char  *              data;                 /*    16     8 */
	struct {
		struct AppleSMCData * le_next;           /*    24     8 */
		struct AppleSMCData * * le_prev;         /*    32     8 */
	} node;                                          /*    24    16 */

	/* size: 40, cachelines: 1, members: 4 */
	/* sum members: 33, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
struct AppleSMCState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	MemoryRegion               io_data;              /*   128   256 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	MemoryRegion               io_cmd;               /*   384   256 */
	/* --- cacheline 10 boundary (640 bytes) --- */
	uint32_t                   iobase;               /*   640     4 */
	uint8_t                    cmd;                  /*   644     1 */
	uint8_t                    status;               /*   645     1 */
	uint8_t                    key[4];               /*   646     4 */
	uint8_t                    read_pos;             /*   650     1 */
	uint8_t                    data_len;             /*   651     1 */
	uint8_t                    data_pos;             /*   652     1 */
	uint8_t                    data[255];            /*   653   255 */
	/* --- cacheline 14 boundary (896 bytes) was 12 bytes ago --- */
	uint8_t                    charactic[4];         /*   908     4 */
	char *                     osk;                  /*   912     8 */
	struct {
		struct AppleSMCData * lh_first;          /*   920     8 */
	} data_def;                                      /*   920     8 */

	/* size: 928, cachelines: 15, members: 14 */
	/* last cacheline: 32 bytes */
};
struct ISADebugExitState {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint32_t                   iobase;               /*   128     4 */
	uint32_t                   iosize;               /*   132     4 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               io;                   /*   144   256 */

	/* size: 400, cachelines: 7, members: 4 */
	/* sum members: 392, holes: 1, sum holes: 8 */
	/* last cacheline: 16 bytes */
};
struct PCTestdev {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	MemoryRegion               ioport;               /*   128   256 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	MemoryRegion               ioport_byte;          /*   384   256 */
	/* --- cacheline 10 boundary (640 bytes) --- */
	MemoryRegion               flush;                /*   640   256 */
	/* --- cacheline 14 boundary (896 bytes) --- */
	MemoryRegion               irq;                  /*   896   256 */
	/* --- cacheline 18 boundary (1152 bytes) --- */
	MemoryRegion               iomem;                /*  1152   256 */
	/* --- cacheline 22 boundary (1408 bytes) --- */
	uint32_t                   ioport_data;          /*  1408     4 */
	char                       iomem_buf[65536];     /*  1412 65536 */

	/* Force padding: */
	char                       [65536]:524288;

	/* size: 66960, cachelines: 1047, members: 8 */
	/* padding: 12 */
	/* last cacheline: 16 bytes */
};
struct PCITestDevHdr {
	uint8_t                    test;                 /*     0     1 */
	uint8_t                    width;                /*     1     1 */
	uint8_t                    pad0[2];              /*     2     2 */
	uint32_t                   offset;               /*     4     4 */
	uint8_t                    data;                 /*     8     1 */
	uint8_t                    pad1[3];              /*     9     3 */
	uint32_t                   count;                /*    12     4 */
	uint8_t                    name[];               /*    16     0 */

	/* size: 16, cachelines: 1, members: 8 */
	/* last cacheline: 16 bytes */
};
struct IOTest {
	MemoryRegion *             mr;                   /*     0     8 */
	EventNotifier              notifier;             /*     8     8 */
	_Bool                      hasnotifier;          /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	unsigned int               size;                 /*    20     4 */
	_Bool                      match_data;           /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	PCITestDevHdr *            hdr;                  /*    32     8 */
	unsigned int               bufsize;              /*    40     4 */

	/* size: 48, cachelines: 1, members: 7 */
	/* sum members: 34, holes: 2, sum holes: 10 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct PCITestDevState {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	MemoryRegion               mmio;                 /*  2288   256 */
	/* --- cacheline 39 boundary (2496 bytes) was 48 bytes ago --- */
	MemoryRegion               portio;               /*  2544   256 */
	/* --- cacheline 43 boundary (2752 bytes) was 48 bytes ago --- */
	IOTest *                   tests;                /*  2800     8 */
	int                        current;              /*  2808     4 */

	/* size: 2816, cachelines: 44, members: 5 */
	/* padding: 4 */
};
struct NE2000State {
	MemoryRegion               io;                   /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint8_t                    cmd;                  /*   256     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   start;                /*   260     4 */
	uint32_t                   stop;                 /*   264     4 */
	uint8_t                    boundary;             /*   268     1 */
	uint8_t                    tsr;                  /*   269     1 */
	uint8_t                    tpsr;                 /*   270     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   tcnt;                 /*   272     2 */
	uint16_t                   rcnt;                 /*   274     2 */
	uint32_t                   rsar;                 /*   276     4 */
	uint8_t                    rsr;                  /*   280     1 */
	uint8_t                    rxcr;                 /*   281     1 */
	uint8_t                    isr;                  /*   282     1 */
	uint8_t                    dcfg;                 /*   283     1 */
	uint8_t                    imr;                  /*   284     1 */
	uint8_t                    phys[6];              /*   285     6 */
	uint8_t                    curpag;               /*   291     1 */
	uint8_t                    mult[8];              /*   292     8 */

	/* XXX 4 bytes hole, try to pack */

	qemu_irq                   irq;                  /*   304     8 */
	NICState *                 nic;                  /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	NICConf                    c;                    /*   320  8216 */
	/* --- cacheline 133 boundary (8512 bytes) was 24 bytes ago --- */
	uint8_t                    mem[49152];           /*  8536 49152 */

	/* size: 57696, cachelines: 902, members: 22 */
	/* sum members: 57680, holes: 3, sum holes: 8 */
	/* padding: 8 */
	/* last cacheline: 32 bytes */
};
struct PCINE2000State {
	PCIDevice                  dev;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	NE2000State                ne2000;               /*  2288 57696 */

	/* size: 59984, cachelines: 938, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PCNetState_st {
	NICState *                 nic;                  /*     0     8 */
	NICConf                    conf;                 /*     8  8216 */
	/* --- cacheline 128 boundary (8192 bytes) was 32 bytes ago --- */
	QEMUTimer *                poll_timer;           /*  8224     8 */
	int                        rap;                  /*  8232     4 */
	int                        isr;                  /*  8236     4 */
	int                        lnkst;                /*  8240     4 */
	uint32_t                   rdra;                 /*  8244     4 */
	uint32_t                   tdra;                 /*  8248     4 */
	uint8_t                    prom[16];             /*  8252    16 */
	/* --- cacheline 129 boundary (8256 bytes) was 12 bytes ago --- */
	uint16_t                   csr[128];             /*  8268   256 */
	/* --- cacheline 133 boundary (8512 bytes) was 12 bytes ago --- */
	uint16_t                   bcr[32];              /*  8524    64 */
	/* --- cacheline 134 boundary (8576 bytes) was 12 bytes ago --- */
	int                        xmit_pos;             /*  8588     4 */
	uint64_t                   timer;                /*  8592     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               mmio;                 /*  8608   256 */
	/* --- cacheline 138 boundary (8832 bytes) was 32 bytes ago --- */
	uint8_t                    buffer[4096];         /*  8864  4096 */
	/* --- cacheline 202 boundary (12928 bytes) was 32 bytes ago --- */
	qemu_irq                   irq;                  /* 12960     8 */
	void                       (*phys_mem_read)(void *, hwaddr, uint8_t *, int, int); /* 12968     8 */
	void                       (*phys_mem_write)(void *, hwaddr, uint8_t *, int, int); /* 12976     8 */
	void *                     dma_opaque;           /* 12984     8 */
	/* --- cacheline 203 boundary (12992 bytes) --- */
	int                        tx_busy;              /* 12992     4 */
	int                        looptest;             /* 12996     4 */

	/* size: 13008, cachelines: 204, members: 21 */
	/* sum members: 12992, holes: 1, sum holes: 8 */
	/* padding: 8 */
	/* last cacheline: 16 bytes */
};
struct qemu_ether_header {
	uint8_t                    ether_dhost[6];       /*     0     6 */
	uint8_t                    ether_shost[6];       /*     6     6 */
	uint16_t                   ether_type;           /*    12     2 */

	/* size: 14, cachelines: 1, members: 3 */
	/* last cacheline: 14 bytes */
};
struct pcnet_initblk16 {
	uint16_t                   mode;                 /*     0     2 */
	uint16_t                   padr[3];              /*     2     6 */
	uint16_t                   ladrf[4];             /*     8     8 */
	uint32_t                   rdra;                 /*    16     4 */
	uint32_t                   tdra;                 /*    20     4 */

	/* size: 24, cachelines: 1, members: 5 */
	/* last cacheline: 24 bytes */
};
struct pcnet_initblk32 {
	uint16_t                   mode;                 /*     0     2 */
	uint8_t                    rlen;                 /*     2     1 */
	uint8_t                    tlen;                 /*     3     1 */
	uint16_t                   padr[3];              /*     4     6 */
	uint16_t                   _res;                 /*    10     2 */
	uint16_t                   ladrf[4];             /*    12     8 */
	uint32_t                   rdra;                 /*    20     4 */
	uint32_t                   tdra;                 /*    24     4 */

	/* size: 28, cachelines: 1, members: 8 */
	/* last cacheline: 28 bytes */
};
struct pcnet_TMD {
	uint32_t                   tbadr;                /*     0     4 */
	int16_t                    length;               /*     4     2 */
	int16_t                    status;               /*     6     2 */
	uint32_t                   misc;                 /*     8     4 */
	uint32_t                   res;                  /*    12     4 */

	/* size: 16, cachelines: 1, members: 5 */
	/* last cacheline: 16 bytes */
};
struct pcnet_RMD {
	uint32_t                   rbadr;                /*     0     4 */
	int16_t                    buf_length;           /*     4     2 */
	int16_t                    status;               /*     6     2 */
	uint32_t                   msg_length;           /*     8     4 */
	uint32_t                   res;                  /*    12     4 */

	/* size: 16, cachelines: 1, members: 5 */
	/* last cacheline: 16 bytes */
};
struct e1000_tx_desc {
	uint64_t                   buffer_addr;          /*     0     8 */
	union {
		uint32_t           data;                 /*     8     4 */
		struct {
			uint16_t   length;               /*     8     2 */
			uint8_t    cso;                  /*    10     1 */
			uint8_t    cmd;                  /*    11     1 */
		} flags;                                 /*     8     4 */
	} lower;                                         /*     8     4 */
	union {
		uint32_t           data;                 /*    12     4 */
		struct {
			uint8_t    status;               /*    12     1 */
			uint8_t    css;                  /*    13     1 */
			uint16_t   special;              /*    14     2 */
		} fields;                                /*    12     4 */
	} upper;                                         /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct e1000_rx_desc {
	uint64_t                   buffer_addr;          /*     0     8 */
	uint16_t                   length;               /*     8     2 */
	uint16_t                   csum;                 /*    10     2 */
	uint8_t                    status;               /*    12     1 */
	uint8_t                    errors;               /*    13     1 */
	uint16_t                   special;              /*    14     2 */

	/* size: 16, cachelines: 1, members: 6 */
	/* last cacheline: 16 bytes */
};
struct e1000_context_desc {
	union {
		uint32_t           ip_config;            /*     0     4 */
		struct {
			uint8_t    ipcss;                /*     0     1 */
			uint8_t    ipcso;                /*     1     1 */
			uint16_t   ipcse;                /*     2     2 */
		} ip_fields;                             /*     0     4 */
	} lower_setup;                                   /*     0     4 */
	union {
		uint32_t           tcp_config;           /*     4     4 */
		struct {
			uint8_t    tucss;                /*     4     1 */
			uint8_t    tucso;                /*     5     1 */
			uint16_t   tucse;                /*     6     2 */
		} tcp_fields;                            /*     4     4 */
	} upper_setup;                                   /*     4     4 */
	uint32_t                   cmd_and_length;       /*     8     4 */
	union {
		uint32_t           data;                 /*    12     4 */
		struct {
			uint8_t    status;               /*    12     1 */
			uint8_t    hdr_len;              /*    13     1 */
			uint16_t   mss;                  /*    14     2 */
		} fields;                                /*    12     4 */
	} tcp_seg_setup;                                 /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct e1000x_txd_props {
	unsigned char              sum_needed;           /*     0     1 */
	uint8_t                    ipcss;                /*     1     1 */
	uint8_t                    ipcso;                /*     2     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   ipcse;                /*     4     2 */
	uint8_t                    tucss;                /*     6     1 */
	uint8_t                    tucso;                /*     7     1 */
	uint16_t                   tucse;                /*     8     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   paylen;               /*    12     4 */
	uint8_t                    hdr_len;              /*    16     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   mss;                  /*    18     2 */
	int8_t                     ip;                   /*    20     1 */
	int8_t                     tcp;                  /*    21     1 */
	_Bool                      tse;                  /*    22     1 */
	_Bool                      cptse;                /*    23     1 */

	/* size: 24, cachelines: 1, members: 14 */
	/* sum members: 20, holes: 3, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct e1000_tx {
	unsigned char              header[256];          /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	unsigned char              vlan_header[4];       /*   256     4 */
	unsigned char              vlan[4];              /*   260     4 */
	unsigned char              data[65536];          /*   264 65536 */
	/* --- cacheline 1028 boundary (65792 bytes) was 8 bytes ago --- */
	uint16_t                   size;                 /* 65800     2 */
	unsigned char              vlan_needed;          /* 65802     1 */

	/* XXX 1 byte hole, try to pack */

	e1000x_txd_props           props;                /* 65804    24 */
	uint16_t                   tso_frames;           /* 65828     2 */

	/* size: 65832, cachelines: 1029, members: 8 */
	/* sum members: 65829, holes: 1, sum holes: 1 */
	/* padding: 2 */
	/* last cacheline: 40 bytes */
};
struct E1000State_st {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	NICState *                 nic;                  /*  2288     8 */
	NICConf                    conf;                 /*  2296  8216 */
	/* --- cacheline 164 boundary (10496 bytes) was 16 bytes ago --- */
	MemoryRegion               mmio;                 /* 10512   256 */
	/* --- cacheline 168 boundary (10752 bytes) was 16 bytes ago --- */
	MemoryRegion               io;                   /* 10768   256 */
	/* --- cacheline 172 boundary (11008 bytes) was 16 bytes ago --- */
	uint32_t                   mac_reg[32768];       /* 11024 131072 */
	/* --- cacheline 2220 boundary (142080 bytes) was 16 bytes ago --- */
	uint16_t                   phy_reg[32];          /* 142096    64 */
	/* --- cacheline 2221 boundary (142144 bytes) was 16 bytes ago --- */
	uint16_t                   eeprom_data[64];      /* 142160   128 */
	/* --- cacheline 2223 boundary (142272 bytes) was 16 bytes ago --- */
	uint32_t                   rxbuf_size;           /* 142288     4 */
	uint32_t                   rxbuf_min_shift;      /* 142292     4 */
	struct e1000_tx            tx;                   /* 142296 65832 */

	/* XXX last struct has 2 bytes of padding */

	/* --- cacheline 3252 boundary (208128 bytes) --- */
	struct {
		uint32_t           val_in;               /* 208128     4 */
		uint16_t           bitnum_in;            /* 208132     2 */
		uint16_t           bitnum_out;           /* 208134     2 */
		uint16_t           reading;              /* 208136     2 */

		/* XXX 2 bytes hole, try to pack */

		uint32_t           old_eecd;             /* 208140     4 */
	} eecd_state;                                    /* 208128    16 */
	QEMUTimer *                autoneg_timer;        /* 208144     8 */
	QEMUTimer *                mit_timer;            /* 208152     8 */
	_Bool                      mit_timer_on;         /* 208160     1 */
	_Bool                      mit_irq_level;        /* 208161     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   mit_ide;              /* 208164     4 */
	uint32_t                   compat_flags;         /* 208168     4 */

	/* size: 208176, cachelines: 3253, members: 18 */
	/* sum members: 208170, holes: 1, sum holes: 2 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 2 */
	/* last cacheline: 48 bytes */
};
struct E1000BaseClass {
	PCIDeviceClass             parent_class;         /*     0   264 */
	/* --- cacheline 4 boundary (256 bytes) was 8 bytes ago --- */
	uint16_t                   phy_id2;              /*   264     2 */

	/* size: 272, cachelines: 5, members: 2 */
	/* padding: 6 */
	/* last cacheline: 16 bytes */
};
struct E1000Info {
	const char  *              name;                 /*     0     8 */
	uint16_t                   device_id;            /*     8     2 */
	uint8_t                    revision;             /*    10     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   phy_id2;              /*    12     2 */

	/* size: 16, cachelines: 1, members: 4 */
	/* sum members: 13, holes: 1, sum holes: 1 */
	/* padding: 2 */
	/* last cacheline: 16 bytes */
};
struct eth_header {
	uint8_t                    h_dest[6];            /*     0     6 */
	uint8_t                    h_source[6];          /*     6     6 */
	uint16_t                   h_proto;              /*    12     2 */

	/* size: 14, cachelines: 1, members: 3 */
	/* last cacheline: 14 bytes */
};
struct vlan_header {
	uint16_t                   h_tci;                /*     0     2 */
	uint16_t                   h_proto;              /*     2     2 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
struct ip_header {
	uint8_t                    ip_ver_len;           /*     0     1 */
	uint8_t                    ip_tos;               /*     1     1 */
	uint16_t                   ip_len;               /*     2     2 */
	uint16_t                   ip_id;                /*     4     2 */
	uint16_t                   ip_off;               /*     6     2 */
	uint8_t                    ip_ttl;               /*     8     1 */
	uint8_t                    ip_p;                 /*     9     1 */
	uint16_t                   ip_sum;               /*    10     2 */
	uint32_t                   ip_src;               /*    12     4 */
	uint32_t                   ip_dst;               /*    16     4 */

	/* size: 20, cachelines: 1, members: 10 */
	/* last cacheline: 20 bytes */
};
struct in6_address {
	union {
		uint8_t            __u6_addr8[16];       /*     0    16 */
	} __in6_u;                                       /*     0    16 */

	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */
};
struct ip6_hdrctl {
	uint32_t                   ip6_un1_flow;         /*     0     4 */
	uint16_t                   ip6_un1_plen;         /*     4     2 */
	uint8_t                    ip6_un1_nxt;          /*     6     1 */
	uint8_t                    ip6_un1_hlim;         /*     7     1 */

	/* size: 8, cachelines: 1, members: 4 */
	/* last cacheline: 8 bytes */
};
struct ip6_ecn_access {
	uint8_t                    ip6_un3_vfc;          /*     0     1 */
	uint8_t                    ip6_un3_ecn;          /*     1     1 */

	/* size: 2, cachelines: 1, members: 2 */
	/* last cacheline: 2 bytes */
};
struct ip6_header {
	union {
		struct ip6_hdrctl  ip6_un1;              /*     0     8 */
		uint8_t            ip6_un2_vfc;          /*     0     1 */
		struct ip6_ecn_access ip6_un3;           /*     0     2 */
	} ip6_ctlun;                                     /*     0     8 */
	struct in6_address         ip6_src;              /*     8    16 */
	struct in6_address         ip6_dst;              /*    24    16 */

	/* size: 40, cachelines: 1, members: 3 */
	/* last cacheline: 40 bytes */
};
struct tcp_hdr {
	u_short                    th_sport;             /*     0     2 */
	u_short                    th_dport;             /*     2     2 */
	uint32_t                   th_seq;               /*     4     4 */
	uint32_t                   th_ack;               /*     8     4 */
	u_char                     th_x2:4;              /*    12: 0  1 */
	u_char                     th_off:4;             /*    12: 4  1 */
	u_char                     th_flags;             /*    13     1 */
	u_short                    th_win;               /*    14     2 */
	u_short                    th_sum;               /*    16     2 */
	u_short                    th_urp;               /*    18     2 */

	/* size: 20, cachelines: 1, members: 10 */
	/* last cacheline: 20 bytes */
};
struct eth_ip6_hdr_info_st {
	uint8_t                    l4proto;              /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	size_t                     full_hdr_len;         /*     8     8 */
	struct ip6_header          ip6_hdr;              /*    16    40 */
	_Bool                      has_ext_hdrs;         /*    56     1 */
	_Bool                      rss_ex_src_valid;     /*    57     1 */
	struct in6_address         rss_ex_src;           /*    58    16 */
	/* --- cacheline 1 boundary (64 bytes) was 10 bytes ago --- */
	_Bool                      rss_ex_dst_valid;     /*    74     1 */
	struct in6_address         rss_ex_dst;           /*    75    16 */
	_Bool                      fragment;             /*    91     1 */

	/* size: 96, cachelines: 2, members: 9 */
	/* sum members: 85, holes: 1, sum holes: 7 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct NetTxPkt {
	PCIDevice *                pci_dev;              /*     0     8 */
	struct virtio_net_hdr      virt_hdr;             /*     8    10 */
	_Bool                      has_virt_hdr;         /*    18     1 */

	/* XXX 5 bytes hole, try to pack */

	struct iovec *             raw;                  /*    24     8 */
	uint32_t                   raw_frags;            /*    32     4 */
	uint32_t                   max_raw_frags;        /*    36     4 */
	struct iovec *             vec;                  /*    40     8 */
	uint8_t                    l2_hdr[22];           /*    48    22 */
	/* --- cacheline 1 boundary (64 bytes) was 6 bytes ago --- */
	uint8_t                    l3_hdr[65535];        /*    70 65535 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 1025 boundary (65600 bytes) was 8 bytes ago --- */
	uint32_t                   payload_len;          /* 65608     4 */
	uint32_t                   payload_frags;        /* 65612     4 */
	uint32_t                   max_payload_frags;    /* 65616     4 */
	uint16_t                   hdr_len;              /* 65620     2 */

	/* XXX 2 bytes hole, try to pack */

	eth_pkt_types_e            packet_type;          /* 65624     4 */
	uint8_t                    l4proto;              /* 65628     1 */
	_Bool                      is_loopback;          /* 65629     1 */

	/* size: 65632, cachelines: 1026, members: 16 */
	/* sum members: 65620, holes: 3, sum holes: 10 */
	/* padding: 2 */
	/* last cacheline: 32 bytes */
};
struct tcp_header {
	uint16_t                   th_sport;             /*     0     2 */
	uint16_t                   th_dport;             /*     2     2 */
	uint32_t                   th_seq;               /*     4     4 */
	uint32_t                   th_ack;               /*     8     4 */
	uint16_t                   th_offset_flags;      /*    12     2 */
	uint16_t                   th_win;               /*    14     2 */
	uint16_t                   th_sum;               /*    16     2 */
	uint16_t                   th_urp;               /*    18     2 */

	/* size: 20, cachelines: 1, members: 8 */
	/* last cacheline: 20 bytes */
};
struct udp_header {
	uint16_t                   uh_sport;             /*     0     2 */
	uint16_t                   uh_dport;             /*     2     2 */
	uint16_t                   uh_ulen;              /*     4     2 */
	uint16_t                   uh_sum;               /*     6     2 */

	/* size: 8, cachelines: 1, members: 4 */
	/* last cacheline: 8 bytes */
};
struct eth_ip4_hdr_info_st {
	struct ip_header           ip4_hdr;              /*     0    20 */
	_Bool                      fragment;             /*    20     1 */

	/* size: 24, cachelines: 1, members: 2 */
	/* padding: 3 */
	/* last cacheline: 24 bytes */
};
struct eth_l4_hdr_info_st {
	union {
		struct tcp_header  tcp;                  /*     0    20 */
		struct udp_header  udp;                  /*     0     8 */
	} hdr;                                           /*     0    20 */
	_Bool                      has_tcp_data;         /*    20     1 */

	/* size: 24, cachelines: 1, members: 2 */
	/* padding: 3 */
	/* last cacheline: 24 bytes */
};
struct toeplitz_key_st {
	uint32_t                   leftmost_32_bits;     /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  next_byte;            /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct NetRxPkt {
	struct virtio_net_hdr      virt_hdr;             /*     0    10 */
	uint8_t                    ehdr_buf[18];         /*    10    18 */

	/* XXX 4 bytes hole, try to pack */

	struct iovec *             vec;                  /*    32     8 */
	uint16_t                   vec_len_total;        /*    40     2 */
	uint16_t                   vec_len;              /*    42     2 */
	uint32_t                   tot_len;              /*    44     4 */
	uint16_t                   tci;                  /*    48     2 */

	/* XXX 6 bytes hole, try to pack */

	size_t                     ehdr_buf_len;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_virt_hdr;         /*    64     1 */

	/* XXX 3 bytes hole, try to pack */

	eth_pkt_types_e            packet_type;          /*    68     4 */
	_Bool                      isip4;                /*    72     1 */
	_Bool                      isip6;                /*    73     1 */
	_Bool                      isudp;                /*    74     1 */
	_Bool                      istcp;                /*    75     1 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     l3hdr_off;            /*    80     8 */
	size_t                     l4hdr_off;            /*    88     8 */
	size_t                     l5hdr_off;            /*    96     8 */
	eth_ip6_hdr_info           ip6hdr_info;          /*   104    96 */
	/* --- cacheline 3 boundary (192 bytes) was 8 bytes ago --- */
	eth_ip4_hdr_info           ip4hdr_info;          /*   200    24 */
	eth_l4_hdr_info            l4hdr_info;           /*   224    24 */

	/* size: 248, cachelines: 4, members: 20 */
	/* sum members: 231, holes: 4, sum holes: 17 */
	/* last cacheline: 56 bytes */
};
struct E1000Core {
	uint32_t                   mac[32768];           /*     0 131072 */
	/* --- cacheline 2048 boundary (131072 bytes) --- */
	uint16_t                   phy[7][32];           /* 131072   448 */
	/* --- cacheline 2055 boundary (131520 bytes) --- */
	uint16_t                   eeprom[64];           /* 131520   128 */
	/* --- cacheline 2057 boundary (131648 bytes) --- */
	uint32_t                   rxbuf_sizes[4];       /* 131648    16 */
	uint32_t                   rx_desc_buf_size;     /* 131664     4 */
	uint32_t                   rxbuf_min_shift;      /* 131668     4 */
	uint8_t                    rx_desc_len;          /* 131672     1 */

	/* XXX 7 bytes hole, try to pack */

	QEMUTimer *                autoneg_timer;        /* 131680     8 */
	struct e1000e_tx           tx[2];                /* 131688    80 */
	/* --- cacheline 2058 boundary (131712 bytes) was 56 bytes ago --- */
	struct NetRxPkt *          rx_pkt;               /* 131768     8 */
	/* --- cacheline 2059 boundary (131776 bytes) --- */
	_Bool                      has_vnet;             /* 131776     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        max_queue_num;        /* 131780     4 */
	uint32_t                   delayed_causes;       /* 131784     4 */

	/* XXX 4 bytes hole, try to pack */

	E1000IntrDelayTimer        radv;                 /* 131792    32 */
	E1000IntrDelayTimer        rdtr;                 /* 131824    32 */
	/* --- cacheline 2060 boundary (131840 bytes) was 16 bytes ago --- */
	E1000IntrDelayTimer        raid;                 /* 131856    32 */
	E1000IntrDelayTimer        tadv;                 /* 131888    32 */
	/* --- cacheline 2061 boundary (131904 bytes) was 16 bytes ago --- */
	E1000IntrDelayTimer        tidv;                 /* 131920    32 */
	E1000IntrDelayTimer        itr;                  /* 131952    32 */
	/* --- cacheline 2062 boundary (131968 bytes) was 16 bytes ago --- */
	_Bool                      itr_intr_pending;     /* 131984     1 */

	/* XXX 7 bytes hole, try to pack */

	E1000IntrDelayTimer        eitr[5];              /* 131992   160 */
	/* --- cacheline 2064 boundary (132096 bytes) was 56 bytes ago --- */
	_Bool                      eitr_intr_pending[5]; /* 132152     5 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 2065 boundary (132160 bytes) --- */
	VMChangeStateEntry *       vmstate;              /* 132160     8 */
	uint32_t                   itr_guest_value;      /* 132168     4 */
	uint32_t                   eitr_guest_value[5];  /* 132172    20 */
	uint16_t                   vet;                  /* 132192     2 */
	uint8_t                    permanent_mac[6];     /* 132194     6 */
	NICState *                 owner_nic;            /* 132200     8 */
	PCIDevice *                owner;                /* 132208     8 */
	void                       (*owner_start_recv)(PCIDevice *); /* 132216     8 */

	/* size: 132224, cachelines: 2066, members: 30 */
	/* sum members: 132200, holes: 5, sum holes: 24 */
};
struct E1000IntrDelayTimer_st {
	QEMUTimer *                timer;                /*     0     8 */
	_Bool                      running;              /*     8     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   delay_reg;            /*    12     4 */
	uint32_t                   delay_resolution_ns;  /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	E1000ECore *               core;                 /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 25, holes: 2, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct e1000e_tx {
	e1000x_txd_props           props;                /*     0    24 */
	_Bool                      skip_cp;              /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	struct NetTxPkt *          tx_pkt;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 3 */
	/* sum members: 33, holes: 1, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
struct E1000EState {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	NICState *                 nic;                  /*  2288     8 */
	NICConf                    conf;                 /*  2296  8216 */
	/* --- cacheline 164 boundary (10496 bytes) was 16 bytes ago --- */
	MemoryRegion               mmio;                 /* 10512   256 */
	/* --- cacheline 168 boundary (10752 bytes) was 16 bytes ago --- */
	MemoryRegion               flash;                /* 10768   256 */
	/* --- cacheline 172 boundary (11008 bytes) was 16 bytes ago --- */
	MemoryRegion               io;                   /* 11024   256 */
	/* --- cacheline 176 boundary (11264 bytes) was 16 bytes ago --- */
	MemoryRegion               msix;                 /* 11280   256 */
	/* --- cacheline 180 boundary (11520 bytes) was 16 bytes ago --- */
	uint32_t                   ioaddr;               /* 11536     4 */
	uint16_t                   subsys_ven;           /* 11540     2 */
	uint16_t                   subsys;               /* 11542     2 */
	uint16_t                   subsys_ven_used;      /* 11544     2 */
	uint16_t                   subsys_used;          /* 11546     2 */
	_Bool                      disable_vnet;         /* 11548     1 */

	/* XXX 3 bytes hole, try to pack */

	E1000ECore                 core;                 /* 11552 132224 */

	/* size: 143776, cachelines: 2247, members: 14 */
	/* sum members: 143773, holes: 1, sum holes: 3 */
	/* last cacheline: 32 bytes */
};
union e1000_rx_desc_extended {
	struct {
		uint64_t           buffer_addr;        /*     0     8 */
		uint64_t           reserved;           /*     8     8 */
	} read;                                        /*     0    16 */
	struct {
		struct {
			uint32_t   mrq;                /*     0     4 */
			union {
				uint32_t rss;          /*     4     4 */
				struct {
					uint16_t ip_id; /*     4     2 */
					uint16_t csum; /*     6     2 */
				} csum_ip;             /*     4     4 */
			} hi_dword;                    /*     4     4 */
		} lower;                               /*     0     8 */
		struct {
			uint32_t   status_error;       /*     8     4 */
			uint16_t   length;             /*    12     2 */
			uint16_t   vlan;               /*    14     2 */
		} upper;                               /*     8     8 */
	} wb;                                          /*     0    16 */
};
union e1000_rx_desc_packet_split {
	struct {
		uint64_t           buffer_addr[4];     /*     0    32 */
	} read;                                        /*     0    32 */
	struct {
		struct {
			uint32_t   mrq;                /*     0     4 */
			union {
				uint32_t rss;          /*     4     4 */
				struct {
					uint16_t ip_id; /*     4     2 */
					uint16_t csum; /*     6     2 */
				} csum_ip;             /*     4     4 */
			} hi_dword;                    /*     4     4 */
		} lower;                               /*     0     8 */
		struct {
			uint32_t   status_error;       /*     8     4 */
			uint16_t   length0;            /*    12     2 */
			uint16_t   vlan;               /*    14     2 */
		} middle;                              /*     8     8 */
		struct {
			uint16_t   header_status;      /*    16     2 */
			uint16_t   length[3];          /*    18     6 */
		} upper;                               /*    16     8 */
		uint64_t           reserved;           /*    24     8 */
	} wb;                                          /*     0    32 */
};
struct E1000E_RSSInfo_st {
	_Bool                      enabled;              /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   hash;                 /*     4     4 */
	uint32_t                   queue;                /*     8     4 */
	uint32_t                   type;                 /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* sum members: 13, holes: 1, sum holes: 3 */
	/* last cacheline: 16 bytes */
};
struct E1000E_RingInfo_st {
	int                        dbah;                 /*     0     4 */
	int                        dbal;                 /*     4     4 */
	int                        dlen;                 /*     8     4 */
	int                        dh;                   /*    12     4 */
	int                        dt;                   /*    16     4 */
	int                        idx;                  /*    20     4 */

	/* size: 24, cachelines: 1, members: 6 */
	/* last cacheline: 24 bytes */
};
struct E1000E_TxRing_st {
	const E1000E_RingInfo  *   i;                    /*     0     8 */
	struct e1000e_tx *         tx;                   /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct E1000E_RxRing_st {
	const E1000E_RingInfo  *   i;                    /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct e1000e_ba_state_st {
	uint16_t                   written[4];           /*     0     8 */
	uint8_t                    cur_idx;              /*     8     1 */

	/* size: 10, cachelines: 1, members: 2 */
	/* padding: 1 */
	/* last cacheline: 10 bytes */
};
struct ip_pseudo_header {
	uint32_t                   ip_src;               /*     0     4 */
	uint32_t                   ip_dst;               /*     4     4 */
	uint8_t                    zeros;                /*     8     1 */
	uint8_t                    ip_proto;             /*     9     1 */
	uint16_t                   ip_payload;           /*    10     2 */

	/* size: 12, cachelines: 1, members: 5 */
	/* last cacheline: 12 bytes */
};
struct EEprom9346 {
	uint16_t                   contents[64];         /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int                        mode;                 /*   128     4 */
	uint32_t                   tick;                 /*   132     4 */
	uint8_t                    address;              /*   136     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   input;                /*   138     2 */
	uint16_t                   output;               /*   140     2 */
	uint8_t                    eecs;                 /*   142     1 */
	uint8_t                    eesk;                 /*   143     1 */
	uint8_t                    eedi;                 /*   144     1 */
	uint8_t                    eedo;                 /*   145     1 */

	/* size: 148, cachelines: 3, members: 10 */
	/* sum members: 145, holes: 1, sum holes: 1 */
	/* padding: 2 */
	/* last cacheline: 20 bytes */
};
struct RTL8139TallyCounters {
	uint64_t                   TxOk;                 /*     0     8 */
	uint64_t                   RxOk;                 /*     8     8 */
	uint64_t                   TxERR;                /*    16     8 */
	uint32_t                   RxERR;                /*    24     4 */
	uint16_t                   MissPkt;              /*    28     2 */
	uint16_t                   FAE;                  /*    30     2 */
	uint32_t                   Tx1Col;               /*    32     4 */
	uint32_t                   TxMCol;               /*    36     4 */
	uint64_t                   RxOkPhy;              /*    40     8 */
	uint64_t                   RxOkBrd;              /*    48     8 */
	uint32_t                   RxOkMul;              /*    56     4 */
	uint16_t                   TxAbt;                /*    60     2 */
	uint16_t                   TxUndrn;              /*    62     2 */

	/* size: 64, cachelines: 1, members: 13 */
};
struct RTL8139State {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	uint8_t                    phys[8];              /*  2288     8 */
	uint8_t                    mult[8];              /*  2296     8 */
	/* --- cacheline 36 boundary (2304 bytes) --- */
	uint32_t                   TxStatus[4];          /*  2304    16 */
	uint32_t                   TxAddr[4];            /*  2320    16 */
	uint32_t                   RxBuf;                /*  2336     4 */
	uint32_t                   RxBufferSize;         /*  2340     4 */
	uint32_t                   RxBufPtr;             /*  2344     4 */
	uint32_t                   RxBufAddr;            /*  2348     4 */
	uint16_t                   IntrStatus;           /*  2352     2 */
	uint16_t                   IntrMask;             /*  2354     2 */
	uint32_t                   TxConfig;             /*  2356     4 */
	uint32_t                   RxConfig;             /*  2360     4 */
	uint32_t                   RxMissed;             /*  2364     4 */
	/* --- cacheline 37 boundary (2368 bytes) --- */
	uint16_t                   CSCR;                 /*  2368     2 */
	uint8_t                    Cfg9346;              /*  2370     1 */
	uint8_t                    Config0;              /*  2371     1 */
	uint8_t                    Config1;              /*  2372     1 */
	uint8_t                    Config3;              /*  2373     1 */
	uint8_t                    Config4;              /*  2374     1 */
	uint8_t                    Config5;              /*  2375     1 */
	uint8_t                    clock_enabled;        /*  2376     1 */
	uint8_t                    bChipCmdState;        /*  2377     1 */
	uint16_t                   MultiIntr;            /*  2378     2 */
	uint16_t                   BasicModeCtrl;        /*  2380     2 */
	uint16_t                   BasicModeStatus;      /*  2382     2 */
	uint16_t                   NWayAdvert;           /*  2384     2 */
	uint16_t                   NWayLPAR;             /*  2386     2 */
	uint16_t                   NWayExpansion;        /*  2388     2 */
	uint16_t                   CpCmd;                /*  2390     2 */
	uint8_t                    TxThresh;             /*  2392     1 */

	/* XXX 7 bytes hole, try to pack */

	NICState *                 nic;                  /*  2400     8 */
	NICConf                    conf;                 /*  2408  8216 */
	/* --- cacheline 166 boundary (10624 bytes) --- */
	uint32_t                   currTxDesc;           /* 10624     4 */
	uint32_t                   cplus_enabled;        /* 10628     4 */
	uint32_t                   currCPlusRxDesc;      /* 10632     4 */
	uint32_t                   currCPlusTxDesc;      /* 10636     4 */
	uint32_t                   RxRingAddrLO;         /* 10640     4 */
	uint32_t                   RxRingAddrHI;         /* 10644     4 */
	EEprom9346                 eeprom;               /* 10648   148 */
	/* --- cacheline 168 boundary (10752 bytes) was 44 bytes ago --- */
	uint32_t                   TCTR;                 /* 10796     4 */
	uint32_t                   TimerInt;             /* 10800     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    TCTR_base;            /* 10808     8 */
	/* --- cacheline 169 boundary (10816 bytes) --- */
	RTL8139TallyCounters       tally_counters;       /* 10816    64 */
	/* --- cacheline 170 boundary (10880 bytes) --- */
	uint8_t *                  cplus_txbuffer;       /* 10880     8 */
	int                        cplus_txbuffer_len;   /* 10888     4 */
	int                        cplus_txbuffer_offset; /* 10892     4 */
	QEMUTimer *                timer;                /* 10896     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               bar_io;               /* 10912   256 */
	/* --- cacheline 174 boundary (11136 bytes) was 32 bytes ago --- */
	MemoryRegion               bar_mem;              /* 11168   256 */
	/* --- cacheline 178 boundary (11392 bytes) was 32 bytes ago --- */
	int                        rtl8139_mmio_io_addr_dummy; /* 11424     4 */

	/* Force padding: */
	int                        :32;
	int                        :32;
	int                        :32;

	/* size: 11440, cachelines: 179, members: 51 */
	/* sum members: 11409, holes: 3, sum holes: 19 */
	/* padding: 12 */
	/* last cacheline: 48 bytes */
};
struct UPT1_TxStats {
	uint64_t                   TSOPktsTxOK;          /*     0     8 */
	uint64_t                   TSOBytesTxOK;         /*     8     8 */
	uint64_t                   ucastPktsTxOK;        /*    16     8 */
	uint64_t                   ucastBytesTxOK;       /*    24     8 */
	uint64_t                   mcastPktsTxOK;        /*    32     8 */
	uint64_t                   mcastBytesTxOK;       /*    40     8 */
	uint64_t                   bcastPktsTxOK;        /*    48     8 */
	uint64_t                   bcastBytesTxOK;       /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint64_t                   pktsTxError;          /*    64     8 */
	uint64_t                   pktsTxDiscard;        /*    72     8 */

	/* size: 80, cachelines: 2, members: 10 */
	/* last cacheline: 16 bytes */
};
struct UPT1_RxStats {
	uint64_t                   LROPktsRxOK;          /*     0     8 */
	uint64_t                   LROBytesRxOK;         /*     8     8 */
	uint64_t                   ucastPktsRxOK;        /*    16     8 */
	uint64_t                   ucastBytesRxOK;       /*    24     8 */
	uint64_t                   mcastPktsRxOK;        /*    32     8 */
	uint64_t                   mcastBytesRxOK;       /*    40     8 */
	uint64_t                   bcastPktsRxOK;        /*    48     8 */
	uint64_t                   bcastBytesRxOK;       /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint64_t                   pktsRxOutOfBuf;       /*    64     8 */
	uint64_t                   pktsRxError;          /*    72     8 */

	/* size: 80, cachelines: 2, members: 10 */
	/* last cacheline: 16 bytes */
};
struct Vmxnet3_TxDesc {
	uint64_t                   addr;                 /*     0     8 */
	uint32_t                   len:14;               /*     8: 0  4 */
	uint32_t                   gen:1;                /*     8:14  4 */
	uint32_t                   rsvd:1;               /*     8:15  4 */
	uint32_t                   dtype:1;              /*     8:16  4 */
	uint32_t                   ext1:1;               /*     8:17  4 */
	uint32_t                   msscof:14;            /*     8:18  4 */
	uint32_t                   hlen:10;              /*    12: 0  4 */
	uint32_t                   om:2;                 /*    12:10  4 */
	uint32_t                   eop:1;                /*    12:12  4 */
	uint32_t                   cq:1;                 /*    12:13  4 */
	uint32_t                   ext2:1;               /*    12:14  4 */
	uint32_t                   ti:1;                 /*    12:15  4 */
	uint32_t                   tci:16;               /*    12:16  4 */

	/* size: 16, cachelines: 1, members: 14 */
	/* last cacheline: 16 bytes */
};
struct Vmxnet3_TxCompDesc {
	uint32_t                   txdIdx:12;            /*     0: 0  4 */
	uint32_t                   ext1:20;              /*     0:12  4 */
	uint32_t                   ext2;                 /*     4     4 */
	uint32_t                   ext3;                 /*     8     4 */
	uint32_t                   rsvd:24;              /*    12: 0  4 */
	uint32_t                   type:7;               /*    12:24  4 */
	uint32_t                   gen:1;                /*    12:31  4 */

	/* size: 16, cachelines: 1, members: 7 */
	/* last cacheline: 16 bytes */
};
struct Vmxnet3_RxDesc {
	uint64_t                   addr;                 /*     0     8 */
	uint32_t                   len:14;               /*     8: 0  4 */
	uint32_t                   btype:1;              /*     8:14  4 */
	uint32_t                   dtype:1;              /*     8:15  4 */
	uint32_t                   rsvd:15;              /*     8:16  4 */
	uint32_t                   gen:1;                /*     8:31  4 */
	uint32_t                   ext1;                 /*    12     4 */

	/* size: 16, cachelines: 1, members: 7 */
	/* last cacheline: 16 bytes */
};
struct Vmxnet3_RxCompDesc {
	uint32_t                   rxdIdx:12;            /*     0: 0  4 */
	uint32_t                   ext1:2;               /*     0:12  4 */
	uint32_t                   eop:1;                /*     0:14  4 */
	uint32_t                   sop:1;                /*     0:15  4 */
	uint32_t                   rqID:10;              /*     0:16  4 */
	uint32_t                   rssType:4;            /*     0:26  4 */
	uint32_t                   cnc:1;                /*     0:30  4 */
	uint32_t                   ext2:1;               /*     0:31  4 */
	uint32_t                   rssHash;              /*     4     4 */
	uint32_t                   len:14;               /*     8: 0  4 */
	uint32_t                   err:1;                /*     8:14  4 */
	uint32_t                   ts:1;                 /*     8:15  4 */
	uint32_t                   tci:16;               /*     8:16  4 */
	uint32_t                   csum:16;              /*    12: 0  4 */
	uint32_t                   tuc:1;                /*    12:16  4 */
	uint32_t                   udp:1;                /*    12:17  4 */
	uint32_t                   tcp:1;                /*    12:18  4 */
	uint32_t                   ipc:1;                /*    12:19  4 */
	uint32_t                   v6:1;                 /*    12:20  4 */
	uint32_t                   v4:1;                 /*    12:21  4 */
	uint32_t                   frg:1;                /*    12:22  4 */
	uint32_t                   fcs:1;                /*    12:23  4 */
	uint32_t                   type:7;               /*    12:24  4 */
	uint32_t                   gen:1;                /*    12:31  4 */

	/* size: 16, cachelines: 1, members: 24 */
	/* last cacheline: 16 bytes */
};
struct Vmxnet3_GOSInfo {
	uint32_t                   gosBits:2;            /*     0: 0  4 */
	uint32_t                   gosType:4;            /*     0: 2  4 */
	uint32_t                   gosVer:16;            /*     0: 6  4 */
	uint32_t                   gosMisc:10;           /*     0:22  4 */

	/* size: 4, cachelines: 1, members: 4 */
	/* last cacheline: 4 bytes */
};
struct Vmxnet3_VariableLenConfDesc {
	uint32_t                   confVer;              /*     0     4 */
	uint32_t                   confLen;              /*     4     4 */
	uint64_t                   confPA;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct VMXNET3Class {
	PCIDeviceClass             parent_class;         /*     0   264 */
	/* --- cacheline 4 boundary (256 bytes) was 8 bytes ago --- */
	DeviceRealize              parent_dc_realize;    /*   264     8 */

	/* size: 272, cachelines: 5, members: 2 */
	/* last cacheline: 16 bytes */
};
struct ISANE2000State {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint32_t                   iobase;               /*   128     4 */
	uint32_t                   isairq;               /*   132     4 */

	/* XXX 8 bytes hole, try to pack */

	NE2000State                ne2000;               /*   144 57696 */

	/* size: 57840, cachelines: 904, members: 4 */
	/* sum members: 57832, holes: 1, sum holes: 8 */
	/* last cacheline: 48 bytes */
};
struct rocker {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	MemoryRegion               mmio;                 /*  2288   256 */
	/* --- cacheline 39 boundary (2496 bytes) was 48 bytes ago --- */
	MemoryRegion               msix_bar;             /*  2544   256 */
	/* --- cacheline 43 boundary (2752 bytes) was 48 bytes ago --- */
	char *                     name;                 /*  2800     8 */
	char *                     world_name;           /*  2808     8 */
	/* --- cacheline 44 boundary (2816 bytes) --- */
	uint32_t                   fp_ports;             /*  2816     4 */

	/* XXX 4 bytes hole, try to pack */

	NICPeers *                 fp_ports_peers;       /*  2824     8 */
	MACAddr                    fp_start_macaddr;     /*  2832     6 */

	/* XXX 2 bytes hole, try to pack */

	uint64_t                   switch_id;            /*  2840     8 */
	FpPort *                   fp_port[62];          /*  2848   496 */
	/* --- cacheline 52 boundary (3328 bytes) was 16 bytes ago --- */
	uint32_t                   test_reg;             /*  3344     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   test_reg64;           /*  3352     8 */
	dma_addr_t                 test_dma_addr;        /*  3360     8 */
	uint32_t                   test_dma_size;        /*  3368     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   lower32;              /*  3376     8 */
	DescRing * *               rings;                /*  3384     8 */
	/* --- cacheline 53 boundary (3392 bytes) --- */
	World *                    worlds[1];            /*  3392     8 */
	World *                    world_dflt;           /*  3400     8 */
	struct {
		struct rocker *    le_next;              /*  3408     8 */
		struct rocker * *  le_prev;              /*  3416     8 */
	} next;                                          /*  3408    16 */

	/* size: 3424, cachelines: 54, members: 19 */
	/* sum members: 3410, holes: 4, sum holes: 14 */
	/* last cacheline: 32 bytes */
};
struct rocker_tlv {
	uint32_t                   type;                 /*     0     4 */
	uint16_t                   len;                  /*     4     2 */
	uint16_t                   rsvd;                 /*     6     2 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct fp_port {
	Rocker *                   r;                    /*     0     8 */
	World *                    world;                /*     8     8 */
	unsigned int               index;                /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     name;                 /*    24     8 */
	uint32_t                   pport;                /*    32     4 */
	_Bool                      enabled;              /*    36     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   speed;                /*    40     4 */
	uint8_t                    duplex;               /*    44     1 */
	uint8_t                    autoneg;              /*    45     1 */
	uint8_t                    learning;             /*    46     1 */

	/* XXX 1 byte hole, try to pack */

	NICState *                 nic;                  /*    48     8 */
	NICConf                    conf;                 /*    56  8216 */

	/* size: 8272, cachelines: 130, members: 12 */
	/* sum members: 8264, holes: 3, sum holes: 8 */
	/* last cacheline: 16 bytes */
};
struct desc_info {
	DescRing *                 ring;                 /*     0     8 */
	RockerDesc                 desc;                 /*     8    32 */
	char *                     buf;                  /*    40     8 */
	size_t                     buf_size;             /*    48     8 */

	/* size: 56, cachelines: 1, members: 4 */
	/* last cacheline: 56 bytes */
};
struct desc_ring {
	hwaddr                     base_addr;            /*     0     8 */
	uint32_t                   size;                 /*     8     4 */
	uint32_t                   head;                 /*    12     4 */
	uint32_t                   tail;                 /*    16     4 */
	uint32_t                   ctrl;                 /*    20     4 */
	uint32_t                   credits;              /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	Rocker *                   r;                    /*    32     8 */
	DescInfo *                 info;                 /*    40     8 */
	int                        index;                /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	desc_ring_consume *        consume;              /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	unsigned int               msix_vector;          /*    64     4 */

	/* size: 72, cachelines: 2, members: 11 */
	/* sum members: 60, holes: 2, sum holes: 8 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
struct rocker_desc {
	uint64_t                   buf_addr;             /*     0     8 */
	uint64_t                   cookie;               /*     8     8 */
	uint16_t                   buf_size;             /*    16     2 */
	uint16_t                   tlv_size;             /*    18     2 */
	uint16_t                   rsvd[5];              /*    20    10 */
	uint16_t                   comp_err;             /*    30     2 */

	/* size: 32, cachelines: 1, members: 6 */
	/* last cacheline: 32 bytes */
};
struct world {
	Rocker *                   r;                    /*     0     8 */
	enum rocker_world_type     type;                 /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	WorldOps *                 ops;                  /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct world_ops {
	const char  *              name;                 /*     0     8 */
	world_init *               init;                 /*     8     8 */
	world_uninit *             uninit;               /*    16     8 */
	world_ig *                 ig;                   /*    24     8 */
	world_cmd *                cmd;                  /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct in_addr {
	in_addr_t                  s_addr;               /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct ipv6_addr {
	union {
		uint8_t            addr8[16];            /*     0    16 */
		uint16_t           addr16[8];            /*     0    16 */
		uint32_t           addr32[4];            /*     0    16 */
	};                                               /*     0    16 */

	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */
};
struct of_dpa {
	World *                    world;                /*     0     8 */
	GHashTable *               flow_tbl;             /*     8     8 */
	GHashTable *               group_tbl;            /*    16     8 */
	unsigned int               flow_tbl_max_size;    /*    24     4 */
	unsigned int               group_tbl_max_size;   /*    28     4 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct of_dpa_flow_key {
	uint32_t                   in_pport;             /*     0     4 */
	uint32_t                   tunnel_id;            /*     4     4 */
	uint32_t                   tbl_id;               /*     8     4 */
	struct {
		uint16_t           vlan_id;              /*    12     2 */
		MACAddr            src;                  /*    14     6 */
		MACAddr            dst;                  /*    20     6 */
		uint16_t           type;                 /*    26     2 */
	} eth;                                           /*    12    16 */
	struct {
		uint8_t            proto;                /*    28     1 */
		uint8_t            tos;                  /*    29     1 */
		uint8_t            ttl;                  /*    30     1 */
		uint8_t            frag;                 /*    31     1 */
	} ip;                                            /*    28     4 */
	union {
		struct {
			struct {
				uint32_t src;            /*    32     4 */
				uint32_t dst;            /*    36     4 */
			} addr;                          /*    32     8 */
			union {
				struct {
					uint16_t src;    /*    40     2 */
					uint16_t dst;    /*    42     2 */
					uint16_t flags;  /*    44     2 */
				} tp;                    /*    40     6 */
				struct {
					MACAddr sha;     /*    40     6 */
					MACAddr tha;     /*    46     6 */
				} arp;                   /*    40    12 */
			};                               /*    40    12 */
		} ipv4;                                  /*    32    20 */
		struct {
			struct {
				Ipv6Addr src;            /*    32    16 */
				Ipv6Addr dst;            /*    48    16 */
			} addr;                          /*    32    32 */
			/* --- cacheline 1 boundary (64 bytes) --- */
			uint32_t   label;                /*    64     4 */
			struct {
				uint16_t src;            /*    68     2 */
				uint16_t dst;            /*    70     2 */
				uint16_t flags;          /*    72     2 */
			} tp;                            /*    68     6 */

			/* XXX 2 bytes hole, try to pack */

			struct {
				Ipv6Addr target;         /*    76    16 */
				MACAddr sll;             /*    92     6 */
				MACAddr tll;             /*    98     6 */
			} nd;                            /*    76    28 */
		} ipv6;                                  /*    32    72 */
	};                                               /*    32    72 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	int                        width;                /*   104     4 */

	/* size: 108, cachelines: 2, members: 7 */
	/* last cacheline: 44 bytes */
};
struct of_dpa_flow_action {
	uint32_t                   goto_tbl;             /*     0     4 */
	struct {
		uint32_t           group_id;             /*     4     4 */
		uint32_t           tun_log_lport;        /*     8     4 */
		uint16_t           vlan_id;              /*    12     2 */
	} write;                                         /*     4    12 */

	/* XXX last struct has 2 bytes of padding */

	struct {
		uint16_t           new_vlan_id;          /*    16     2 */

		/* XXX 2 bytes hole, try to pack */

		uint32_t           out_pport;            /*    20     4 */
		uint8_t            copy_to_cpu;          /*    24     1 */

		/* XXX 1 byte hole, try to pack */

		uint16_t           vlan_id;              /*    26     2 */
	} apply;                                         /*    16    12 */

	/* size: 28, cachelines: 1, members: 3 */
	/* paddings: 1, sum paddings: 2 */
	/* last cacheline: 28 bytes */
};
struct of_dpa_flow {
	uint32_t                   lpm;                  /*     0     4 */
	uint32_t                   priority;             /*     4     4 */
	uint32_t                   hardtime;             /*     8     4 */
	uint32_t                   idletime;             /*    12     4 */
	uint64_t                   cookie;               /*    16     8 */
	OfDpaFlowKey               key;                  /*    24   108 */
	/* --- cacheline 2 boundary (128 bytes) was 4 bytes ago --- */
	OfDpaFlowKey               mask;                 /*   132   108 */
	/* --- cacheline 3 boundary (192 bytes) was 48 bytes ago --- */
	OfDpaFlowAction            action;               /*   240    28 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	struct {
		uint64_t           hits;                 /*   272     8 */
		int64_t            install_time;         /*   280     8 */
		int64_t            refresh_time;         /*   288     8 */
		uint64_t           rx_pkts;              /*   296     8 */
		uint64_t           tx_pkts;              /*   304     8 */
	} stats;                                         /*   272    40 */

	/* size: 312, cachelines: 5, members: 9 */
	/* sum members: 308, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct of_dpa_flow_pkt_fields {
	uint32_t                   tunnel_id;            /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	struct eth_header *        ethhdr;               /*     8     8 */
	uint16_t *                 h_proto;              /*    16     8 */
	struct vlan_header *       vlanhdr;              /*    24     8 */
	struct ip_header *         ipv4hdr;              /*    32     8 */
	struct ip6_header *        ipv6hdr;              /*    40     8 */
	Ipv6Addr *                 ipv6_src_addr;        /*    48     8 */
	Ipv6Addr *                 ipv6_dst_addr;        /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
	/* sum members: 60, holes: 1, sum holes: 4 */
};
struct of_dpa_flow_context {
	uint32_t                   in_pport;             /*     0     4 */
	uint32_t                   tunnel_id;            /*     4     4 */
	struct iovec *             iov;                  /*     8     8 */
	int                        iovcnt;               /*    16     4 */
	struct eth_header          ethhdr_rewrite;       /*    20    14 */
	struct vlan_header         vlanhdr_rewrite;      /*    34     4 */
	struct vlan_header         vlanhdr;              /*    38     4 */

	/* XXX 6 bytes hole, try to pack */

	OfDpa *                    of_dpa;               /*    48     8 */
	OfDpaFlowPktFields         fields;               /*    56    64 */
	/* --- cacheline 1 boundary (64 bytes) was 56 bytes ago --- */
	OfDpaFlowAction            action_set;           /*   120    28 */

	/* size: 152, cachelines: 3, members: 10 */
	/* sum members: 142, holes: 1, sum holes: 6 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct of_dpa_flow_match {
	OfDpaFlowKey               value;                /*     0   108 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	OfDpaFlow *                best;                 /*   112     8 */

	/* size: 120, cachelines: 2, members: 2 */
	/* sum members: 116, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct of_dpa_group {
	uint32_t                   id;                   /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		struct {
			uint32_t   out_pport;            /*     8     4 */
			uint8_t    pop_vlan;             /*    12     1 */
		} l2_interface;                          /*     8     8 */
		struct {
			uint32_t   group_id;             /*     8     4 */
			MACAddr    src_mac;              /*    12     6 */
			MACAddr    dst_mac;              /*    18     6 */
			uint16_t   vlan_id;              /*    24     2 */
		} l2_rewrite;                            /*     8    20 */
		struct {
			uint16_t   group_count;          /*     8     2 */

			/* XXX 6 bytes hole, try to pack */

			uint32_t * group_ids;            /*    16     8 */
		} l2_flood;                              /*     8    16 */
		struct {
			uint32_t   group_id;             /*     8     4 */
			MACAddr    src_mac;              /*    12     6 */
			MACAddr    dst_mac;              /*    18     6 */
			uint16_t   vlan_id;              /*    24     2 */
			uint8_t    ttl_check;            /*    26     1 */
		} l3_unicast;                            /*     8    20 */
	};                                               /*     8    24 */

	/* size: 32, cachelines: 1, members: 2 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct of_dpa_flow_tbl_ops {
	void                       (*build_match)(OfDpaFlowContext *, OfDpaFlowMatch *); /*     0     8 */
	void                       (*hit)(OfDpaFlowContext *, OfDpaFlow *); /*     8     8 */
	void                       (*miss)(OfDpaFlowContext *); /*    16     8 */
	void                       (*hit_no_goto)(OfDpaFlowContext *); /*    24     8 */
	void                       (*action_apply)(OfDpaFlowContext *, OfDpaFlow *); /*    32     8 */
	void                       (*action_write)(OfDpaFlowContext *, OfDpaFlow *); /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct of_dpa_flow_fill_context {
	RockerOfDpaFlowList *      list;                 /*     0     8 */
	uint32_t                   tbl_id;               /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct of_dpa_group_fill_context {
	RockerOfDpaGroupList *     list;                 /*     0     8 */
	uint8_t                    type;                 /*     8     1 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct _eeprom_t {
	uint8_t                    tick;                 /*     0     1 */
	uint8_t                    address;              /*     1     1 */
	uint8_t                    command;              /*     2     1 */
	uint8_t                    writable;             /*     3     1 */
	uint8_t                    eecs;                 /*     4     1 */
	uint8_t                    eesk;                 /*     5     1 */
	uint8_t                    eedo;                 /*     6     1 */
	uint8_t                    addrbits;             /*     7     1 */
	uint16_t                   size;                 /*     8     2 */
	uint16_t                   data;                 /*    10     2 */
	uint16_t                   contents[];           /*    12     0 */

	/* size: 12, cachelines: 1, members: 11 */
	/* last cacheline: 12 bytes */
};
struct FWCfgIoState {
	FWCfgState                 parent_obj;           /*     0  4352 */
	/* --- cacheline 68 boundary (4352 bytes) --- */
	MemoryRegion               comb_iomem;           /*  4352   256 */
	/* --- cacheline 72 boundary (4608 bytes) --- */
	uint32_t                   iobase;               /*  4608     4 */
	uint32_t                   dma_iobase;           /*  4612     4 */

	/* size: 4624, cachelines: 73, members: 4 */
	/* padding: 8 */
	/* last cacheline: 16 bytes */
};
struct FWCfgMemState {
	FWCfgState                 parent_obj;           /*     0  4352 */
	/* --- cacheline 68 boundary (4352 bytes) --- */
	MemoryRegion               ctl_iomem;            /*  4352   256 */
	/* --- cacheline 72 boundary (4608 bytes) --- */
	MemoryRegion               data_iomem;           /*  4608   256 */
	/* --- cacheline 76 boundary (4864 bytes) --- */
	uint32_t                   data_width;           /*  4864     4 */

	/* XXX 4 bytes hole, try to pack */

	MemoryRegionOps            wide_data_ops;        /*  4872   128 */

	/* size: 5008, cachelines: 79, members: 5 */
	/* sum members: 4996, holes: 1, sum holes: 4 */
	/* padding: 8 */
	/* last cacheline: 16 bytes */
};
struct FWCfgState {
	SysBusDevice               parent_obj;           /*     0   768 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	FWCfgEntry                 entries[2][48];       /*   768  3072 */
	/* --- cacheline 60 boundary (3840 bytes) --- */
	int                        entry_order[48];      /*  3840   192 */
	/* --- cacheline 63 boundary (4032 bytes) --- */
	FWCfgFiles *               files;                /*  4032     8 */
	uint16_t                   cur_entry;            /*  4040     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   cur_offset;           /*  4044     4 */
	Notifier                   machine_ready;        /*  4048    24 */
	int                        fw_cfg_order_override; /*  4072     4 */
	_Bool                      dma_enabled;          /*  4076     1 */

	/* XXX 3 bytes hole, try to pack */

	dma_addr_t                 dma_addr;             /*  4080     8 */
	AddressSpace *             dma_as;               /*  4088     8 */
	/* --- cacheline 64 boundary (4096 bytes) --- */
	MemoryRegion               dma_iomem;            /*  4096   256 */

	/* size: 4352, cachelines: 68, members: 12 */
	/* sum members: 4347, holes: 2, sum holes: 5 */
};
struct FWCfgFile {
	uint32_t                   size;                 /*     0     4 */
	uint16_t                   select;               /*     4     2 */
	uint16_t                   reserved;             /*     6     2 */
	char                       name[56];             /*     8    56 */

	/* size: 64, cachelines: 1, members: 4 */
};
struct FWCfgFiles {
	uint32_t                   count;                /*     0     4 */
	FWCfgFile                  f[];                  /*     4     0 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
struct FWCfgDmaAccess {
	uint32_t                   control;              /*     0     4 */
	uint32_t                   length;               /*     4     4 */
	uint64_t                   address;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct FWCfgEntry {
	uint32_t                   len;                  /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  data;                 /*     8     8 */
	void *                     callback_opaque;      /*    16     8 */
	FWCfgReadCallback          read_callback;        /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct SHPCDevice {
	int                        cap;                  /*     0     4 */
	int                        nslots;               /*     4     4 */
	uint8_t *                  config;               /*     8     8 */
	uint8_t *                  cmask;                /*    16     8 */
	uint8_t *                  wmask;                /*    24     8 */
	uint8_t *                  w1cmask;              /*    32     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               mmio;                 /*    48   256 */
	/* --- cacheline 4 boundary (256 bytes) was 48 bytes ago --- */
	PCIBus *                   sec_bus;              /*   304     8 */
	int                        msi_requested;        /*   312     4 */

	/* size: 320, cachelines: 5, members: 9 */
	/* sum members: 308, holes: 1, sum holes: 8 */
	/* padding: 4 */
};
struct PCIBridgeDev {
	PCIBridge                  parent_obj;           /*     0  5136 */
	/* --- cacheline 80 boundary (5120 bytes) was 16 bytes ago --- */
	MemoryRegion               bar;                  /*  5136   256 */
	/* --- cacheline 84 boundary (5376 bytes) was 16 bytes ago --- */
	uint8_t                    chassis_nr;           /*  5392     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   flags;                /*  5396     4 */
	OnOffAuto                  msi;                  /*  5400     4 */

	/* size: 5408, cachelines: 85, members: 5 */
	/* sum members: 5401, holes: 1, sum holes: 3 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct PCIBusClass {
	BusClass                   parent_class;         /*     0   152 */
	/* --- cacheline 2 boundary (128 bytes) was 24 bytes ago --- */
	_Bool                      (*is_root)(PCIBus *); /*   152     8 */
	int                        (*bus_num)(PCIBus *); /*   160     8 */
	uint16_t                   (*numa_node)(PCIBus *); /*   168     8 */

	/* size: 176, cachelines: 3, members: 4 */
	/* last cacheline: 48 bytes */
};
struct PCIHostBridgeClass {
	SysBusDeviceClass          parent_class;         /*     0   216 */
	/* --- cacheline 3 boundary (192 bytes) was 24 bytes ago --- */
	const char  *              (*root_bus_path)(PCIHostState *, PCIBus *); /*   216     8 */

	/* size: 224, cachelines: 4, members: 2 */
	/* last cacheline: 32 bytes */
};
struct PXBBus {
	PCIBus                     parent_obj;           /*     0  2296 */
	/* --- cacheline 35 boundary (2240 bytes) was 56 bytes ago --- */
	char                       bus_path[8];          /*  2296     8 */

	/* size: 2304, cachelines: 36, members: 2 */
};
struct PXBDev {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	uint8_t                    bus_nr;               /*  2288     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   numa_node;            /*  2290     2 */

	/* Force padding: */
	uint16_t                   :16;
	uint16_t                   :16;
	uint16_t                   :16;
	uint16_t                   :16;
	uint16_t                   :16;
	uint16_t                   :16;

	/* size: 2304, cachelines: 36, members: 3 */
	/* sum members: 2291, holes: 1, sum holes: 1 */
	/* padding: 12 */
};
struct PCIEPort {
	PCIBridge                  parent_obj;           /*     0  5136 */
	/* --- cacheline 80 boundary (5120 bytes) was 16 bytes ago --- */
	uint8_t                    port;                 /*  5136     1 */

	/* Force padding: */
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;

	/* size: 5152, cachelines: 81, members: 2 */
	/* padding: 15 */
	/* last cacheline: 32 bytes */
};
struct PCIESlot {
	PCIEPort                   parent_obj;           /*     0  5152 */
	/* --- cacheline 80 boundary (5120 bytes) was 32 bytes ago --- */
	uint8_t                    chassis;              /*  5152     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   slot;                 /*  5154     2 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct PCIESlot *  le_next;              /*  5160     8 */
		struct PCIESlot * * le_prev;             /*  5168     8 */
	} next;                                          /*  5160    16 */

	/* size: 5184, cachelines: 81, members: 4 */
	/* sum members: 5171, holes: 2, sum holes: 5 */
	/* padding: 8 */
};
struct PCII440FXState {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	MemoryRegion *             system_memory;        /*  2288     8 */
	MemoryRegion *             pci_address_space;    /*  2296     8 */
	/* --- cacheline 36 boundary (2304 bytes) --- */
	MemoryRegion *             ram_memory;           /*  2304     8 */

	/* XXX 8 bytes hole, try to pack */

	PAMMemoryRegion            pam_regions[13];      /*  2320 13520 */
	/* --- cacheline 247 boundary (15808 bytes) was 32 bytes ago --- */
	MemoryRegion               smram_region;         /* 15840   256 */
	/* --- cacheline 251 boundary (16064 bytes) was 32 bytes ago --- */
	MemoryRegion               smram;                /* 16096   256 */
	/* --- cacheline 255 boundary (16320 bytes) was 32 bytes ago --- */
	MemoryRegion               low_smram;            /* 16352   256 */

	/* size: 16608, cachelines: 260, members: 8 */
	/* sum members: 16600, holes: 1, sum holes: 8 */
	/* last cacheline: 32 bytes */
};
struct I440FXState {
	PCIHostState               parent_obj;           /*     0  1568 */
	/* --- cacheline 24 boundary (1536 bytes) was 32 bytes ago --- */
	Range                      pci_hole;             /*  1568    16 */
	uint64_t                   pci_hole64_size;      /*  1584     8 */
	uint32_t                   short_root_bus;       /*  1592     4 */

	/* size: 1600, cachelines: 25, members: 4 */
	/* padding: 4 */
};
struct PIIX3State {
	PCIDevice                  dev;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	uint64_t                   pic_levels;           /*  2288     8 */
	qemu_irq *                 pic;                  /*  2296     8 */
	/* --- cacheline 36 boundary (2304 bytes) --- */
	int32_t                    pci_irq_levels_vmstate[4]; /*  2304    16 */
	uint8_t                    rcr;                  /*  2320     1 */

	/* XXX 15 bytes hole, try to pack */

	MemoryRegion               rcr_mem;              /*  2336   256 */

	/* size: 2592, cachelines: 41, members: 6 */
	/* sum members: 2577, holes: 1, sum holes: 15 */
	/* last cacheline: 32 bytes */
};
struct PCIEAERMsg {
	uint32_t                   severity;             /*     0     4 */
	uint16_t                   source_id;            /*     4     2 */

	/* size: 8, cachelines: 1, members: 2 */
	/* padding: 2 */
	/* last cacheline: 8 bytes */
};
struct PCIEAERInject {
	PCIDevice *                dev;                  /*     0     8 */
	uint8_t *                  aer_cap;              /*     8     8 */
	const PCIEAERErr  *        err;                  /*    16     8 */
	uint16_t                   devctl;               /*    24     2 */
	uint16_t                   devsta;               /*    26     2 */
	uint32_t                   error_status;         /*    28     4 */
	_Bool                      unsupported_request;  /*    32     1 */
	_Bool                      log_overflow;         /*    33     1 */

	/* XXX 2 bytes hole, try to pack */

	PCIEAERMsg                 msg;                  /*    36     8 */

	/* size: 48, cachelines: 1, members: 9 */
	/* sum members: 42, holes: 1, sum holes: 2 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct PCIEAERErrorName {
	const char  *              name;                 /*     0     8 */
	uint32_t                   val;                  /*     8     4 */
	_Bool                      correctable;          /*    12     1 */

	/* size: 16, cachelines: 1, members: 3 */
	/* padding: 3 */
	/* last cacheline: 16 bytes */
};
struct PCIEChassis {
	uint8_t                    number;               /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	struct {
		struct PCIESlot *  lh_first;             /*     8     8 */
	} slots;                                         /*     8     8 */
	struct {
		struct PCIEChassis * le_next;            /*    16     8 */
		struct PCIEChassis * * le_prev;          /*    24     8 */
	} next;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* sum members: 25, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct SCSIDeviceClass {
	DeviceClass                parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	void                       (*realize)(SCSIDevice *, Error * *); /*   192     8 */
	int                        (*parse_cdb)(SCSIDevice *, SCSICommand *, uint8_t *, void *); /*   200     8 */
	SCSIRequest *              (*alloc_req)(SCSIDevice *, uint32_t, uint32_t, uint8_t *, void *); /*   208     8 */
	void                       (*unit_attention_reported)(SCSIDevice *); /*   216     8 */

	/* size: 224, cachelines: 4, members: 5 */
	/* last cacheline: 32 bytes */
};
struct SCSIDiskClass {
	SCSIDeviceClass            parent_class;         /*     0   224 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	DMAIOFunc *                dma_readv;            /*   224     8 */
	DMAIOFunc *                dma_writev;           /*   232     8 */
	_Bool                      (*need_fua_emulation)(SCSICommand *); /*   240     8 */

	/* size: 248, cachelines: 4, members: 4 */
	/* last cacheline: 56 bytes */
};
struct SCSIDiskReq {
	SCSIRequest                req;                  /*     0   408 */
	/* --- cacheline 6 boundary (384 bytes) was 24 bytes ago --- */
	uint64_t                   sector;               /*   408     8 */
	uint32_t                   sector_count;         /*   416     4 */
	uint32_t                   buflen;               /*   420     4 */
	_Bool                      started;              /*   424     1 */
	_Bool                      need_fua_emulation;   /*   425     1 */

	/* XXX 6 bytes hole, try to pack */

	struct iovec               iov;                  /*   432    16 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	QEMUIOVector               qiov;                 /*   448    24 */
	BlockAcctCookie            acct;                 /*   472    24 */
	unsigned char *            status;               /*   496     8 */

	/* size: 504, cachelines: 8, members: 10 */
	/* sum members: 498, holes: 1, sum holes: 6 */
	/* last cacheline: 56 bytes */
};
struct SCSIDiskState {
	SCSIDevice                 qdev;                 /*     0   512 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	uint32_t                   features;             /*   512     4 */
	_Bool                      media_changed;        /*   516     1 */
	_Bool                      media_event;          /*   517     1 */
	_Bool                      eject_request;        /*   518     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   port_index;           /*   520     2 */

	/* XXX 6 bytes hole, try to pack */

	uint64_t                   max_unmap_size;       /*   528     8 */
	uint64_t                   max_io_size;          /*   536     8 */
	QEMUBH *                   bh;                   /*   544     8 */
	char *                     version;              /*   552     8 */
	char *                     serial;               /*   560     8 */
	char *                     vendor;               /*   568     8 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	char *                     product;              /*   576     8 */
	_Bool                      tray_open;            /*   584     1 */
	_Bool                      tray_locked;          /*   585     1 */

	/* size: 592, cachelines: 10, members: 15 */
	/* sum members: 579, holes: 2, sum holes: 7 */
	/* padding: 6 */
	/* last cacheline: 16 bytes */
};
struct UnmapCBData {
	SCSIDiskReq *              r;                    /*     0     8 */
	uint8_t *                  inbuf;                /*     8     8 */
	int                        count;                /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct WriteSameCBData {
	SCSIDiskReq *              r;                    /*     0     8 */
	int64_t                    sector;               /*     8     8 */
	int                        nb_sectors;           /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUIOVector               qiov;                 /*    24    24 */
	struct iovec               iov;                  /*    48    16 */

	/* size: 64, cachelines: 1, members: 5 */
	/* sum members: 60, holes: 1, sum holes: 4 */
};
struct SCSIBlockReq {
	SCSIDiskReq                req;                  /*     0   504 */
	/* --- cacheline 7 boundary (448 bytes) was 56 bytes ago --- */
	sg_io_hdr_t                io_header;            /*   504    88 */
	/* --- cacheline 9 boundary (576 bytes) was 16 bytes ago --- */
	uint8_t                    cmd;                  /*   592     1 */
	uint8_t                    cdb1;                 /*   593     1 */
	uint8_t                    group_number;         /*   594     1 */
	uint8_t                    cdb[16];              /*   595    16 */

	/* size: 616, cachelines: 10, members: 6 */
	/* padding: 5 */
	/* last cacheline: 40 bytes */
};
struct sg_scsi_id {
	int                        host_no;              /*     0     4 */
	int                        channel;              /*     4     4 */
	int                        scsi_id;              /*     8     4 */
	int                        lun;                  /*    12     4 */
	int                        scsi_type;            /*    16     4 */
	short int                  h_cmd_per_lun;        /*    20     2 */
	short int                  d_queue_depth;        /*    22     2 */
	int                        unused[2];            /*    24     8 */

	/* size: 32, cachelines: 1, members: 8 */
	/* last cacheline: 32 bytes */
};
struct SCSIGenericReq {
	SCSIRequest                req;                  /*     0   408 */
	/* --- cacheline 6 boundary (384 bytes) was 24 bytes ago --- */
	uint8_t *                  buf;                  /*   408     8 */
	int                        buflen;               /*   416     4 */
	int                        len;                  /*   420     4 */
	sg_io_hdr_t                io_header;            /*   424    88 */

	/* size: 512, cachelines: 8, members: 5 */
};
struct SCSITargetReq {
	SCSIRequest                req;                  /*     0   408 */
	/* --- cacheline 6 boundary (384 bytes) was 24 bytes ago --- */
	int                        len;                  /*   408     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  buf;                  /*   416     8 */
	int                        buf_len;              /*   424     4 */

	/* size: 432, cachelines: 7, members: 4 */
	/* sum members: 424, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct lsi_request {
	SCSIRequest *              req;                  /*     0     8 */
	uint32_t                   tag;                  /*     8     4 */
	uint32_t                   dma_len;              /*    12     4 */
	uint8_t *                  dma_buf;              /*    16     8 */
	uint32_t                   pending;              /*    24     4 */
	int                        out;                  /*    28     4 */
	struct {
		struct lsi_request * tqe_next;           /*    32     8 */
		struct lsi_request * * tqe_prev;         /*    40     8 */
	} next;                                          /*    32    16 */

	/* size: 48, cachelines: 1, members: 7 */
	/* last cacheline: 48 bytes */
};
struct MPISGEntry {
	uint32_t                   FlagsLength;          /*     0     4 */
	union {
		uint32_t           Address32;            /*     4     4 */
		uint64_t           Address64;            /*     4     8 */
	} u;                                             /*     4     8 */

	/* size: 12, cachelines: 1, members: 2 */
	/* last cacheline: 12 bytes */
} __attribute__((__packed__));
struct MPIRequestHeader {
	uint8_t                    Reserved[2];          /*     0     2 */
	uint8_t                    ChainOffset;          /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    Reserved1[3];         /*     4     3 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */

	/* size: 12, cachelines: 1, members: 6 */
	/* last cacheline: 12 bytes */
};
struct MPIDefaultReply {
	uint8_t                    Reserved[2];          /*     0     2 */
	uint8_t                    MsgLength;            /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    Reserved1[3];         /*     4     3 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */
	uint8_t                    Reserved2[2];         /*    12     2 */
	uint16_t                   IOCStatus;            /*    14     2 */
	uint32_t                   IOCLogInfo;           /*    16     4 */

	/* size: 20, cachelines: 1, members: 9 */
	/* last cacheline: 20 bytes */
};
struct MPIMsgSCSIIORequest {
	uint8_t                    TargetID;             /*     0     1 */
	uint8_t                    Bus;                  /*     1     1 */
	uint8_t                    ChainOffset;          /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    CDBLength;            /*     4     1 */
	uint8_t                    SenseBufferLength;    /*     5     1 */
	uint8_t                    Reserved;             /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */
	uint8_t                    LUN[8];               /*    12     8 */
	uint32_t                   Control;              /*    20     4 */
	uint8_t                    CDB[16];              /*    24    16 */
	uint32_t                   DataLength;           /*    40     4 */
	uint32_t                   SenseBufferLowAddr;   /*    44     4 */

	/* size: 48, cachelines: 1, members: 14 */
	/* last cacheline: 48 bytes */
};
struct MPIMsgSCSIIOReply {
	uint8_t                    TargetID;             /*     0     1 */
	uint8_t                    Bus;                  /*     1     1 */
	uint8_t                    MsgLength;            /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    CDBLength;            /*     4     1 */
	uint8_t                    SenseBufferLength;    /*     5     1 */
	uint8_t                    Reserved;             /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */
	uint8_t                    SCSIStatus;           /*    12     1 */
	uint8_t                    SCSIState;            /*    13     1 */
	uint16_t                   IOCStatus;            /*    14     2 */
	uint32_t                   IOCLogInfo;           /*    16     4 */
	uint32_t                   TransferCount;        /*    20     4 */
	uint32_t                   SenseCount;           /*    24     4 */
	uint32_t                   ResponseInfo;         /*    28     4 */
	uint16_t                   TaskTag;              /*    32     2 */
	uint16_t                   Reserved1;            /*    34     2 */

	/* size: 36, cachelines: 1, members: 18 */
	/* last cacheline: 36 bytes */
};
struct MPIMsgSCSITaskMgmt {
	uint8_t                    TargetID;             /*     0     1 */
	uint8_t                    Bus;                  /*     1     1 */
	uint8_t                    ChainOffset;          /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    Reserved;             /*     4     1 */
	uint8_t                    TaskType;             /*     5     1 */
	uint8_t                    Reserved1;            /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */
	uint8_t                    LUN[8];               /*    12     8 */
	uint32_t                   Reserved2[7];         /*    20    28 */
	uint32_t                   TaskMsgContext;       /*    48     4 */

	/* size: 52, cachelines: 1, members: 12 */
	/* last cacheline: 52 bytes */
};
struct MPIMsgSCSITaskMgmtReply {
	uint8_t                    TargetID;             /*     0     1 */
	uint8_t                    Bus;                  /*     1     1 */
	uint8_t                    MsgLength;            /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    ResponseCode;         /*     4     1 */
	uint8_t                    TaskType;             /*     5     1 */
	uint8_t                    Reserved1;            /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */
	uint8_t                    Reserved2[2];         /*    12     2 */
	uint16_t                   IOCStatus;            /*    14     2 */
	uint32_t                   IOCLogInfo;           /*    16     4 */
	uint32_t                   TerminationCount;     /*    20     4 */

	/* size: 24, cachelines: 1, members: 13 */
	/* last cacheline: 24 bytes */
};
struct MPIMsgIOCInit {
	uint8_t                    WhoInit;              /*     0     1 */
	uint8_t                    Reserved;             /*     1     1 */
	uint8_t                    ChainOffset;          /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    Flags;                /*     4     1 */
	uint8_t                    MaxDevices;           /*     5     1 */
	uint8_t                    MaxBuses;             /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */
	uint16_t                   ReplyFrameSize;       /*    12     2 */
	uint8_t                    Reserved1[2];         /*    14     2 */
	uint32_t                   HostMfaHighAddr;      /*    16     4 */
	uint32_t                   SenseBufferHighAddr;  /*    20     4 */
	uint32_t                   ReplyFifoHostSignalingAddr; /*    24     4 */
	MPISGEntry                 HostPageBufferSGE;    /*    28    12 */
	uint16_t                   MsgVersion;           /*    40     2 */
	uint16_t                   HeaderVersion;        /*    42     2 */

	/* size: 44, cachelines: 1, members: 17 */
	/* last cacheline: 44 bytes */
} __attribute__((__packed__));
struct MPIMsgIOCInitReply {
	uint8_t                    WhoInit;              /*     0     1 */
	uint8_t                    Reserved;             /*     1     1 */
	uint8_t                    MsgLength;            /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    Flags;                /*     4     1 */
	uint8_t                    MaxDevices;           /*     5     1 */
	uint8_t                    MaxBuses;             /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */
	uint16_t                   Reserved2;            /*    12     2 */
	uint16_t                   IOCStatus;            /*    14     2 */
	uint32_t                   IOCLogInfo;           /*    16     4 */

	/* size: 20, cachelines: 1, members: 12 */
	/* last cacheline: 20 bytes */
};
struct MPIMsgIOCFacts {
	uint8_t                    Reserved[2];          /*     0     2 */
	uint8_t                    ChainOffset;          /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    Reserved1[3];         /*     4     3 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */

	/* size: 12, cachelines: 1, members: 6 */
	/* last cacheline: 12 bytes */
};
struct MPIMsgIOCFactsReply {
	uint16_t                   MsgVersion;           /*     0     2 */
	uint8_t                    MsgLength;            /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint16_t                   HeaderVersion;        /*     4     2 */
	uint8_t                    IOCNumber;            /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */
	uint16_t                   IOCExceptions;        /*    12     2 */
	uint16_t                   IOCStatus;            /*    14     2 */
	uint32_t                   IOCLogInfo;           /*    16     4 */
	uint8_t                    MaxChainDepth;        /*    20     1 */
	uint8_t                    WhoInit;              /*    21     1 */
	uint8_t                    BlockSize;            /*    22     1 */
	uint8_t                    Flags;                /*    23     1 */
	uint16_t                   ReplyQueueDepth;      /*    24     2 */
	uint16_t                   RequestFrameSize;     /*    26     2 */
	uint16_t                   Reserved_0101_FWVersion; /*    28     2 */
	uint16_t                   ProductID;            /*    30     2 */
	uint32_t                   CurrentHostMfaHighAddr; /*    32     4 */
	uint16_t                   GlobalCredits;        /*    36     2 */
	uint8_t                    NumberOfPorts;        /*    38     1 */
	uint8_t                    EventState;           /*    39     1 */
	uint32_t                   CurrentSenseBufferHighAddr; /*    40     4 */
	uint16_t                   CurReplyFrameSize;    /*    44     2 */
	uint8_t                    MaxDevices;           /*    46     1 */
	uint8_t                    MaxBuses;             /*    47     1 */
	uint32_t                   FWImageSize;          /*    48     4 */
	uint32_t                   IOCCapabilities;      /*    52     4 */
	uint8_t                    FWVersionDev;         /*    56     1 */
	uint8_t                    FWVersionUnit;        /*    57     1 */
	uint8_t                    FWVersionMinor;       /*    58     1 */
	uint8_t                    FWVersionMajor;       /*    59     1 */
	uint16_t                   HighPriorityQueueDepth; /*    60     2 */
	uint16_t                   Reserved2;            /*    62     2 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	MPISGEntry                 HostPageBufferSGE;    /*    64    12 */
	uint32_t                   ReplyFifoHostSignalingAddr; /*    76     4 */

	/* size: 80, cachelines: 2, members: 36 */
	/* last cacheline: 16 bytes */
};
struct MPIMsgPortFacts {
	uint8_t                    Reserved[2];          /*     0     2 */
	uint8_t                    ChainOffset;          /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    Reserved1[2];         /*     4     2 */
	uint8_t                    PortNumber;           /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */

	/* size: 12, cachelines: 1, members: 7 */
	/* last cacheline: 12 bytes */
};
struct MPIMsgPortFactsReply {
	uint16_t                   Reserved;             /*     0     2 */
	uint8_t                    MsgLength;            /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint16_t                   Reserved1;            /*     4     2 */
	uint8_t                    PortNumber;           /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */
	uint16_t                   Reserved2;            /*    12     2 */
	uint16_t                   IOCStatus;            /*    14     2 */
	uint32_t                   IOCLogInfo;           /*    16     4 */
	uint8_t                    Reserved3;            /*    20     1 */
	uint8_t                    PortType;             /*    21     1 */
	uint16_t                   MaxDevices;           /*    22     2 */
	uint16_t                   PortSCSIID;           /*    24     2 */
	uint16_t                   ProtocolFlags;        /*    26     2 */
	uint16_t                   MaxPostedCmdBuffers;  /*    28     2 */
	uint16_t                   MaxPersistentIDs;     /*    30     2 */
	uint16_t                   MaxLanBuckets;        /*    32     2 */
	uint8_t                    MaxInitiators;        /*    34     1 */
	uint8_t                    Reserved4;            /*    35     1 */
	uint32_t                   Reserved5;            /*    36     4 */

	/* size: 40, cachelines: 1, members: 21 */
	/* last cacheline: 40 bytes */
};
struct MPIMsgPortEnable {
	uint8_t                    Reserved[2];          /*     0     2 */
	uint8_t                    ChainOffset;          /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    Reserved1[2];         /*     4     2 */
	uint8_t                    PortNumber;           /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */

	/* size: 12, cachelines: 1, members: 7 */
	/* last cacheline: 12 bytes */
};
struct MPIMsgPortEnableReply {
	uint8_t                    Reserved[2];          /*     0     2 */
	uint8_t                    MsgLength;            /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    Reserved1[2];         /*     4     2 */
	uint8_t                    PortNumber;           /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */
	uint16_t                   Reserved2;            /*    12     2 */
	uint16_t                   IOCStatus;            /*    14     2 */
	uint32_t                   IOCLogInfo;           /*    16     4 */

	/* size: 20, cachelines: 1, members: 10 */
	/* last cacheline: 20 bytes */
};
struct MPIMsgEventNotify {
	uint8_t                    Switch;               /*     0     1 */
	uint8_t                    Reserved;             /*     1     1 */
	uint8_t                    ChainOffset;          /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    Reserved1[3];         /*     4     3 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */

	/* size: 12, cachelines: 1, members: 7 */
	/* last cacheline: 12 bytes */
};
struct MPIMsgEventNotifyReply {
	uint16_t                   EventDataLength;      /*     0     2 */
	uint8_t                    MsgLength;            /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint8_t                    Reserved1[2];         /*     4     2 */
	uint8_t                    AckRequired;          /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */
	uint8_t                    Reserved2[2];         /*    12     2 */
	uint16_t                   IOCStatus;            /*    14     2 */
	uint32_t                   IOCLogInfo;           /*    16     4 */
	uint32_t                   Event;                /*    20     4 */
	uint32_t                   EventContext;         /*    24     4 */
	uint32_t                   Data[1];              /*    28     4 */

	/* size: 32, cachelines: 1, members: 13 */
	/* last cacheline: 32 bytes */
};
struct MPIMsgConfig {
	uint8_t                    Action;               /*     0     1 */
	uint8_t                    Reserved;             /*     1     1 */
	uint8_t                    ChainOffset;          /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint16_t                   ExtPageLength;        /*     4     2 */
	uint8_t                    ExtPageType;          /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */
	uint8_t                    Reserved2[8];         /*    12     8 */
	uint8_t                    PageVersion;          /*    20     1 */
	uint8_t                    PageLength;           /*    21     1 */
	uint8_t                    PageNumber;           /*    22     1 */
	uint8_t                    PageType;             /*    23     1 */
	uint32_t                   PageAddress;          /*    24     4 */
	MPISGEntry                 PageBufferSGE;        /*    28    12 */

	/* size: 40, cachelines: 1, members: 15 */
	/* last cacheline: 40 bytes */
} __attribute__((__packed__));
struct MPTSASState {
	PCIDevice                  dev;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	MemoryRegion               mmio_io;              /*  2288   256 */
	/* --- cacheline 39 boundary (2496 bytes) was 48 bytes ago --- */
	MemoryRegion               port_io;              /*  2544   256 */
	/* --- cacheline 43 boundary (2752 bytes) was 48 bytes ago --- */
	MemoryRegion               diag_io;              /*  2800   256 */
	/* --- cacheline 47 boundary (3008 bytes) was 48 bytes ago --- */
	QEMUBH *                   request_bh;           /*  3056     8 */
	OnOffAuto                  msi;                  /*  3064     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 48 boundary (3072 bytes) --- */
	uint64_t                   sas_addr;             /*  3072     8 */
	_Bool                      msi_in_use;           /*  3080     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   state;                /*  3084     4 */
	uint8_t                    who_init;             /*  3088     1 */
	uint8_t                    doorbell_state;       /*  3089     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   doorbell_msg[256];    /*  3092  1024 */
	/* --- cacheline 64 boundary (4096 bytes) was 20 bytes ago --- */
	int                        doorbell_idx;         /*  4116     4 */
	int                        doorbell_cnt;         /*  4120     4 */
	uint16_t                   doorbell_reply[256];  /*  4124   512 */
	/* --- cacheline 72 boundary (4608 bytes) was 28 bytes ago --- */
	int                        doorbell_reply_idx;   /*  4636     4 */
	int                        doorbell_reply_size;  /*  4640     4 */
	uint8_t                    diagnostic_idx;       /*  4644     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   diagnostic;           /*  4648     4 */
	uint32_t                   intr_mask;            /*  4652     4 */
	uint32_t                   intr_status;          /*  4656     4 */
	uint32_t                   request_post[129];    /*  4660   516 */
	/* --- cacheline 80 boundary (5120 bytes) was 56 bytes ago --- */
	uint16_t                   request_post_head;    /*  5176     2 */
	uint16_t                   request_post_tail;    /*  5178     2 */
	uint32_t                   reply_post[129];      /*  5180   516 */
	/* --- cacheline 89 boundary (5696 bytes) --- */
	uint16_t                   reply_post_head;      /*  5696     2 */
	uint16_t                   reply_post_tail;      /*  5698     2 */
	uint32_t                   reply_free[129];      /*  5700   516 */
	/* --- cacheline 97 boundary (6208 bytes) was 8 bytes ago --- */
	uint16_t                   reply_free_head;      /*  6216     2 */
	uint16_t                   reply_free_tail;      /*  6218     2 */

	/* XXX 4 bytes hole, try to pack */

	hwaddr                     host_mfa_high_addr;   /*  6224     8 */
	hwaddr                     sense_buffer_high_addr; /*  6232     8 */
	uint16_t                   max_devices;          /*  6240     2 */
	uint16_t                   max_buses;            /*  6242     2 */
	uint16_t                   reply_frame_size;     /*  6244     2 */

	/* XXX 2 bytes hole, try to pack */

	SCSIBus                    bus;                  /*  6248   120 */
	/* --- cacheline 99 boundary (6336 bytes) was 32 bytes ago --- */
	struct {
		struct MPTSASRequest * tqh_first;        /*  6368     8 */
		struct MPTSASRequest * * tqh_last;       /*  6376     8 */
	} pending;                                       /*  6368    16 */

	/* size: 6384, cachelines: 100, members: 37 */
	/* sum members: 6366, holes: 6, sum holes: 18 */
	/* last cacheline: 48 bytes */
};
struct MPTSASRequest {
	MPIMsgSCSIIORequest        scsi_io;              /*     0    48 */
	SCSIRequest *              sreq;                 /*    48     8 */
	QEMUSGList                 qsg;                  /*    56    40 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	MPTSASState *              dev;                  /*    96     8 */
	struct {
		struct MPTSASRequest * tqe_next;         /*   104     8 */
		struct MPTSASRequest * * tqe_prev;       /*   112     8 */
	} next;                                          /*   104    16 */

	/* size: 120, cachelines: 2, members: 5 */
	/* last cacheline: 56 bytes */
};
struct MPIMsgConfigReply {
	uint8_t                    Action;               /*     0     1 */
	uint8_t                    Reserved;             /*     1     1 */
	uint8_t                    MsgLength;            /*     2     1 */
	uint8_t                    Function;             /*     3     1 */
	uint16_t                   ExtPageLength;        /*     4     2 */
	uint8_t                    ExtPageType;          /*     6     1 */
	uint8_t                    MsgFlags;             /*     7     1 */
	uint32_t                   MsgContext;           /*     8     4 */
	uint8_t                    Reserved2[2];         /*    12     2 */
	uint16_t                   IOCStatus;            /*    14     2 */
	uint32_t                   IOCLogInfo;           /*    16     4 */
	uint8_t                    PageVersion;          /*    20     1 */
	uint8_t                    PageLength;           /*    21     1 */
	uint8_t                    PageNumber;           /*    22     1 */
	uint8_t                    PageType;             /*    23     1 */

	/* size: 24, cachelines: 1, members: 15 */
	/* last cacheline: 24 bytes */
};
union PackValue {
	uint64_t                   ll;                 /*     0     8 */
	char *                     str;                /*     0     8 */
};
struct MPTSASConfigPage {
	uint8_t                    number;               /*     0     1 */
	uint8_t                    type;                 /*     1     1 */

	/* XXX 6 bytes hole, try to pack */

	size_t                     (*mpt_config_build)(MPTSASState *, uint8_t * *, int); /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* sum members: 10, holes: 1, sum holes: 6 */
	/* last cacheline: 16 bytes */
};
struct mfi_sg32 {
	uint32_t                   addr;                 /*     0     4 */
	uint32_t                   len;                  /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct mfi_sg64 {
	uint64_t                   addr;                 /*     0     8 */
	uint32_t                   len;                  /*     8     4 */

	/* size: 12, cachelines: 1, members: 2 */
	/* last cacheline: 12 bytes */
} __attribute__((__packed__));
struct mfi_sg_skinny {
	uint64_t                   addr;                 /*     0     8 */
	uint32_t                   len;                  /*     8     4 */
	uint32_t                   flag;                 /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
union mfi_sgl {
	struct mfi_sg32            sg32[1];            /*     0     8 */
	struct mfi_sg64            sg64[1];            /*     0    12 */
	struct mfi_sg_skinny       sg_skinny[1];       /*     0    16 */
};
struct mfi_frame_header {
	uint8_t                    frame_cmd;            /*     0     1 */
	uint8_t                    sense_len;            /*     1     1 */
	uint8_t                    cmd_status;           /*     2     1 */
	uint8_t                    scsi_status;          /*     3     1 */
	uint8_t                    target_id;            /*     4     1 */
	uint8_t                    lun_id;               /*     5     1 */
	uint8_t                    cdb_len;              /*     6     1 */
	uint8_t                    sge_count;            /*     7     1 */
	uint64_t                   context;              /*     8     8 */
	uint16_t                   flags;                /*    16     2 */
	uint16_t                   timeout;              /*    18     2 */
	uint32_t                   data_len;             /*    20     4 */

	/* size: 24, cachelines: 1, members: 12 */
	/* last cacheline: 24 bytes */
};
struct mfi_init_frame {
	struct mfi_frame_header    header;               /*     0    24 */
	uint32_t                   qinfo_new_addr_lo;    /*    24     4 */
	uint32_t                   qinfo_new_addr_hi;    /*    28     4 */
	uint32_t                   qinfo_old_addr_lo;    /*    32     4 */
	uint32_t                   qinfo_old_addr_hi;    /*    36     4 */
	uint32_t                   reserved[6];          /*    40    24 */

	/* size: 64, cachelines: 1, members: 6 */
};
struct mfi_io_frame {
	struct mfi_frame_header    header;               /*     0    24 */
	uint32_t                   sense_addr_lo;        /*    24     4 */
	uint32_t                   sense_addr_hi;        /*    28     4 */
	uint32_t                   lba_lo;               /*    32     4 */
	uint32_t                   lba_hi;               /*    36     4 */
	union mfi_sgl              sgl;                  /*    40    16 */

	/* size: 56, cachelines: 1, members: 6 */
	/* last cacheline: 56 bytes */
};
struct mfi_pass_frame {
	struct mfi_frame_header    header;               /*     0    24 */
	uint32_t                   sense_addr_lo;        /*    24     4 */
	uint32_t                   sense_addr_hi;        /*    28     4 */
	uint8_t                    cdb[16];              /*    32    16 */
	union mfi_sgl              sgl;                  /*    48    16 */

	/* size: 64, cachelines: 1, members: 5 */
};
struct mfi_dcmd_frame {
	struct mfi_frame_header    header;               /*     0    24 */
	uint32_t                   opcode;               /*    24     4 */
	uint8_t                    mbox[12];             /*    28    12 */
	union mfi_sgl              sgl;                  /*    40    16 */

	/* size: 56, cachelines: 1, members: 4 */
	/* last cacheline: 56 bytes */
};
struct mfi_abort_frame {
	struct mfi_frame_header    header;               /*     0    24 */
	uint64_t                   abort_context;        /*    24     8 */
	uint32_t                   abort_mfi_addr_lo;    /*    32     4 */
	uint32_t                   abort_mfi_addr_hi;    /*    36     4 */
	uint32_t                   reserved1[6];         /*    40    24 */

	/* size: 64, cachelines: 1, members: 5 */
};
struct mfi_smp_frame {
	struct mfi_frame_header    header;               /*     0    24 */
	uint64_t                   sas_addr;             /*    24     8 */
	union {
		struct mfi_sg32    sg32[2];              /*    32    16 */
		struct mfi_sg64    sg64[2];              /*    32    24 */
	} sgl;                                           /*    32    24 */

	/* size: 56, cachelines: 1, members: 3 */
	/* last cacheline: 56 bytes */
};
struct mfi_stp_frame {
	struct mfi_frame_header    header;               /*     0    24 */
	uint16_t                   fis[10];              /*    24    20 */
	uint32_t                   stp_flags;            /*    44     4 */
	union {
		struct mfi_sg32    sg32[2];              /*    48    16 */
		struct mfi_sg64    sg64[2];              /*    48    24 */
	} sgl;                                           /*    48    24 */

	/* size: 72, cachelines: 2, members: 4 */
	/* last cacheline: 8 bytes */
};
union mfi_frame {
	struct mfi_frame_header    header;             /*     0    24 */
	struct mfi_init_frame      init;               /*     0    64 */
	struct mfi_io_frame        io;                 /*     0    56 */
	struct mfi_pass_frame      pass;               /*     0    64 */
	struct mfi_dcmd_frame      dcmd;               /*     0    56 */
	struct mfi_abort_frame     abort;              /*     0    64 */
	struct mfi_smp_frame       smp;                /*     0    56 */
	struct mfi_stp_frame       stp;                /*     0    72 */
	uint64_t                   raw[8];             /*     0    64 */
	uint8_t                    bytes[64];          /*     0    64 */
};
struct mfi_init_qinfo {
	uint32_t                   flags;                /*     0     4 */
	uint32_t                   rq_entries;           /*     4     4 */
	uint32_t                   rq_addr_lo;           /*     8     4 */
	uint32_t                   rq_addr_hi;           /*    12     4 */
	uint32_t                   pi_addr_lo;           /*    16     4 */
	uint32_t                   pi_addr_hi;           /*    20     4 */
	uint32_t                   ci_addr_lo;           /*    24     4 */
	uint32_t                   ci_addr_hi;           /*    28     4 */

	/* size: 32, cachelines: 1, members: 8 */
	/* last cacheline: 32 bytes */
};
struct mfi_ctrl_props {
	uint16_t                   seq_num;              /*     0     2 */
	uint16_t                   pred_fail_poll_interval; /*     2     2 */
	uint16_t                   intr_throttle_cnt;    /*     4     2 */
	uint16_t                   intr_throttle_timeout; /*     6     2 */
	uint8_t                    rebuild_rate;         /*     8     1 */
	uint8_t                    patrol_read_rate;     /*     9     1 */
	uint8_t                    bgi_rate;             /*    10     1 */
	uint8_t                    cc_rate;              /*    11     1 */
	uint8_t                    recon_rate;           /*    12     1 */
	uint8_t                    cache_flush_interval; /*    13     1 */
	uint8_t                    spinup_drv_cnt;       /*    14     1 */
	uint8_t                    spinup_delay;         /*    15     1 */
	uint8_t                    cluster_enable;       /*    16     1 */
	uint8_t                    coercion_mode;        /*    17     1 */
	uint8_t                    alarm_enable;         /*    18     1 */
	uint8_t                    disable_auto_rebuild; /*    19     1 */
	uint8_t                    disable_battery_warn; /*    20     1 */
	uint8_t                    ecc_bucket_size;      /*    21     1 */
	uint16_t                   ecc_bucket_leak_rate; /*    22     2 */
	uint8_t                    restore_hotspare_on_insertion; /*    24     1 */
	uint8_t                    expose_encl_devices;  /*    25     1 */
	uint8_t                    maintainPdFailHistory; /*    26     1 */
	uint8_t                    disallowHostRequestReordering; /*    27     1 */
	uint8_t                    abortCCOnError;       /*    28     1 */
	uint8_t                    loadBalanceMode;      /*    29     1 */
	uint8_t                    disableAutoDetectBackplane; /*    30     1 */
	uint8_t                    snapVDSpace;          /*    31     1 */
	uint32_t                   OnOffProperties;      /*    32     4 */
	uint8_t                    autoSnapVDSpace;      /*    36     1 */
	uint8_t                    viewSpace;            /*    37     1 */
	uint16_t                   spinDownTime;         /*    38     2 */
	uint8_t                    reserved[24];         /*    40    24 */

	/* size: 64, cachelines: 1, members: 32 */
};
struct mfi_info_pci {
	uint16_t                   vendor;               /*     0     2 */
	uint16_t                   device;               /*     2     2 */
	uint16_t                   subvendor;            /*     4     2 */
	uint16_t                   subdevice;            /*     6     2 */
	uint8_t                    reserved[24];         /*     8    24 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct mfi_info_host {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    reserved[6];          /*     1     6 */
	uint8_t                    port_count;           /*     7     1 */
	uint64_t                   port_addr[8];         /*     8    64 */

	/* size: 72, cachelines: 2, members: 4 */
	/* last cacheline: 8 bytes */
};
struct mfi_info_device {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    reserved[6];          /*     1     6 */
	uint8_t                    port_count;           /*     7     1 */
	uint64_t                   port_addr[8];         /*     8    64 */

	/* size: 72, cachelines: 2, members: 4 */
	/* last cacheline: 8 bytes */
};
struct mfi_info_component {
	char                       name[8];              /*     0     8 */
	char                       version[32];          /*     8    32 */
	char                       build_date[16];       /*    40    16 */
	char                       build_time[16];       /*    56    16 */

	/* size: 72, cachelines: 2, members: 4 */
	/* last cacheline: 8 bytes */
};
struct mfi_defaults {
	uint64_t                   sas_addr;             /*     0     8 */
	uint8_t                    phy_polarity;         /*     8     1 */
	uint8_t                    background_rate;      /*     9     1 */
	uint8_t                    stripe_size;          /*    10     1 */
	uint8_t                    flush_time;           /*    11     1 */
	uint8_t                    write_back;           /*    12     1 */
	uint8_t                    read_ahead;           /*    13     1 */
	uint8_t                    cache_when_bbu_bad;   /*    14     1 */
	uint8_t                    cached_io;            /*    15     1 */
	uint8_t                    smart_mode;           /*    16     1 */
	uint8_t                    alarm_disable;        /*    17     1 */
	uint8_t                    coercion;             /*    18     1 */
	uint8_t                    zrc_config;           /*    19     1 */
	uint8_t                    dirty_led_shows_drive_activity; /*    20     1 */
	uint8_t                    bios_continue_on_error; /*    21     1 */
	uint8_t                    spindown_mode;        /*    22     1 */
	uint8_t                    allowed_device_types; /*    23     1 */
	uint8_t                    allow_mix_in_enclosure; /*    24     1 */
	uint8_t                    allow_mix_in_ld;      /*    25     1 */
	uint8_t                    allow_sata_in_cluster; /*    26     1 */
	uint8_t                    max_chained_enclosures; /*    27     1 */
	uint8_t                    disable_ctrl_r;       /*    28     1 */
	uint8_t                    enable_web_bios;      /*    29     1 */
	uint8_t                    phy_polarity_split;   /*    30     1 */
	uint8_t                    direct_pd_mapping;    /*    31     1 */
	uint8_t                    bios_enumerate_lds;   /*    32     1 */
	uint8_t                    restored_hot_spare_on_insertion; /*    33     1 */
	uint8_t                    expose_enclosure_devices; /*    34     1 */
	uint8_t                    maintain_pd_fail_history; /*    35     1 */
	uint8_t                    disable_puncture;     /*    36     1 */
	uint8_t                    zero_based_enumeration; /*    37     1 */
	uint8_t                    disable_preboot_cli;  /*    38     1 */
	uint8_t                    show_drive_led_on_activity; /*    39     1 */
	uint8_t                    cluster_disable;      /*    40     1 */
	uint8_t                    sas_disable;          /*    41     1 */
	uint8_t                    auto_detect_backplane; /*    42     1 */
	uint8_t                    fde_only;             /*    43     1 */
	uint8_t                    delay_during_post;    /*    44     1 */
	uint8_t                    resv[19];             /*    45    19 */

	/* size: 64, cachelines: 1, members: 39 */
};
struct mfi_bios_data {
	uint16_t                   boot_target_id;       /*     0     2 */
	uint8_t                    do_not_int_13;        /*     2     1 */
	uint8_t                    continue_on_error;    /*     3     1 */
	uint8_t                    verbose;              /*     4     1 */
	uint8_t                    geometry;             /*     5     1 */
	uint8_t                    expose_all_drives;    /*     6     1 */
	uint8_t                    reserved[56];         /*     7    56 */
	uint8_t                    check_sum;            /*    63     1 */

	/* size: 64, cachelines: 1, members: 8 */
};
struct mfi_ctrl_info {
	struct mfi_info_pci        pci;                  /*     0    32 */
	struct mfi_info_host       host;                 /*    32    72 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	struct mfi_info_device     device;               /*   104    72 */
	/* --- cacheline 2 boundary (128 bytes) was 48 bytes ago --- */
	uint32_t                   image_check_word;     /*   176     4 */
	uint32_t                   image_component_count; /*   180     4 */
	struct mfi_info_component  image_component[8];   /*   184   576 */
	/* --- cacheline 11 boundary (704 bytes) was 56 bytes ago --- */
	uint32_t                   pending_image_component_count; /*   760     4 */
	struct mfi_info_component  pending_image_component[8]; /*   764   576 */
	/* --- cacheline 20 boundary (1280 bytes) was 60 bytes ago --- */
	uint8_t                    max_arms;             /*  1340     1 */
	uint8_t                    max_spans;            /*  1341     1 */
	uint8_t                    max_arrays;           /*  1342     1 */
	uint8_t                    max_lds;              /*  1343     1 */
	/* --- cacheline 21 boundary (1344 bytes) --- */
	char                       product_name[80];     /*  1344    80 */
	/* --- cacheline 22 boundary (1408 bytes) was 16 bytes ago --- */
	char                       serial_number[32];    /*  1424    32 */
	uint32_t                   hw_present;           /*  1456     4 */
	uint32_t                   current_fw_time;      /*  1460     4 */
	uint16_t                   max_cmds;             /*  1464     2 */
	uint16_t                   max_sg_elements;      /*  1466     2 */
	uint32_t                   max_request_size;     /*  1468     4 */
	/* --- cacheline 23 boundary (1472 bytes) --- */
	uint16_t                   lds_present;          /*  1472     2 */
	uint16_t                   lds_degraded;         /*  1474     2 */
	uint16_t                   lds_offline;          /*  1476     2 */
	uint16_t                   pd_present;           /*  1478     2 */
	uint16_t                   pd_disks_present;     /*  1480     2 */
	uint16_t                   pd_disks_pred_failure; /*  1482     2 */
	uint16_t                   pd_disks_failed;      /*  1484     2 */
	uint16_t                   nvram_size;           /*  1486     2 */
	uint16_t                   memory_size;          /*  1488     2 */
	uint16_t                   flash_size;           /*  1490     2 */
	uint16_t                   ram_correctable_errors; /*  1492     2 */
	uint16_t                   ram_uncorrectable_errors; /*  1494     2 */
	uint8_t                    cluster_allowed;      /*  1496     1 */
	uint8_t                    cluster_active;       /*  1497     1 */
	uint16_t                   max_strips_per_io;    /*  1498     2 */
	uint32_t                   raid_levels;          /*  1500     4 */
	uint32_t                   adapter_ops;          /*  1504     4 */
	uint32_t                   ld_ops;               /*  1508     4 */
	struct {
		uint8_t            min;                  /*  1512     1 */
		uint8_t            max;                  /*  1513     1 */
		uint8_t            reserved[2];          /*  1514     2 */
	} stripe_sz_ops;                                 /*  1512     4 */
	uint32_t                   pd_ops;               /*  1516     4 */
	uint32_t                   pd_mix_support;       /*  1520     4 */
	uint8_t                    ecc_bucket_count;     /*  1524     1 */
	uint8_t                    reserved2[11];        /*  1525    11 */
	/* --- cacheline 24 boundary (1536 bytes) --- */
	struct mfi_ctrl_props      properties;           /*  1536    64 */
	/* --- cacheline 25 boundary (1600 bytes) --- */
	char                       package_version[96];  /*  1600    96 */
	/* --- cacheline 26 boundary (1664 bytes) was 32 bytes ago --- */
	uint8_t                    pad[352];             /*  1696   352 */

	/* size: 2048, cachelines: 32, members: 45 */
};
union mfi_evt {
	struct {
		uint16_t           locale;             /*     0     2 */
		uint8_t            reserved;           /*     2     1 */
		int8_t             class;              /*     3     1 */
	} members;                                     /*     0     4 */
	uint32_t                   word;               /*     0     4 */
};
struct mfi_evt_log_state {
	uint32_t                   newest_seq_num;       /*     0     4 */
	uint32_t                   oldest_seq_num;       /*     4     4 */
	uint32_t                   clear_seq_num;        /*     8     4 */
	uint32_t                   shutdown_seq_num;     /*    12     4 */
	uint32_t                   boot_seq_num;         /*    16     4 */

	/* size: 20, cachelines: 1, members: 5 */
	/* last cacheline: 20 bytes */
};
struct mfi_progress {
	uint16_t                   progress;             /*     0     2 */
	uint16_t                   elapsed_seconds;      /*     2     2 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
union mfi_pd_ref {
	struct {
		uint16_t           device_id;          /*     0     2 */
		uint16_t           seq_num;            /*     2     2 */
	} v;                                           /*     0     4 */
	uint32_t                   ref;                /*     0     4 */
};
union mfi_pd_ddf_type {
	struct {
		uint16_t           pd_type;            /*     0     2 */
		uint16_t           reserved;           /*     2     2 */
	} ddf;                                         /*     0     4 */
	struct {
		uint32_t           reserved;           /*     0     4 */
	} non_disk;                                    /*     0     4 */
	uint32_t                   type;               /*     0     4 */
};
struct mfi_pd_progress {
	uint32_t                   active;               /*     0     4 */
	struct mfi_progress        rbld;                 /*     4     4 */
	struct mfi_progress        patrol;               /*     8     4 */
	struct mfi_progress        clear;                /*    12     4 */
	struct mfi_progress        reserved[4];          /*    16    16 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct mfi_pd_info {
	union mfi_pd_ref           ref;                  /*     0     4 */
	uint8_t                    inquiry_data[96];     /*     4    96 */
	/* --- cacheline 1 boundary (64 bytes) was 36 bytes ago --- */
	uint8_t                    vpd_page83[64];       /*   100    64 */
	/* --- cacheline 2 boundary (128 bytes) was 36 bytes ago --- */
	uint8_t                    not_supported;        /*   164     1 */
	uint8_t                    scsi_dev_type;        /*   165     1 */
	uint8_t                    connected_port_bitmap; /*   166     1 */
	uint8_t                    device_speed;         /*   167     1 */
	uint32_t                   media_err_count;      /*   168     4 */
	uint32_t                   other_err_count;      /*   172     4 */
	uint32_t                   pred_fail_count;      /*   176     4 */
	uint32_t                   last_pred_fail_event_seq_num; /*   180     4 */
	uint16_t                   fw_state;             /*   184     2 */
	uint8_t                    disable_for_removal;  /*   186     1 */
	uint8_t                    link_speed;           /*   187     1 */
	union mfi_pd_ddf_type      state;                /*   188     4 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	struct {
		uint8_t            count;                /*   192     1 */
		uint8_t            is_path_broken;       /*   193     1 */
		uint8_t            reserved[6];          /*   194     6 */
		uint64_t           sas_addr[4];          /*   200    32 */
	} path_info;                                     /*   192    40 */
	uint64_t                   raw_size;             /*   232     8 */
	uint64_t                   non_coerced_size;     /*   240     8 */
	uint64_t                   coerced_size;         /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint16_t                   encl_device_id;       /*   256     2 */
	uint8_t                    encl_index;           /*   258     1 */
	uint8_t                    slot_number;          /*   259     1 */
	struct mfi_pd_progress     prog_info;            /*   260    32 */
	uint8_t                    bad_block_table_full; /*   292     1 */
	uint8_t                    unusable_in_current_config; /*   293     1 */
	uint8_t                    vpd_page83_ext[64];   /*   294    64 */
	/* --- cacheline 5 boundary (320 bytes) was 38 bytes ago --- */
	uint8_t                    reserved[154];        /*   358   154 */

	/* size: 512, cachelines: 8, members: 27 */
};
struct mfi_pd_address {
	uint16_t                   device_id;            /*     0     2 */
	uint16_t                   encl_device_id;       /*     2     2 */
	uint8_t                    encl_index;           /*     4     1 */
	uint8_t                    slot_number;          /*     5     1 */
	uint8_t                    scsi_dev_type;        /*     6     1 */
	uint8_t                    connect_port_bitmap;  /*     7     1 */
	uint64_t                   sas_addr[2];          /*     8    16 */

	/* size: 24, cachelines: 1, members: 7 */
	/* last cacheline: 24 bytes */
};
struct mfi_pd_list {
	uint32_t                   size;                 /*     0     4 */
	uint32_t                   count;                /*     4     4 */
	struct mfi_pd_address      addr[240];            /*     8  5760 */

	/* size: 5768, cachelines: 91, members: 3 */
	/* last cacheline: 8 bytes */
};
union mfi_ld_ref {
	struct {
		uint8_t            target_id;          /*     0     1 */
		uint8_t            reserved;           /*     1     1 */
		uint16_t           seq;                /*     2     2 */
	} v;                                           /*     0     4 */
	uint32_t                   ref;                /*     0     4 */
};
struct mfi_ld_list {
	uint32_t                   ld_count;             /*     0     4 */
	uint32_t                   reserved1;            /*     4     4 */
	struct {
		union mfi_ld_ref   ld;                   /*     8     4 */
		uint8_t            state;                /*    12     1 */
		uint8_t            reserved2[3];         /*    13     3 */
		uint64_t           size;                 /*    16     8 */
	} ld_list[64]; /*     8  1024 */

	/* size: 1032, cachelines: 17, members: 3 */
	/* last cacheline: 8 bytes */
};
struct mfi_ld_targetid_list {
	uint32_t                   size;                 /*     0     4 */
	uint32_t                   ld_count;             /*     4     4 */
	uint8_t                    pad[3];               /*     8     3 */
	uint8_t                    targetid[64];         /*    11    64 */

	/* size: 75, cachelines: 2, members: 4 */
	/* last cacheline: 11 bytes */
} __attribute__((__packed__));
struct mfi_ld_props {
	union mfi_ld_ref           ld;                   /*     0     4 */
	char                       name[16];             /*     4    16 */
	uint8_t                    default_cache_policy; /*    20     1 */
	uint8_t                    access_policy;        /*    21     1 */
	uint8_t                    disk_cache_policy;    /*    22     1 */
	uint8_t                    current_cache_policy; /*    23     1 */
	uint8_t                    no_bgi;               /*    24     1 */
	uint8_t                    reserved[7];          /*    25     7 */

	/* size: 32, cachelines: 1, members: 8 */
	/* last cacheline: 32 bytes */
};
struct mfi_ld_params {
	uint8_t                    primary_raid_level;   /*     0     1 */
	uint8_t                    raid_level_qualifier; /*     1     1 */
	uint8_t                    secondary_raid_level; /*     2     1 */
	uint8_t                    stripe_size;          /*     3     1 */
	uint8_t                    num_drives;           /*     4     1 */
	uint8_t                    span_depth;           /*     5     1 */
	uint8_t                    state;                /*     6     1 */
	uint8_t                    init_state;           /*     7     1 */
	uint8_t                    is_consistent;        /*     8     1 */
	uint8_t                    reserved[23];         /*     9    23 */

	/* size: 32, cachelines: 1, members: 10 */
	/* last cacheline: 32 bytes */
};
struct mfi_ld_progress {
	uint32_t                   active;               /*     0     4 */
	struct mfi_progress        cc;                   /*     4     4 */
	struct mfi_progress        bgi;                  /*     8     4 */
	struct mfi_progress        fgi;                  /*    12     4 */
	struct mfi_progress        recon;                /*    16     4 */
	struct mfi_progress        reserved[4];          /*    20    16 */

	/* size: 36, cachelines: 1, members: 6 */
	/* last cacheline: 36 bytes */
};
struct mfi_span {
	uint64_t                   start_block;          /*     0     8 */
	uint64_t                   num_blocks;           /*     8     8 */
	uint16_t                   array_ref;            /*    16     2 */
	uint8_t                    reserved[6];          /*    18     6 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct mfi_ld_config {
	struct mfi_ld_props        properties;           /*     0    32 */
	struct mfi_ld_params       params;               /*    32    32 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	struct mfi_span            span[8];              /*    64   192 */

	/* size: 256, cachelines: 4, members: 3 */
};
struct mfi_ld_info {
	struct mfi_ld_config       ld_config;            /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint64_t                   size;                 /*   256     8 */
	struct mfi_ld_progress     progress;             /*   264    36 */
	uint16_t                   cluster_owner;        /*   300     2 */
	uint8_t                    reconstruct_active;   /*   302     1 */
	uint8_t                    reserved1[1];         /*   303     1 */
	uint8_t                    vpd_page83[64];       /*   304    64 */
	/* --- cacheline 5 boundary (320 bytes) was 48 bytes ago --- */
	uint8_t                    reserved2[16];        /*   368    16 */

	/* size: 384, cachelines: 6, members: 8 */
};
struct mfi_array {
	uint64_t                   size;                 /*     0     8 */
	uint8_t                    num_drives;           /*     8     1 */
	uint8_t                    reserved;             /*     9     1 */
	uint16_t                   array_ref;            /*    10     2 */
	uint8_t                    pad[20];              /*    12    20 */
	struct {
		union mfi_pd_ref   ref;                  /*    32     4 */
		uint16_t           fw_state;             /*    36     2 */
		struct {
			uint8_t    pd;                   /*    38     1 */
			uint8_t    slot;                 /*    39     1 */
		} encl;                                  /*    38     2 */
	} pd[32]; /*    32   256 */

	/* size: 288, cachelines: 5, members: 6 */
	/* last cacheline: 32 bytes */
};
struct mfi_config_data {
	uint32_t                   size;                 /*     0     4 */
	uint16_t                   array_count;          /*     4     2 */
	uint16_t                   array_size;           /*     6     2 */
	uint16_t                   log_drv_count;        /*     8     2 */
	uint16_t                   log_drv_size;         /*    10     2 */
	uint16_t                   spares_count;         /*    12     2 */
	uint16_t                   spares_size;          /*    14     2 */
	uint8_t                    reserved[16];         /*    16    16 */

	/* size: 32, cachelines: 1, members: 8 */
	/* last cacheline: 32 bytes */
};
struct MegasasCmd {
	uint32_t                   index;                /*     0     4 */
	uint16_t                   flags;                /*     4     2 */
	uint16_t                   count;                /*     6     2 */
	uint64_t                   context;              /*     8     8 */
	hwaddr                     pa;                   /*    16     8 */
	hwaddr                     pa_size;              /*    24     8 */
	union mfi_frame *          frame;                /*    32     8 */
	SCSIRequest *              req;                  /*    40     8 */
	QEMUSGList                 qsg;                  /*    48    40 */
	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	void *                     iov_buf;              /*    88     8 */
	size_t                     iov_size;             /*    96     8 */
	size_t                     iov_offset;           /*   104     8 */
	struct MegasasState *      state;                /*   112     8 */

	/* size: 120, cachelines: 2, members: 13 */
	/* last cacheline: 56 bytes */
};
struct MegasasState {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	MemoryRegion               mmio_io;              /*  2288   256 */
	/* --- cacheline 39 boundary (2496 bytes) was 48 bytes ago --- */
	MemoryRegion               port_io;              /*  2544   256 */
	/* --- cacheline 43 boundary (2752 bytes) was 48 bytes ago --- */
	MemoryRegion               queue_io;             /*  2800   256 */
	/* --- cacheline 47 boundary (3008 bytes) was 48 bytes ago --- */
	uint32_t                   frame_hi;             /*  3056     4 */
	int                        fw_state;             /*  3060     4 */
	uint32_t                   fw_sge;               /*  3064     4 */
	uint32_t                   fw_cmds;              /*  3068     4 */
	/* --- cacheline 48 boundary (3072 bytes) --- */
	uint32_t                   flags;                /*  3072     4 */
	int                        fw_luns;              /*  3076     4 */
	int                        intr_mask;            /*  3080     4 */
	int                        doorbell;             /*  3084     4 */
	int                        busy;                 /*  3088     4 */
	int                        diag;                 /*  3092     4 */
	int                        adp_reset;            /*  3096     4 */
	OnOffAuto                  msi;                  /*  3100     4 */
	OnOffAuto                  msix;                 /*  3104     4 */

	/* XXX 4 bytes hole, try to pack */

	MegasasCmd *               event_cmd;            /*  3112     8 */
	int                        event_locale;         /*  3120     4 */
	int                        event_class;          /*  3124     4 */
	int                        event_count;          /*  3128     4 */
	int                        shutdown_event;       /*  3132     4 */
	/* --- cacheline 49 boundary (3136 bytes) --- */
	int                        boot_event;           /*  3136     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   sas_addr;             /*  3144     8 */
	char *                     hba_serial;           /*  3152     8 */
	uint64_t                   reply_queue_pa;       /*  3160     8 */
	void *                     reply_queue;          /*  3168     8 */
	int                        reply_queue_len;      /*  3176     4 */
	int                        reply_queue_head;     /*  3180     4 */
	int                        reply_queue_tail;     /*  3184     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   consumer_pa;          /*  3192     8 */
	/* --- cacheline 50 boundary (3200 bytes) --- */
	uint64_t                   producer_pa;          /*  3200     8 */
	MegasasCmd                 frames[2048];         /*  3208 245760 */
	/* --- cacheline 3890 boundary (248960 bytes) was 8 bytes ago --- */
	long unsigned int          frame_map[32];        /* 248968   256 */
	/* --- cacheline 3894 boundary (249216 bytes) was 8 bytes ago --- */
	SCSIBus                    bus;                  /* 249224   120 */

	/* size: 249344, cachelines: 3896, members: 35 */
	/* sum members: 249332, holes: 3, sum holes: 12 */
};
struct MegasasBaseClass {
	PCIDeviceClass             parent_class;         /*     0   264 */
	/* --- cacheline 4 boundary (256 bytes) was 8 bytes ago --- */
	const char  *              product_name;         /*   264     8 */
	const char  *              product_version;      /*   272     8 */
	int                        mmio_bar;             /*   280     4 */
	int                        ioport_bar;           /*   284     4 */
	int                        osts;                 /*   288     4 */

	/* size: 296, cachelines: 5, members: 6 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct dcmd_cmd_tbl_t {
	int                        opcode;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              desc;                 /*     8     8 */
	int                        (*func)(MegasasState *, MegasasCmd *); /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct MegasasInfo {
	const char  *              name;                 /*     0     8 */
	const char  *              desc;                 /*     8     8 */
	const char  *              product_name;         /*    16     8 */
	const char  *              product_version;      /*    24     8 */
	uint16_t                   device_id;            /*    32     2 */
	uint16_t                   subsystem_id;         /*    34     2 */
	int                        ioport_bar;           /*    36     4 */
	int                        mmio_bar;             /*    40     4 */
	_Bool                      is_express;           /*    44     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        osts;                 /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	const VMStateDescription  * vmsd;                /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	Property *                 props;                /*    64     8 */

	/* size: 72, cachelines: 2, members: 12 */
	/* sum members: 65, holes: 2, sum holes: 7 */
	/* last cacheline: 8 bytes */
};
struct PVSCSICmdDescResetDevice {
	uint32_t                   target;               /*     0     4 */
	uint8_t                    lun[8];               /*     4     8 */

	/* size: 12, cachelines: 1, members: 2 */
	/* last cacheline: 12 bytes */
};
struct PVSCSICmdDescAbortCmd {
	uint64_t                   context;              /*     0     8 */
	uint32_t                   target;               /*     8     4 */
	uint32_t                   pad;                  /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct PVSCSICmdDescSetupRings {
	uint32_t                   reqRingNumPages;      /*     0     4 */
	uint32_t                   cmpRingNumPages;      /*     4     4 */
	uint64_t                   ringsStatePPN;        /*     8     8 */
	uint64_t                   reqRingPPNs[32];      /*    16   256 */
	/* --- cacheline 4 boundary (256 bytes) was 16 bytes ago --- */
	uint64_t                   cmpRingPPNs[32];      /*   272   256 */

	/* size: 528, cachelines: 9, members: 5 */
	/* last cacheline: 16 bytes */
};
struct PVSCSICmdDescSetupMsgRing {
	uint32_t                   numPages;             /*     0     4 */
	uint32_t                   pad;                  /*     4     4 */
	uint64_t                   ringPPNs[16];         /*     8   128 */

	/* size: 136, cachelines: 3, members: 3 */
	/* last cacheline: 8 bytes */
};
struct PVSCSIRingMsgDesc {
	uint32_t                   type;                 /*     0     4 */
	uint32_t                   args[31];             /*     4   124 */

	/* size: 128, cachelines: 2, members: 2 */
};
struct PVSCSIMsgDescDevStatusChanged {
	uint32_t                   type;                 /*     0     4 */
	uint32_t                   bus;                  /*     4     4 */
	uint32_t                   target;               /*     8     4 */
	uint8_t                    lun[8];               /*    12     8 */
	uint32_t                   pad[27];              /*    20   108 */

	/* size: 128, cachelines: 2, members: 5 */
};
struct PVSCSIRingReqDesc {
	uint64_t                   context;              /*     0     8 */
	uint64_t                   dataAddr;             /*     8     8 */
	uint64_t                   dataLen;              /*    16     8 */
	uint64_t                   senseAddr;            /*    24     8 */
	uint32_t                   senseLen;             /*    32     4 */
	uint32_t                   flags;                /*    36     4 */
	uint8_t                    cdb[16];              /*    40    16 */
	uint8_t                    cdbLen;               /*    56     1 */
	uint8_t                    lun[8];               /*    57     8 */
	/* --- cacheline 1 boundary (64 bytes) was 1 bytes ago --- */
	uint8_t                    tag;                  /*    65     1 */
	uint8_t                    bus;                  /*    66     1 */
	uint8_t                    target;               /*    67     1 */
	uint8_t                    vcpuHint;             /*    68     1 */
	uint8_t                    unused[59];           /*    69    59 */

	/* size: 128, cachelines: 2, members: 14 */
};
struct PVSCSISGElement {
	uint64_t                   addr;                 /*     0     8 */
	uint32_t                   length;               /*     8     4 */
	uint32_t                   flags;                /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct PVSCSIRingCmpDesc {
	uint64_t                   context;              /*     0     8 */
	uint64_t                   dataLen;              /*     8     8 */
	uint32_t                   senseLen;             /*    16     4 */
	uint16_t                   hostStatus;           /*    20     2 */
	uint16_t                   scsiStatus;           /*    22     2 */
	uint32_t                   pad[2];               /*    24     8 */

	/* size: 32, cachelines: 1, members: 6 */
	/* last cacheline: 32 bytes */
};
struct PVSCSIClass {
	PCIDeviceClass             parent_class;         /*     0   264 */
	/* --- cacheline 4 boundary (256 bytes) was 8 bytes ago --- */
	DeviceRealize              parent_dc_realize;    /*   264     8 */

	/* size: 272, cachelines: 5, members: 2 */
	/* last cacheline: 16 bytes */
};
struct PVSCSIRingInfo {
	uint64_t                   rs_pa;                /*     0     8 */
	uint32_t                   txr_len_mask;         /*     8     4 */
	uint32_t                   rxr_len_mask;         /*    12     4 */
	uint32_t                   msg_len_mask;         /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   req_ring_pages_pa[32]; /*    24   256 */
	/* --- cacheline 4 boundary (256 bytes) was 24 bytes ago --- */
	uint64_t                   cmp_ring_pages_pa[32]; /*   280   256 */
	/* --- cacheline 8 boundary (512 bytes) was 24 bytes ago --- */
	uint64_t                   msg_ring_pages_pa[16]; /*   536   128 */
	/* --- cacheline 10 boundary (640 bytes) was 24 bytes ago --- */
	uint64_t                   consumed_ptr;         /*   664     8 */
	uint64_t                   filled_cmp_ptr;       /*   672     8 */
	uint64_t                   filled_msg_ptr;       /*   680     8 */

	/* size: 688, cachelines: 11, members: 10 */
	/* sum members: 684, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct PVSCSISGState {
	hwaddr                     elemAddr;             /*     0     8 */
	hwaddr                     dataAddr;             /*     8     8 */
	uint32_t                   resid;                /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct PVSCSIRequest {
	SCSIRequest *              sreq;                 /*     0     8 */
	PVSCSIState *              dev;                  /*     8     8 */
	uint8_t                    sense_key;            /*    16     1 */
	uint8_t                    completed;            /*    17     1 */

	/* XXX 2 bytes hole, try to pack */

	int                        lun;                  /*    20     4 */
	QEMUSGList                 sgl;                  /*    24    40 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	PVSCSISGState              sg;                   /*    64    24 */
	struct PVSCSIRingReqDesc   req;                  /*    88   128 */
	/* --- cacheline 3 boundary (192 bytes) was 24 bytes ago --- */
	struct PVSCSIRingCmpDesc   cmp;                  /*   216    32 */
	struct {
		struct PVSCSIRequest * tqe_next;         /*   248     8 */
		/* --- cacheline 4 boundary (256 bytes) --- */
		struct PVSCSIRequest * * tqe_prev;       /*   256     8 */
	} next;                                          /*   248    16 */

	/* size: 264, cachelines: 5, members: 10 */
	/* sum members: 262, holes: 1, sum holes: 2 */
	/* last cacheline: 8 bytes */
};
struct ESPState {
	uint8_t                    rregs[16];            /*     0    16 */
	uint8_t                    wregs[16];            /*    16    16 */
	qemu_irq                   irq;                  /*    32     8 */
	uint8_t                    chip_id;              /*    40     1 */
	_Bool                      tchi_written;         /*    41     1 */

	/* XXX 2 bytes hole, try to pack */

	int32_t                    ti_size;              /*    44     4 */
	uint32_t                   ti_rptr;              /*    48     4 */
	uint32_t                   ti_wptr;              /*    52     4 */
	uint32_t                   status;               /*    56     4 */
	uint32_t                   dma;                  /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint8_t                    ti_buf[16];           /*    64    16 */
	SCSIBus                    bus;                  /*    80   120 */
	/* --- cacheline 3 boundary (192 bytes) was 8 bytes ago --- */
	SCSIDevice *               current_dev;          /*   200     8 */
	SCSIRequest *              current_req;          /*   208     8 */
	uint8_t                    cmdbuf[32];           /*   216    32 */
	uint32_t                   cmdlen;               /*   248     4 */
	uint32_t                   do_cmd;               /*   252     4 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint32_t                   dma_left;             /*   256     4 */
	uint32_t                   dma_counter;          /*   260     4 */
	int                        dma_enabled;          /*   264     4 */
	uint32_t                   async_len;            /*   268     4 */
	uint8_t *                  async_buf;            /*   272     8 */
	ESPDMAMemoryReadWriteFunc  dma_memory_read;      /*   280     8 */
	ESPDMAMemoryReadWriteFunc  dma_memory_write;     /*   288     8 */
	void *                     dma_opaque;           /*   296     8 */
	void                       (*dma_cb)(ESPState *); /*   304     8 */

	/* size: 312, cachelines: 5, members: 26 */
	/* sum members: 310, holes: 1, sum holes: 2 */
	/* last cacheline: 56 bytes */
};
struct PCIESPState {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	MemoryRegion               io;                   /*  2288   256 */
	/* --- cacheline 39 boundary (2496 bytes) was 48 bytes ago --- */
	uint32_t                   dma_regs[8];          /*  2544    32 */
	/* --- cacheline 40 boundary (2560 bytes) was 16 bytes ago --- */
	uint32_t                   sbac;                 /*  2576     4 */

	/* XXX 4 bytes hole, try to pack */

	ESPState                   esp;                  /*  2584   312 */

	/* size: 2896, cachelines: 46, members: 5 */
	/* sum members: 2892, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct SDState {
	DeviceState                parent_obj;           /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	uint32_t                   mode;                 /*   112     4 */
	int32_t                    state;                /*   116     4 */
	uint32_t                   ocr;                  /*   120     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 2 boundary (128 bytes) --- */
	QEMUTimer *                ocr_power_timer;      /*   128     8 */
	uint8_t                    scr[8];               /*   136     8 */
	uint8_t                    cid[16];              /*   144    16 */
	uint8_t                    csd[16];              /*   160    16 */
	uint16_t                   rca;                  /*   176     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   card_status;          /*   180     4 */
	uint8_t                    sd_status[64];        /*   184    64 */
	/* --- cacheline 3 boundary (192 bytes) was 56 bytes ago --- */
	uint32_t                   vhs;                  /*   248     4 */
	_Bool                      wp_switch;            /*   252     1 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 4 boundary (256 bytes) --- */
	long unsigned int *        wp_groups;            /*   256     8 */
	int32_t                    wpgrps_size;          /*   264     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   size;                 /*   272     8 */
	uint32_t                   blk_len;              /*   280     4 */
	uint32_t                   multi_blk_cnt;        /*   284     4 */
	uint32_t                   erase_start;          /*   288     4 */
	uint32_t                   erase_end;            /*   292     4 */
	uint8_t                    pwd[16];              /*   296    16 */
	uint32_t                   pwd_len;              /*   312     4 */
	uint8_t                    function_group[6];    /*   316     6 */
	/* --- cacheline 5 boundary (320 bytes) was 2 bytes ago --- */
	_Bool                      spi;                  /*   322     1 */
	uint8_t                    current_cmd;          /*   323     1 */
	_Bool                      expecting_acmd;       /*   324     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   blk_written;          /*   328     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   data_start;           /*   336     8 */
	uint32_t                   data_offset;          /*   344     4 */
	uint8_t                    data[512];            /*   348   512 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 13 boundary (832 bytes) was 32 bytes ago --- */
	qemu_irq                   readonly_cb;          /*   864     8 */
	qemu_irq                   inserted_cb;          /*   872     8 */
	BlockBackend *             blk;                  /*   880     8 */
	_Bool                      enable;               /*   888     1 */

	/* size: 896, cachelines: 14, members: 34 */
	/* sum members: 865, holes: 7, sum holes: 24 */
	/* padding: 7 */
};
struct SDBus {
	BusState                   qbus;                 /*     0   104 */

	/* size: 104, cachelines: 2, members: 1 */
	/* last cacheline: 40 bytes */
};
struct SDHCIState {
	union {
		PCIDevice          pcidev;               /*     0  2288 */
		SysBusDevice       busdev;               /*     0   768 */
	};                                               /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	SDBus                      sdbus;                /*  2288   104 */

	/* XXX 8 bytes hole, try to pack */

	/* --- cacheline 37 boundary (2368 bytes) was 32 bytes ago --- */
	MemoryRegion               iomem;                /*  2400   256 */
	/* --- cacheline 41 boundary (2624 bytes) was 32 bytes ago --- */
	QEMUTimer *                insert_timer;         /*  2656     8 */
	QEMUTimer *                transfer_timer;       /*  2664     8 */
	qemu_irq                   eject_cb;             /*  2672     8 */
	qemu_irq                   ro_cb;                /*  2680     8 */
	/* --- cacheline 42 boundary (2688 bytes) --- */
	qemu_irq                   irq;                  /*  2688     8 */
	uint32_t                   sdmasysad;            /*  2696     4 */
	uint16_t                   blksize;              /*  2700     2 */
	uint16_t                   blkcnt;               /*  2702     2 */
	uint32_t                   argument;             /*  2704     4 */
	uint16_t                   trnmod;               /*  2708     2 */
	uint16_t                   cmdreg;               /*  2710     2 */
	uint32_t                   rspreg[4];            /*  2712    16 */
	uint32_t                   prnsts;               /*  2728     4 */
	uint8_t                    hostctl;              /*  2732     1 */
	uint8_t                    pwrcon;               /*  2733     1 */
	uint8_t                    blkgap;               /*  2734     1 */
	uint8_t                    wakcon;               /*  2735     1 */
	uint16_t                   clkcon;               /*  2736     2 */
	uint8_t                    timeoutcon;           /*  2738     1 */
	uint8_t                    admaerr;              /*  2739     1 */
	uint16_t                   norintsts;            /*  2740     2 */
	uint16_t                   errintsts;            /*  2742     2 */
	uint16_t                   norintstsen;          /*  2744     2 */
	uint16_t                   errintstsen;          /*  2746     2 */
	uint16_t                   norintsigen;          /*  2748     2 */
	uint16_t                   errintsigen;          /*  2750     2 */
	/* --- cacheline 43 boundary (2752 bytes) --- */
	uint16_t                   acmd12errsts;         /*  2752     2 */

	/* XXX 6 bytes hole, try to pack */

	uint64_t                   admasysaddr;          /*  2760     8 */
	uint32_t                   capareg;              /*  2768     4 */
	uint32_t                   maxcurr;              /*  2772     4 */
	uint8_t *                  fifo_buffer;          /*  2776     8 */
	uint32_t                   buf_maxsz;            /*  2784     4 */
	uint16_t                   data_count;           /*  2788     2 */
	uint8_t                    stopped_state;        /*  2790     1 */
	_Bool                      pending_insert_quirk; /*  2791     1 */
	_Bool                      pending_insert_state; /*  2792     1 */

	/* size: 2800, cachelines: 44, members: 39 */
	/* sum members: 2779, holes: 2, sum holes: 14 */
	/* padding: 7 */
	/* last cacheline: 48 bytes */
};
struct ADMADescr {
	hwaddr                     addr;                 /*     0     8 */
	uint16_t                   length;               /*     8     2 */
	uint8_t                    attr;                 /*    10     1 */
	uint8_t                    incr;                 /*    11     1 */

	/* size: 16, cachelines: 1, members: 4 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct smbios_21_entry_point {
	uint8_t                    anchor_string[4];     /*     0     4 */
	uint8_t                    checksum;             /*     4     1 */
	uint8_t                    length;               /*     5     1 */
	uint8_t                    smbios_major_version; /*     6     1 */
	uint8_t                    smbios_minor_version; /*     7     1 */
	uint16_t                   max_structure_size;   /*     8     2 */
	uint8_t                    entry_point_revision; /*    10     1 */
	uint8_t                    formatted_area[5];    /*    11     5 */
	uint8_t                    intermediate_anchor_string[5]; /*    16     5 */
	uint8_t                    intermediate_checksum; /*    21     1 */
	uint16_t                   structure_table_length; /*    22     2 */
	uint32_t                   structure_table_address; /*    24     4 */
	uint16_t                   number_of_structures; /*    28     2 */
	uint8_t                    smbios_bcd_revision;  /*    30     1 */

	/* size: 31, cachelines: 1, members: 14 */
	/* last cacheline: 31 bytes */
} __attribute__((__packed__));
struct smbios_30_entry_point {
	uint8_t                    anchor_string[5];     /*     0     5 */
	uint8_t                    checksum;             /*     5     1 */
	uint8_t                    length;               /*     6     1 */
	uint8_t                    smbios_major_version; /*     7     1 */
	uint8_t                    smbios_minor_version; /*     8     1 */
	uint8_t                    smbios_doc_rev;       /*     9     1 */
	uint8_t                    entry_point_revision; /*    10     1 */
	uint8_t                    reserved;             /*    11     1 */
	uint32_t                   structure_table_max_size; /*    12     4 */
	uint64_t                   structure_table_address; /*    16     8 */

	/* size: 24, cachelines: 1, members: 10 */
	/* last cacheline: 24 bytes */
};
struct smbios_structure_header {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    length;               /*     1     1 */
	uint16_t                   handle;               /*     2     2 */

	/* size: 4, cachelines: 1, members: 3 */
	/* last cacheline: 4 bytes */
};
struct smbios_type_0 {
	struct smbios_structure_header header;           /*     0     4 */
	uint8_t                    vendor_str;           /*     4     1 */
	uint8_t                    bios_version_str;     /*     5     1 */
	uint16_t                   bios_starting_address_segment; /*     6     2 */
	uint8_t                    bios_release_date_str; /*     8     1 */
	uint8_t                    bios_rom_size;        /*     9     1 */
	uint64_t                   bios_characteristics; /*    10     8 */
	uint8_t                    bios_characteristics_extension_bytes[2]; /*    18     2 */
	uint8_t                    system_bios_major_release; /*    20     1 */
	uint8_t                    system_bios_minor_release; /*    21     1 */
	uint8_t                    embedded_controller_major_release; /*    22     1 */
	uint8_t                    embedded_controller_minor_release; /*    23     1 */

	/* size: 24, cachelines: 1, members: 12 */
	/* last cacheline: 24 bytes */
} __attribute__((__packed__));
struct smbios_uuid {
	uint32_t                   time_low;             /*     0     4 */
	uint16_t                   time_mid;             /*     4     2 */
	uint16_t                   time_hi_and_version;  /*     6     2 */
	uint8_t                    clock_seq_hi_and_reserved; /*     8     1 */
	uint8_t                    clock_seq_low;        /*     9     1 */
	uint8_t                    node[6];              /*    10     6 */

	/* size: 16, cachelines: 1, members: 6 */
	/* last cacheline: 16 bytes */
};
struct smbios_type_1 {
	struct smbios_structure_header header;           /*     0     4 */
	uint8_t                    manufacturer_str;     /*     4     1 */
	uint8_t                    product_name_str;     /*     5     1 */
	uint8_t                    version_str;          /*     6     1 */
	uint8_t                    serial_number_str;    /*     7     1 */
	struct smbios_uuid         uuid;                 /*     8    16 */
	uint8_t                    wake_up_type;         /*    24     1 */
	uint8_t                    sku_number_str;       /*    25     1 */
	uint8_t                    family_str;           /*    26     1 */

	/* size: 27, cachelines: 1, members: 9 */
	/* last cacheline: 27 bytes */
} __attribute__((__packed__));
struct smbios_type_2 {
	struct smbios_structure_header header;           /*     0     4 */
	uint8_t                    manufacturer_str;     /*     4     1 */
	uint8_t                    product_str;          /*     5     1 */
	uint8_t                    version_str;          /*     6     1 */
	uint8_t                    serial_number_str;    /*     7     1 */
	uint8_t                    asset_tag_number_str; /*     8     1 */
	uint8_t                    feature_flags;        /*     9     1 */
	uint8_t                    location_str;         /*    10     1 */
	uint16_t                   chassis_handle;       /*    11     2 */
	uint8_t                    board_type;           /*    13     1 */
	uint8_t                    contained_element_count; /*    14     1 */

	/* size: 15, cachelines: 1, members: 11 */
	/* last cacheline: 15 bytes */
} __attribute__((__packed__));
struct smbios_type_3 {
	struct smbios_structure_header header;           /*     0     4 */
	uint8_t                    manufacturer_str;     /*     4     1 */
	uint8_t                    type;                 /*     5     1 */
	uint8_t                    version_str;          /*     6     1 */
	uint8_t                    serial_number_str;    /*     7     1 */
	uint8_t                    asset_tag_number_str; /*     8     1 */
	uint8_t                    boot_up_state;        /*     9     1 */
	uint8_t                    power_supply_state;   /*    10     1 */
	uint8_t                    thermal_state;        /*    11     1 */
	uint8_t                    security_status;      /*    12     1 */
	uint32_t                   oem_defined;          /*    13     4 */
	uint8_t                    height;               /*    17     1 */
	uint8_t                    number_of_power_cords; /*    18     1 */
	uint8_t                    contained_element_count; /*    19     1 */
	uint8_t                    sku_number_str;       /*    20     1 */

	/* size: 21, cachelines: 1, members: 15 */
	/* last cacheline: 21 bytes */
} __attribute__((__packed__));
struct smbios_type_4 {
	struct smbios_structure_header header;           /*     0     4 */
	uint8_t                    socket_designation_str; /*     4     1 */
	uint8_t                    processor_type;       /*     5     1 */
	uint8_t                    processor_family;     /*     6     1 */
	uint8_t                    processor_manufacturer_str; /*     7     1 */
	uint32_t                   processor_id[2];      /*     8     8 */
	uint8_t                    processor_version_str; /*    16     1 */
	uint8_t                    voltage;              /*    17     1 */
	uint16_t                   external_clock;       /*    18     2 */
	uint16_t                   max_speed;            /*    20     2 */
	uint16_t                   current_speed;        /*    22     2 */
	uint8_t                    status;               /*    24     1 */
	uint8_t                    processor_upgrade;    /*    25     1 */
	uint16_t                   l1_cache_handle;      /*    26     2 */
	uint16_t                   l2_cache_handle;      /*    28     2 */
	uint16_t                   l3_cache_handle;      /*    30     2 */
	uint8_t                    serial_number_str;    /*    32     1 */
	uint8_t                    asset_tag_number_str; /*    33     1 */
	uint8_t                    part_number_str;      /*    34     1 */
	uint8_t                    core_count;           /*    35     1 */
	uint8_t                    core_enabled;         /*    36     1 */
	uint8_t                    thread_count;         /*    37     1 */
	uint16_t                   processor_characteristics; /*    38     2 */
	uint16_t                   processor_family2;    /*    40     2 */

	/* size: 42, cachelines: 1, members: 24 */
	/* last cacheline: 42 bytes */
} __attribute__((__packed__));
struct smbios_type_16 {
	struct smbios_structure_header header;           /*     0     4 */
	uint8_t                    location;             /*     4     1 */
	uint8_t                    use;                  /*     5     1 */
	uint8_t                    error_correction;     /*     6     1 */
	uint32_t                   maximum_capacity;     /*     7     4 */
	uint16_t                   memory_error_information_handle; /*    11     2 */
	uint16_t                   number_of_memory_devices; /*    13     2 */
	uint64_t                   extended_maximum_capacity; /*    15     8 */

	/* size: 23, cachelines: 1, members: 8 */
	/* last cacheline: 23 bytes */
} __attribute__((__packed__));
struct smbios_type_17 {
	struct smbios_structure_header header;           /*     0     4 */
	uint16_t                   physical_memory_array_handle; /*     4     2 */
	uint16_t                   memory_error_information_handle; /*     6     2 */
	uint16_t                   total_width;          /*     8     2 */
	uint16_t                   data_width;           /*    10     2 */
	uint16_t                   size;                 /*    12     2 */
	uint8_t                    form_factor;          /*    14     1 */
	uint8_t                    device_set;           /*    15     1 */
	uint8_t                    device_locator_str;   /*    16     1 */
	uint8_t                    bank_locator_str;     /*    17     1 */
	uint8_t                    memory_type;          /*    18     1 */
	uint16_t                   type_detail;          /*    19     2 */
	uint16_t                   speed;                /*    21     2 */
	uint8_t                    manufacturer_str;     /*    23     1 */
	uint8_t                    serial_number_str;    /*    24     1 */
	uint8_t                    asset_tag_number_str; /*    25     1 */
	uint8_t                    part_number_str;      /*    26     1 */
	uint8_t                    attributes;           /*    27     1 */
	uint32_t                   extended_size;        /*    28     4 */
	uint16_t                   configured_clock_speed; /*    32     2 */
	uint16_t                   minimum_voltage;      /*    34     2 */
	uint16_t                   maximum_voltage;      /*    36     2 */
	uint16_t                   configured_voltage;   /*    38     2 */

	/* size: 40, cachelines: 1, members: 23 */
	/* last cacheline: 40 bytes */
} __attribute__((__packed__));
struct smbios_type_19 {
	struct smbios_structure_header header;           /*     0     4 */
	uint32_t                   starting_address;     /*     4     4 */
	uint32_t                   ending_address;       /*     8     4 */
	uint16_t                   memory_array_handle;  /*    12     2 */
	uint8_t                    partition_width;      /*    14     1 */
	uint64_t                   extended_starting_address; /*    15     8 */
	uint64_t                   extended_ending_address; /*    23     8 */

	/* size: 31, cachelines: 1, members: 7 */
	/* last cacheline: 31 bytes */
} __attribute__((__packed__));
struct smbios_type_32 {
	struct smbios_structure_header header;           /*     0     4 */
	uint8_t                    reserved[6];          /*     4     6 */
	uint8_t                    boot_status;          /*    10     1 */

	/* size: 11, cachelines: 1, members: 3 */
	/* last cacheline: 11 bytes */
} __attribute__((__packed__));
struct smbios_type_127 {
	struct smbios_structure_header header;           /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct smbios_header {
	uint16_t                   length;               /*     0     2 */
	uint8_t                    type;                 /*     2     1 */

	/* size: 3, cachelines: 1, members: 2 */
	/* last cacheline: 3 bytes */
} __attribute__((__packed__));
struct smbios_field {
	struct smbios_header       header;               /*     0     3 */
	uint8_t                    type;                 /*     3     1 */
	uint16_t                   offset;               /*     4     2 */
	uint8_t                    data[];               /*     6     0 */

	/* size: 6, cachelines: 1, members: 4 */
	/* last cacheline: 6 bytes */
};
struct smbios_table {
	struct smbios_header       header;               /*     0     3 */
	uint8_t                    data[];               /*     3     0 */

	/* size: 3, cachelines: 1, members: 2 */
	/* last cacheline: 3 bytes */
} __attribute__((__packed__));
struct smbios_type_38 {
	struct smbios_structure_header header;           /*     0     4 */
	uint8_t                    interface_type;       /*     4     1 */
	uint8_t                    ipmi_spec_revision;   /*     5     1 */
	uint8_t                    i2c_slave_address;    /*     6     1 */
	uint8_t                    nv_storage_device_address; /*     7     1 */
	uint64_t                   base_address;         /*     8     8 */
	uint8_t                    base_address_modifier; /*    16     1 */
	uint8_t                    interrupt_number;     /*    17     1 */

	/* size: 18, cachelines: 1, members: 8 */
	/* last cacheline: 18 bytes */
} __attribute__((__packed__));
struct HPETTimer {
	uint8_t                    tn;                   /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	QEMUTimer *                qemu_timer;           /*     8     8 */
	struct HPETState *         state;                /*    16     8 */
	uint64_t                   config;               /*    24     8 */
	uint64_t                   cmp;                  /*    32     8 */
	uint64_t                   fsb;                  /*    40     8 */
	uint64_t                   period;               /*    48     8 */
	uint8_t                    wrap_flag;            /*    56     1 */

	/* size: 64, cachelines: 1, members: 8 */
	/* sum members: 50, holes: 1, sum holes: 7 */
	/* padding: 7 */
};
struct HPETState {
	SysBusDevice               parent_obj;           /*     0   768 */
	/* --- cacheline 12 boundary (768 bytes) --- */
	MemoryRegion               iomem;                /*   768   256 */
	/* --- cacheline 16 boundary (1024 bytes) --- */
	uint64_t                   hpet_offset;          /*  1024     8 */
	qemu_irq                   irqs[32];             /*  1032   256 */
	/* --- cacheline 20 boundary (1280 bytes) was 8 bytes ago --- */
	uint32_t                   flags;                /*  1288     4 */
	uint8_t                    rtc_irq_level;        /*  1292     1 */

	/* XXX 3 bytes hole, try to pack */

	qemu_irq                   pit_enabled;          /*  1296     8 */
	uint8_t                    num_timers;           /*  1304     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   intcap;               /*  1308     4 */
	HPETTimer                  timer[32];            /*  1312  2048 */
	/* --- cacheline 52 boundary (3328 bytes) was 32 bytes ago --- */
	uint64_t                   capability;           /*  3360     8 */
	uint64_t                   config;               /*  3368     8 */
	uint64_t                   isr;                  /*  3376     8 */
	uint64_t                   hpet_counter;         /*  3384     8 */
	/* --- cacheline 53 boundary (3392 bytes) --- */
	uint8_t                    hpet_id;              /*  3392     1 */

	/* Force padding: */
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;
	uint8_t                    :8;

	/* size: 3408, cachelines: 54, members: 15 */
	/* sum members: 3387, holes: 2, sum holes: 6 */
	/* padding: 15 */
	/* last cacheline: 16 bytes */
};
struct PITClass {
	PITCommonClass             parent_class;         /*     0   224 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	DeviceRealize              parent_realize;       /*   224     8 */

	/* size: 232, cachelines: 4, members: 2 */
	/* last cacheline: 40 bytes */
};
struct TPMState {
	ISADevice                  busdev;               /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	MemoryRegion               mmio;                 /*   128   256 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	union {
		TPMTISEmuState     tis;                  /*   384  4448 */
	} s;                                             /*   384  4448 */
	/* --- cacheline 75 boundary (4800 bytes) was 32 bytes ago --- */
	uint8_t                    locty_number;         /*  4832     1 */

	/* XXX 7 bytes hole, try to pack */

	TPMLocality *              locty_data;           /*  4840     8 */
	char *                     backend;              /*  4848     8 */
	TPMBackend *               be_driver;            /*  4856     8 */
	/* --- cacheline 76 boundary (4864 bytes) --- */
	TPMVersion                 be_tpm_version;       /*  4864     4 */

	/* Force padding: */
	TPMVersion                 :32;
	TPMVersion                 :32;
	TPMVersion                 :32;

	/* size: 4880, cachelines: 77, members: 8 */
	/* sum members: 4861, holes: 1, sum holes: 7 */
	/* padding: 12 */
	/* last cacheline: 16 bytes */
};
struct TPMLocality {
	TPMTISState                state;                /*     0     4 */
	uint8_t                    access;               /*     4     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   sts;                  /*     8     4 */
	uint32_t                   iface_id;             /*    12     4 */
	uint32_t                   inte;                 /*    16     4 */
	uint32_t                   ints;                 /*    20     4 */
	uint16_t                   w_offset;             /*    24     2 */
	uint16_t                   r_offset;             /*    26     2 */

	/* XXX 4 bytes hole, try to pack */

	TPMSizedBuffer             w_buffer;             /*    32    16 */
	TPMSizedBuffer             r_buffer;             /*    48    16 */

	/* size: 64, cachelines: 1, members: 10 */
	/* sum members: 57, holes: 2, sum holes: 7 */
};
struct TPMTISEmuState {
	QEMUBH *                   bh;                   /*     0     8 */
	uint32_t                   offset;               /*     8     4 */
	uint8_t                    buf[4096];            /*    12  4096 */
	/* --- cacheline 64 boundary (4096 bytes) was 12 bytes ago --- */
	uint8_t                    active_locty;         /*  4108     1 */
	uint8_t                    aborting_locty;       /*  4109     1 */
	uint8_t                    next_locty;           /*  4110     1 */

	/* XXX 1 byte hole, try to pack */

	TPMLocality                loc[5];               /*  4112   320 */
	/* --- cacheline 69 boundary (4416 bytes) was 16 bytes ago --- */
	qemu_irq                   irq;                  /*  4432     8 */
	uint32_t                   irq_num;              /*  4440     4 */

	/* size: 4448, cachelines: 70, members: 9 */
	/* sum members: 4443, holes: 1, sum holes: 1 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct tpm_req_hdr {
	uint16_t                   tag;                  /*     0     2 */
	uint32_t                   len;                  /*     2     4 */
	uint32_t                   ordinal;              /*     6     4 */

	/* size: 10, cachelines: 1, members: 3 */
	/* last cacheline: 10 bytes */
} __attribute__((__packed__));
struct tpm_resp_hdr {
	uint16_t                   tag;                  /*     0     2 */
	uint32_t                   len;                  /*     2     4 */
	uint32_t                   errcode;              /*     6     4 */

	/* size: 10, cachelines: 1, members: 3 */
	/* last cacheline: 10 bytes */
} __attribute__((__packed__));
struct TPMPassthruThreadParams {
	TPMState *                 tpm_state;            /*     0     8 */
	TPMRecvDataCB *            recv_data_callback;   /*     8     8 */
	TPMBackend *               tb;                   /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct TPMPassthruState {
	TPMBackend                 parent;               /*     0   104 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	TPMBackendThread           tbt;                  /*   104     8 */
	TPMPassthruThreadParams    tpm_thread_params;    /*   112    24 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	char *                     tpm_dev;              /*   136     8 */
	int                        tpm_fd;               /*   144     4 */
	_Bool                      tpm_executing;        /*   148     1 */
	_Bool                      tpm_op_canceled;      /*   149     1 */

	/* XXX 2 bytes hole, try to pack */

	int                        cancel_fd;            /*   152     4 */
	_Bool                      had_startup_error;    /*   156     1 */

	/* XXX 3 bytes hole, try to pack */

	TPMVersion                 tpm_version;          /*   160     4 */

	/* size: 168, cachelines: 3, members: 10 */
	/* sum members: 159, holes: 2, sum holes: 5 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct USBBus {
	BusState                   qbus;                 /*     0   104 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	USBBusOps *                ops;                  /*   104     8 */
	int                        busnr;                /*   112     4 */
	int                        nfree;                /*   116     4 */
	int                        nused;                /*   120     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 2 boundary (128 bytes) --- */
	struct {
		struct USBPort *   tqh_first;            /*   128     8 */
		struct USBPort * * tqh_last;             /*   136     8 */
	} free;                                          /*   128    16 */
	struct {
		struct USBPort *   tqh_first;            /*   144     8 */
		struct USBPort * * tqh_last;             /*   152     8 */
	} used;                                          /*   144    16 */
	struct {
		struct USBBus *    tqe_next;             /*   160     8 */
		struct USBBus * *  tqe_prev;             /*   168     8 */
	} next;                                          /*   160    16 */

	/* size: 176, cachelines: 3, members: 8 */
	/* sum members: 172, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct USBBusOps {
	void                       (*register_companion)(USBBus *, USBPort * *, uint32_t, uint32_t, Error * *); /*     0     8 */
	void                       (*wakeup_endpoint)(USBBus *, USBEndpoint *, unsigned int); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct USBDeviceClass {
	DeviceClass                parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	USBDeviceRealize           realize;              /*   192     8 */
	USBDeviceUnrealize         unrealize;            /*   200     8 */
	USBDevice *                (*find_device)(USBDevice *, uint8_t); /*   208     8 */
	void                       (*cancel_packet)(USBDevice *, USBPacket *); /*   216     8 */
	void                       (*handle_destroy)(USBDevice *); /*   224     8 */
	void                       (*handle_attach)(USBDevice *); /*   232     8 */
	void                       (*handle_reset)(USBDevice *); /*   240     8 */
	void                       (*handle_control)(USBDevice *, USBPacket *, int, int, int, int, uint8_t *); /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	void                       (*handle_data)(USBDevice *, USBPacket *); /*   256     8 */
	void                       (*set_interface)(USBDevice *, int, int, int); /*   264     8 */
	void                       (*flush_ep_queue)(USBDevice *, USBEndpoint *); /*   272     8 */
	void                       (*ep_stopped)(USBDevice *, USBEndpoint *); /*   280     8 */
	int                        (*alloc_streams)(USBDevice *, USBEndpoint * *, int, int); /*   288     8 */
	void                       (*free_streams)(USBDevice *, USBEndpoint * *, int); /*   296     8 */
	const char  *              product_desc;         /*   304     8 */
	const USBDesc  *           usb_desc;             /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	_Bool                      attached_settable;    /*   320     1 */

	/* size: 328, cachelines: 6, members: 18 */
	/* padding: 7 */
	/* last cacheline: 8 bytes */
};
struct LegacyUSBFactory {
	const char  *              name;                 /*     0     8 */
	const char  *              usbdevice_name;       /*     8     8 */
	USBDevice *                (*usbdevice_init)(USBBus *, const char  *); /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct USBDesc {
	USBDescID                  id;                   /*     0    10 */

	/* XXX 6 bytes hole, try to pack */

	const USBDescDevice  *     full;                 /*    16     8 */
	const USBDescDevice  *     high;                 /*    24     8 */
	const USBDescDevice  *     super;                /*    32     8 */
	const char  * const *      str;                  /*    40     8 */
	const USBDescMSOS  *       msos;                 /*    48     8 */

	/* size: 56, cachelines: 1, members: 6 */
	/* sum members: 50, holes: 1, sum holes: 6 */
	/* last cacheline: 56 bytes */
};
struct USBDescID {
	uint16_t                   idVendor;             /*     0     2 */
	uint16_t                   idProduct;            /*     2     2 */
	uint16_t                   bcdDevice;            /*     4     2 */
	uint8_t                    iManufacturer;        /*     6     1 */
	uint8_t                    iProduct;             /*     7     1 */
	uint8_t                    iSerialNumber;        /*     8     1 */

	/* size: 10, cachelines: 1, members: 6 */
	/* padding: 1 */
	/* last cacheline: 10 bytes */
};
struct USBDescDevice {
	uint16_t                   bcdUSB;               /*     0     2 */
	uint8_t                    bDeviceClass;         /*     2     1 */
	uint8_t                    bDeviceSubClass;      /*     3     1 */
	uint8_t                    bDeviceProtocol;      /*     4     1 */
	uint8_t                    bMaxPacketSize0;      /*     5     1 */
	uint8_t                    bNumConfigurations;   /*     6     1 */

	/* XXX 1 byte hole, try to pack */

	const USBDescConfig  *     confs;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 7 */
	/* sum members: 15, holes: 1, sum holes: 1 */
	/* last cacheline: 16 bytes */
};
struct USBDescConfig {
	uint8_t                    bNumInterfaces;       /*     0     1 */
	uint8_t                    bConfigurationValue;  /*     1     1 */
	uint8_t                    iConfiguration;       /*     2     1 */
	uint8_t                    bmAttributes;         /*     3     1 */
	uint8_t                    bMaxPower;            /*     4     1 */
	uint8_t                    nif_groups;           /*     5     1 */

	/* XXX 2 bytes hole, try to pack */

	const USBDescIfaceAssoc  * if_groups;            /*     8     8 */
	uint8_t                    nif;                  /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	const USBDescIface  *      ifs;                  /*    24     8 */

	/* size: 32, cachelines: 1, members: 9 */
	/* sum members: 23, holes: 2, sum holes: 9 */
	/* last cacheline: 32 bytes */
};
struct USBDescIfaceAssoc {
	uint8_t                    bFirstInterface;      /*     0     1 */
	uint8_t                    bInterfaceCount;      /*     1     1 */
	uint8_t                    bFunctionClass;       /*     2     1 */
	uint8_t                    bFunctionSubClass;    /*     3     1 */
	uint8_t                    bFunctionProtocol;    /*     4     1 */
	uint8_t                    iFunction;            /*     5     1 */
	uint8_t                    nif;                  /*     6     1 */

	/* XXX 1 byte hole, try to pack */

	const USBDescIface  *      ifs;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 8 */
	/* sum members: 15, holes: 1, sum holes: 1 */
	/* last cacheline: 16 bytes */
};
struct USBDescIface {
	uint8_t                    bInterfaceNumber;     /*     0     1 */
	uint8_t                    bAlternateSetting;    /*     1     1 */
	uint8_t                    bNumEndpoints;        /*     2     1 */
	uint8_t                    bInterfaceClass;      /*     3     1 */
	uint8_t                    bInterfaceSubClass;   /*     4     1 */
	uint8_t                    bInterfaceProtocol;   /*     5     1 */
	uint8_t                    iInterface;           /*     6     1 */
	uint8_t                    ndesc;                /*     7     1 */
	USBDescOther *             descs;                /*     8     8 */
	USBDescEndpoint *          eps;                  /*    16     8 */

	/* size: 24, cachelines: 1, members: 10 */
	/* last cacheline: 24 bytes */
};
struct USBDescEndpoint {
	uint8_t                    bEndpointAddress;     /*     0     1 */
	uint8_t                    bmAttributes;         /*     1     1 */
	uint16_t                   wMaxPacketSize;       /*     2     2 */
	uint8_t                    bInterval;            /*     4     1 */
	uint8_t                    bRefresh;             /*     5     1 */
	uint8_t                    bSynchAddress;        /*     6     1 */
	uint8_t                    is_audio;             /*     7     1 */
	uint8_t *                  extra;                /*     8     8 */
	uint8_t                    bMaxBurst;            /*    16     1 */
	uint8_t                    bmAttributes_super;   /*    17     1 */
	uint16_t                   wBytesPerInterval;    /*    18     2 */

	/* size: 24, cachelines: 1, members: 11 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct USBDescOther {
	uint8_t                    length;               /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	const uint8_t  *           data;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 9, holes: 1, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct USBDescMSOS {
	const char  *              CompatibleID;         /*     0     8 */
	const wchar_t  *           Label;                /*     8     8 */
	_Bool                      SelectiveSuspendEnabled; /*    16     1 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct USBDescriptor {
	uint8_t                    bLength;              /*     0     1 */
	uint8_t                    bDescriptorType;      /*     1     1 */
	union {
		struct {
			uint8_t    bcdUSB_lo;            /*     2     1 */
			uint8_t    bcdUSB_hi;            /*     3     1 */
			uint8_t    bDeviceClass;         /*     4     1 */
			uint8_t    bDeviceSubClass;      /*     5     1 */
			uint8_t    bDeviceProtocol;      /*     6     1 */
			uint8_t    bMaxPacketSize0;      /*     7     1 */
			uint8_t    idVendor_lo;          /*     8     1 */
			uint8_t    idVendor_hi;          /*     9     1 */
			uint8_t    idProduct_lo;         /*    10     1 */
			uint8_t    idProduct_hi;         /*    11     1 */
			uint8_t    bcdDevice_lo;         /*    12     1 */
			uint8_t    bcdDevice_hi;         /*    13     1 */
			uint8_t    iManufacturer;        /*    14     1 */
			uint8_t    iProduct;             /*    15     1 */
			uint8_t    iSerialNumber;        /*    16     1 */
			uint8_t    bNumConfigurations;   /*    17     1 */
		} device;                                /*     2    16 */
		struct {
			uint8_t    bcdUSB_lo;            /*     2     1 */
			uint8_t    bcdUSB_hi;            /*     3     1 */
			uint8_t    bDeviceClass;         /*     4     1 */
			uint8_t    bDeviceSubClass;      /*     5     1 */
			uint8_t    bDeviceProtocol;      /*     6     1 */
			uint8_t    bMaxPacketSize0;      /*     7     1 */
			uint8_t    bNumConfigurations;   /*     8     1 */
			uint8_t    bReserved;            /*     9     1 */
		} device_qualifier;                      /*     2     8 */
		struct {
			uint8_t    wTotalLength_lo;      /*     2     1 */
			uint8_t    wTotalLength_hi;      /*     3     1 */
			uint8_t    bNumInterfaces;       /*     4     1 */
			uint8_t    bConfigurationValue;  /*     5     1 */
			uint8_t    iConfiguration;       /*     6     1 */
			uint8_t    bmAttributes;         /*     7     1 */
			uint8_t    bMaxPower;            /*     8     1 */
		} config;                                /*     2     7 */
		struct {
			uint8_t    bInterfaceNumber;     /*     2     1 */
			uint8_t    bAlternateSetting;    /*     3     1 */
			uint8_t    bNumEndpoints;        /*     4     1 */
			uint8_t    bInterfaceClass;      /*     5     1 */
			uint8_t    bInterfaceSubClass;   /*     6     1 */
			uint8_t    bInterfaceProtocol;   /*     7     1 */
			uint8_t    iInterface;           /*     8     1 */
		} interface;                             /*     2     7 */
		struct {
			uint8_t    bEndpointAddress;     /*     2     1 */
			uint8_t    bmAttributes;         /*     3     1 */
			uint8_t    wMaxPacketSize_lo;    /*     4     1 */
			uint8_t    wMaxPacketSize_hi;    /*     5     1 */
			uint8_t    bInterval;            /*     6     1 */
			uint8_t    bRefresh;             /*     7     1 */
			uint8_t    bSynchAddress;        /*     8     1 */
		} endpoint;                              /*     2     7 */
		struct {
			uint8_t    bMaxBurst;            /*     2     1 */
			uint8_t    bmAttributes;         /*     3     1 */
			uint8_t    wBytesPerInterval_lo; /*     4     1 */
			uint8_t    wBytesPerInterval_hi; /*     5     1 */
		} super_endpoint;                        /*     2     4 */
		struct {
			uint8_t    wTotalLength_lo;      /*     2     1 */
			uint8_t    wTotalLength_hi;      /*     3     1 */
			uint8_t    bNumDeviceCaps;       /*     4     1 */
		} bos;                                   /*     2     3 */
		struct {
			uint8_t    bDevCapabilityType;   /*     2     1 */
			union {
				struct {
					uint8_t bmAttributes_1; /*     3     1 */
					uint8_t bmAttributes_2; /*     4     1 */
					uint8_t bmAttributes_3; /*     5     1 */
					uint8_t bmAttributes_4; /*     6     1 */
				} usb2_ext;              /*     3     4 */
				struct {
					uint8_t bmAttributes; /*     3     1 */
					uint8_t wSpeedsSupported_lo; /*     4     1 */
					uint8_t wSpeedsSupported_hi; /*     5     1 */
					uint8_t bFunctionalitySupport; /*     6     1 */
					uint8_t bU1DevExitLat; /*     7     1 */
					uint8_t wU2DevExitLat_lo; /*     8     1 */
					uint8_t wU2DevExitLat_hi; /*     9     1 */
				} super;                 /*     3     7 */
			} u;                             /*     3     7 */
		} cap;                                   /*     2     8 */
	} u;                                             /*     2    16 */

	/* size: 18, cachelines: 1, members: 3 */
	/* last cacheline: 18 bytes */
};
struct msos_compat_hdr {
	uint32_t                   dwLength;             /*     0     4 */
	uint8_t                    bcdVersion_lo;        /*     4     1 */
	uint8_t                    bcdVersion_hi;        /*     5     1 */
	uint8_t                    wIndex_lo;            /*     6     1 */
	uint8_t                    wIndex_hi;            /*     7     1 */
	uint8_t                    bCount;               /*     8     1 */
	uint8_t                    reserved[7];          /*     9     7 */

	/* size: 16, cachelines: 1, members: 7 */
	/* last cacheline: 16 bytes */
};
struct msos_compat_func {
	uint8_t                    bFirstInterfaceNumber; /*     0     1 */
	uint8_t                    reserved_1;           /*     1     1 */
	char                       compatibleId[8];      /*     2     8 */
	uint8_t                    subCompatibleId[8];   /*    10     8 */
	uint8_t                    reserved_2[6];        /*    18     6 */

	/* size: 24, cachelines: 1, members: 5 */
	/* last cacheline: 24 bytes */
};
struct msos_prop_hdr {
	uint32_t                   dwLength;             /*     0     4 */
	uint8_t                    bcdVersion_lo;        /*     4     1 */
	uint8_t                    bcdVersion_hi;        /*     5     1 */
	uint8_t                    wIndex_lo;            /*     6     1 */
	uint8_t                    wIndex_hi;            /*     7     1 */
	uint8_t                    wCount_lo;            /*     8     1 */
	uint8_t                    wCount_hi;            /*     9     1 */

	/* size: 10, cachelines: 1, members: 7 */
	/* last cacheline: 10 bytes */
} __attribute__((__packed__));
struct msos_prop {
	uint32_t                   dwLength;             /*     0     4 */
	uint32_t                   dwPropertyDataType;   /*     4     4 */
	uint8_t                    dwPropertyNameLength_lo; /*     8     1 */
	uint8_t                    dwPropertyNameLength_hi; /*     9     1 */
	uint8_t                    bPropertyName[];      /*    10     0 */

	/* size: 10, cachelines: 1, members: 5 */
	/* last cacheline: 10 bytes */
} __attribute__((__packed__));
struct msos_prop_data {
	uint32_t                   dwPropertyDataLength; /*     0     4 */
	uint8_t                    bPropertyData[];      /*     4     0 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
struct UHCIState {
	PCIDevice                  dev;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	MemoryRegion               io_bar;               /*  2288   256 */
	/* --- cacheline 39 boundary (2496 bytes) was 48 bytes ago --- */
	USBBus                     bus;                  /*  2544   176 */
	/* --- cacheline 42 boundary (2688 bytes) was 32 bytes ago --- */
	uint16_t                   cmd;                  /*  2720     2 */
	uint16_t                   status;               /*  2722     2 */
	uint16_t                   intr;                 /*  2724     2 */
	uint16_t                   frnum;                /*  2726     2 */
	uint32_t                   fl_base_addr;         /*  2728     4 */
	uint8_t                    sof_timing;           /*  2732     1 */
	uint8_t                    status2;              /*  2733     1 */

	/* XXX 2 bytes hole, try to pack */

	int64_t                    expire_time;          /*  2736     8 */
	QEMUTimer *                frame_timer;          /*  2744     8 */
	/* --- cacheline 43 boundary (2752 bytes) --- */
	QEMUBH *                   bh;                   /*  2752     8 */
	uint32_t                   frame_bytes;          /*  2760     4 */
	uint32_t                   frame_bandwidth;      /*  2764     4 */
	_Bool                      completions_only;     /*  2768     1 */

	/* XXX 7 bytes hole, try to pack */

	UHCIPort                   ports[2];             /*  2776   160 */
	/* --- cacheline 45 boundary (2880 bytes) was 56 bytes ago --- */
	uint32_t                   pending_int_mask;     /*  2936     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 46 boundary (2944 bytes) --- */
	struct {
		struct UHCIQueue * tqh_first;            /*  2944     8 */
		struct UHCIQueue * * tqh_last;           /*  2952     8 */
	} queues;                                        /*  2944    16 */
	uint8_t                    num_ports_vmstate;    /*  2960     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     masterbus;            /*  2968     8 */
	uint32_t                   firstport;            /*  2976     4 */
	uint32_t                   maxframes;            /*  2980     4 */

	/* size: 2992, cachelines: 47, members: 23 */
	/* sum members: 2964, holes: 4, sum holes: 20 */
	/* padding: 8 */
	/* last cacheline: 48 bytes */
};
struct UHCIAsync {
	USBPacket                  packet;               /*     0   120 */
	/* --- cacheline 1 boundary (64 bytes) was 56 bytes ago --- */
	uint8_t                    static_buf[64];       /*   120    64 */
	/* --- cacheline 2 boundary (128 bytes) was 56 bytes ago --- */
	uint8_t *                  buf;                  /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	UHCIQueue *                queue;                /*   192     8 */
	struct {
		struct UHCIAsync * tqe_next;             /*   200     8 */
		struct UHCIAsync * * tqe_prev;           /*   208     8 */
	} next;                                          /*   200    16 */
	uint32_t                   td_addr;              /*   216     4 */
	uint8_t                    done;                 /*   220     1 */

	/* size: 224, cachelines: 4, members: 7 */
	/* padding: 3 */
	/* last cacheline: 32 bytes */
};
struct UHCIQueue {
	uint32_t                   qh_addr;              /*     0     4 */
	uint32_t                   token;                /*     4     4 */
	UHCIState *                uhci;                 /*     8     8 */
	USBEndpoint *              ep;                   /*    16     8 */
	struct {
		struct UHCIQueue * tqe_next;             /*    24     8 */
		struct UHCIQueue * * tqe_prev;           /*    32     8 */
	} next;                                          /*    24    16 */
	struct asyncs_head         asyncs;               /*    40    16 */
	int8_t                     valid;                /*    56     1 */

	/* size: 64, cachelines: 1, members: 7 */
	/* padding: 7 */
};
struct UHCIInfo {
	const char  *              name;                 /*     0     8 */
	uint16_t                   vendor_id;            /*     8     2 */
	uint16_t                   device_id;            /*    10     2 */
	uint8_t                    revision;             /*    12     1 */
	uint8_t                    irq_pin;              /*    13     1 */

	/* XXX 2 bytes hole, try to pack */

	void                       (*realize)(PCIDevice *, Error * *); /*    16     8 */
	_Bool                      unplug;               /*    24     1 */

	/* size: 32, cachelines: 1, members: 7 */
	/* sum members: 23, holes: 1, sum holes: 2 */
	/* padding: 7 */
	/* last cacheline: 32 bytes */
};
struct UHCIPCIDeviceClass {
	PCIDeviceClass             parent_class;         /*     0   264 */
	/* --- cacheline 4 boundary (256 bytes) was 8 bytes ago --- */
	UHCIInfo                   info;                 /*   264    32 */

	/* size: 296, cachelines: 5, members: 2 */
	/* last cacheline: 40 bytes */
};
struct asyncs_head {
	struct UHCIAsync *         tqh_first;            /*     0     8 */
	struct UHCIAsync * *       tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct UHCIPort {
	USBPort                    port;                 /*     0    72 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	uint16_t                   ctrl;                 /*    72     2 */

	/* size: 80, cachelines: 2, members: 2 */
	/* padding: 6 */
	/* last cacheline: 16 bytes */
};
struct UHCI_TD {
	uint32_t                   link;                 /*     0     4 */
	uint32_t                   ctrl;                 /*     4     4 */
	uint32_t                   token;                /*     8     4 */
	uint32_t                   buffer;               /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct UHCI_QH {
	uint32_t                   link;                 /*     0     4 */
	uint32_t                   el_link;              /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct OHCIPort {
	USBPort                    port;                 /*     0    72 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	uint32_t                   ctrl;                 /*    72     4 */

	/* size: 80, cachelines: 2, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct ohci_hcca {
	uint32_t                   intr[32];             /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint16_t                   frame;                /*   128     2 */
	uint16_t                   pad;                  /*   130     2 */
	uint32_t                   done;                 /*   132     4 */

	/* size: 136, cachelines: 3, members: 4 */
	/* last cacheline: 8 bytes */
};
struct ohci_ed {
	uint32_t                   flags;                /*     0     4 */
	uint32_t                   tail;                 /*     4     4 */
	uint32_t                   head;                 /*     8     4 */
	uint32_t                   next;                 /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct ohci_td {
	uint32_t                   flags;                /*     0     4 */
	uint32_t                   cbp;                  /*     4     4 */
	uint32_t                   next;                 /*     8     4 */
	uint32_t                   be;                   /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct ohci_iso_td {
	uint32_t                   flags;                /*     0     4 */
	uint32_t                   bp;                   /*     4     4 */
	uint32_t                   next;                 /*     8     4 */
	uint32_t                   be;                   /*    12     4 */
	uint16_t                   offset[8];            /*    16    16 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct EHCIPacket {
	EHCIQueue *                queue;                /*     0     8 */
	struct {
		struct EHCIPacket * tqe_next;            /*     8     8 */
		struct EHCIPacket * * tqe_prev;          /*    16     8 */
	} next;                                          /*     8    16 */
	EHCIqtd                    qtd;                  /*    24    32 */
	uint32_t                   qtdaddr;              /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	USBPacket                  packet;               /*    64   120 */
	/* --- cacheline 2 boundary (128 bytes) was 56 bytes ago --- */
	QEMUSGList                 sgl;                  /*   184    40 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	int                        pid;                  /*   224     4 */
	enum async_state           async;                /*   228     4 */

	/* size: 232, cachelines: 4, members: 8 */
	/* sum members: 228, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct EHCIQueue {
	EHCIState *                ehci;                 /*     0     8 */
	struct {
		struct EHCIQueue * tqe_next;             /*     8     8 */
		struct EHCIQueue * * tqe_prev;           /*    16     8 */
	} next;                                          /*     8    16 */
	uint32_t                   seen;                 /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   ts;                   /*    32     8 */
	int                        async;                /*    40     4 */
	int                        transact_ctr;         /*    44     4 */
	EHCIqh                     qh;                   /*    48    48 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	uint32_t                   qhaddr;               /*    96     4 */
	uint32_t                   qtdaddr;              /*   100     4 */
	int                        last_pid;             /*   104     4 */

	/* XXX 4 bytes hole, try to pack */

	USBDevice *                dev;                  /*   112     8 */
	struct pkts_head           packets;              /*   120    16 */

	/* size: 136, cachelines: 3, members: 12 */
	/* sum members: 128, holes: 2, sum holes: 8 */
	/* last cacheline: 8 bytes */
};
struct EHCIState {
	USBBus                     bus;                  /*     0   176 */
	/* --- cacheline 2 boundary (128 bytes) was 48 bytes ago --- */
	DeviceState *              device;               /*   176     8 */
	qemu_irq                   irq;                  /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	MemoryRegion               mem;                  /*   192   256 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	AddressSpace *             as;                   /*   448     8 */

	/* XXX 8 bytes hole, try to pack */

	MemoryRegion               mem_caps;             /*   464   256 */
	/* --- cacheline 11 boundary (704 bytes) was 16 bytes ago --- */
	MemoryRegion               mem_opreg;            /*   720   256 */
	/* --- cacheline 15 boundary (960 bytes) was 16 bytes ago --- */
	MemoryRegion               mem_ports;            /*   976   256 */
	/* --- cacheline 19 boundary (1216 bytes) was 16 bytes ago --- */
	int                        companion_count;      /*  1232     4 */
	_Bool                      companion_enable;     /*  1236     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   capsbase;             /*  1238     2 */
	uint16_t                   opregbase;            /*  1240     2 */
	uint16_t                   portscbase;           /*  1242     2 */
	uint16_t                   portnr;               /*  1244     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   maxframes;            /*  1248     4 */
	uint8_t                    caps[16];             /*  1252    16 */
	union {
		uint32_t           opreg[17];            /*  1268    68 */
		struct {
			uint32_t   usbcmd;               /*  1268     4 */
			uint32_t   usbsts;               /*  1272     4 */
			uint32_t   usbintr;              /*  1276     4 */
			/* --- cacheline 20 boundary (1280 bytes) --- */
			uint32_t   frindex;              /*  1280     4 */
			uint32_t   ctrldssegment;        /*  1284     4 */
			uint32_t   periodiclistbase;     /*  1288     4 */
			uint32_t   asynclistaddr;        /*  1292     4 */
			uint32_t   notused[9];           /*  1296    36 */
			uint32_t   configflag;           /*  1332     4 */
		};                                       /*  1268    68 */
	};                                               /*  1268    68 */
	/* --- cacheline 20 boundary (1280 bytes) was 56 bytes ago --- */
	uint32_t                   portsc[6];            /*  1336    24 */
	/* --- cacheline 21 boundary (1344 bytes) was 16 bytes ago --- */
	QEMUTimer *                frame_timer;          /*  1360     8 */
	QEMUBH *                   async_bh;             /*  1368     8 */
	uint32_t                   astate;               /*  1376     4 */
	uint32_t                   pstate;               /*  1380     4 */
	USBPort                    ports[6];             /*  1384   432 */
	/* --- cacheline 28 boundary (1792 bytes) was 24 bytes ago --- */
	USBPort *                  companion_ports[6];   /*  1816    48 */
	/* --- cacheline 29 boundary (1856 bytes) was 8 bytes ago --- */
	uint32_t                   usbsts_pending;       /*  1864     4 */
	uint32_t                   usbsts_frindex;       /*  1868     4 */
	EHCIQueueHead              aqueues;              /*  1872    16 */
	EHCIQueueHead              pqueues;              /*  1888    16 */
	uint32_t                   a_fetch_addr;         /*  1904     4 */
	uint32_t                   p_fetch_addr;         /*  1908     4 */
	USBPacket                  ipacket;              /*  1912   120 */
	/* --- cacheline 31 boundary (1984 bytes) was 48 bytes ago --- */
	QEMUSGList                 isgl;                 /*  2032    40 */
	/* --- cacheline 32 boundary (2048 bytes) was 24 bytes ago --- */
	uint64_t                   last_run_ns;          /*  2072     8 */
	uint32_t                   async_stepdown;       /*  2080     4 */
	uint32_t                   periodic_sched_active; /*  2084     4 */
	_Bool                      int_req_by_async;     /*  2088     1 */

	/* XXX 7 bytes hole, try to pack */

	VMChangeStateEntry *       vmstate;              /*  2096     8 */

	/* size: 2112, cachelines: 33, members: 37 */
	/* sum members: 2086, holes: 4, sum holes: 18 */
	/* padding: 8 */
};
struct EHCIitd {
	uint32_t                   next;                 /*     0     4 */
	uint32_t                   transact[8];          /*     4    32 */
	uint32_t                   bufptr[7];            /*    36    28 */

	/* size: 64, cachelines: 1, members: 3 */
};
struct EHCIsitd {
	uint32_t                   next;                 /*     0     4 */
	uint32_t                   epchar;               /*     4     4 */
	uint32_t                   uframe;               /*     8     4 */
	uint32_t                   results;              /*    12     4 */
	uint32_t                   bufptr[2];            /*    16     8 */
	uint32_t                   backptr;              /*    24     4 */

	/* size: 28, cachelines: 1, members: 6 */
	/* last cacheline: 28 bytes */
};
struct EHCIqtd {
	uint32_t                   next;                 /*     0     4 */
	uint32_t                   altnext;              /*     4     4 */
	uint32_t                   token;                /*     8     4 */
	uint32_t                   bufptr[5];            /*    12    20 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct EHCIqh {
	uint32_t                   next;                 /*     0     4 */
	uint32_t                   epchar;               /*     4     4 */
	uint32_t                   epcap;                /*     8     4 */
	uint32_t                   current_qtd;          /*    12     4 */
	uint32_t                   next_qtd;             /*    16     4 */
	uint32_t                   altnext_qtd;          /*    20     4 */
	uint32_t                   token;                /*    24     4 */
	uint32_t                   bufptr[5];            /*    28    20 */

	/* size: 48, cachelines: 1, members: 8 */
	/* last cacheline: 48 bytes */
};
struct pkts_head {
	struct EHCIPacket *        tqh_first;            /*     0     8 */
	struct EHCIPacket * *      tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct EHCIQueueHead {
	struct EHCIQueue *         tqh_first;            /*     0     8 */
	struct EHCIQueue * *       tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct EHCIPCIState {
	PCIDevice                  pcidev;               /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	EHCIState                  ehci;                 /*  2288  2112 */

	/* size: 4400, cachelines: 69, members: 2 */
	/* last cacheline: 48 bytes */
};
struct EHCIPCIInfo {
	const char  *              name;                 /*     0     8 */
	uint16_t                   vendor_id;            /*     8     2 */
	uint16_t                   device_id;            /*    10     2 */
	uint8_t                    revision;             /*    12     1 */
	_Bool                      companion;            /*    13     1 */

	/* size: 16, cachelines: 1, members: 5 */
	/* padding: 2 */
	/* last cacheline: 16 bytes */
};
struct ehci_companions {
	const char  *              name;                 /*     0     8 */
	int                        func;                 /*     8     4 */
	int                        port;                 /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct XHCITRB {
	uint64_t                   parameter;            /*     0     8 */
	uint32_t                   status;               /*     8     4 */
	uint32_t                   control;              /*    12     4 */
	dma_addr_t                 addr;                 /*    16     8 */
	_Bool                      ccs;                  /*    24     1 */

	/* size: 32, cachelines: 1, members: 5 */
	/* padding: 7 */
	/* last cacheline: 32 bytes */
};
struct XHCIState {
	PCIDevice                  parent_obj;           /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	USBBus                     bus;                  /*  2288   176 */
	/* --- cacheline 38 boundary (2432 bytes) was 32 bytes ago --- */
	MemoryRegion               mem;                  /*  2464   256 */
	/* --- cacheline 42 boundary (2688 bytes) was 32 bytes ago --- */
	MemoryRegion               mem_cap;              /*  2720   256 */
	/* --- cacheline 46 boundary (2944 bytes) was 32 bytes ago --- */
	MemoryRegion               mem_oper;             /*  2976   256 */
	/* --- cacheline 50 boundary (3200 bytes) was 32 bytes ago --- */
	MemoryRegion               mem_runtime;          /*  3232   256 */
	/* --- cacheline 54 boundary (3456 bytes) was 32 bytes ago --- */
	MemoryRegion               mem_doorbell;         /*  3488   256 */
	/* --- cacheline 58 boundary (3712 bytes) was 32 bytes ago --- */
	uint32_t                   numports_2;           /*  3744     4 */
	uint32_t                   numports_3;           /*  3748     4 */
	uint32_t                   numintrs;             /*  3752     4 */
	uint32_t                   numslots;             /*  3756     4 */
	uint32_t                   flags;                /*  3760     4 */
	uint32_t                   max_pstreams_mask;    /*  3764     4 */
	OnOffAuto                  msi;                  /*  3768     4 */
	OnOffAuto                  msix;                 /*  3772     4 */
	/* --- cacheline 59 boundary (3776 bytes) --- */
	uint32_t                   usbcmd;               /*  3776     4 */
	uint32_t                   usbsts;               /*  3780     4 */
	uint32_t                   dnctrl;               /*  3784     4 */
	uint32_t                   crcr_low;             /*  3788     4 */
	uint32_t                   crcr_high;            /*  3792     4 */
	uint32_t                   dcbaap_low;           /*  3796     4 */
	uint32_t                   dcbaap_high;          /*  3800     4 */
	uint32_t                   config;               /*  3804     4 */
	USBPort                    uports[15];           /*  3808  1080 */

	/* XXX 8 bytes hole, try to pack */

	/* --- cacheline 76 boundary (4864 bytes) was 32 bytes ago --- */
	XHCIPort                   ports[30];            /*  4896  9120 */
	/* --- cacheline 219 boundary (14016 bytes) --- */
	XHCISlot                   slots[64];            /* 14016 17408 */
	/* --- cacheline 491 boundary (31424 bytes) --- */
	uint32_t                   numports;             /* 31424     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    mfindex_start;        /* 31432     8 */
	QEMUTimer *                mfwrap_timer;         /* 31440     8 */
	XHCIInterrupter            intr[16];             /* 31448 2884480 */
	/* --- cacheline 45561 boundary (2915904 bytes) was 24 bytes ago --- */
	XHCIRing                   cmd_ring;             /* 2915928    16 */

	/* size: 2915952, cachelines: 45562, members: 31 */
	/* sum members: 2915932, holes: 2, sum holes: 12 */
	/* padding: 8 */
	/* last cacheline: 48 bytes */
};
struct XHCIStreamContext {
	dma_addr_t                 pctx;                 /*     0     8 */
	unsigned int               sct;                  /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	XHCIRing                   ring;                 /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct XHCIEPContext {
	XHCIState *                xhci;                 /*     0     8 */
	unsigned int               slotid;               /*     8     4 */
	unsigned int               epid;                 /*    12     4 */
	XHCIRing                   ring;                 /*    16    16 */
	uint32_t                   xfer_count;           /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct XHCITransfer * tqh_first;         /*    40     8 */
		struct XHCITransfer * * tqh_last;        /*    48     8 */
	} transfers;                                     /*    40    16 */
	XHCITransfer *             retry;                /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	EPType                     type;                 /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	dma_addr_t                 pctx;                 /*    72     8 */
	unsigned int               max_psize;            /*    80     4 */
	uint32_t                   state;                /*    84     4 */
	unsigned int               max_pstreams;         /*    88     4 */
	_Bool                      lsa;                  /*    92     1 */

	/* XXX 3 bytes hole, try to pack */

	unsigned int               nr_pstreams;          /*    96     4 */

	/* XXX 4 bytes hole, try to pack */

	XHCIStreamContext *        pstreams;             /*   104     8 */
	unsigned int               interval;             /*   112     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    mfindex_last;         /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	QEMUTimer *                kick_timer;           /*   128     8 */

	/* size: 136, cachelines: 3, members: 18 */
	/* sum members: 117, holes: 5, sum holes: 19 */
	/* last cacheline: 8 bytes */
};
struct XHCIRing {
	dma_addr_t                 dequeue;              /*     0     8 */
	_Bool                      ccs;                  /*     8     1 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct XHCIPort {
	XHCIState *                xhci;                 /*     0     8 */
	uint32_t                   portsc;               /*     8     4 */
	uint32_t                   portnr;               /*    12     4 */
	USBPort *                  uport;                /*    16     8 */
	uint32_t                   speedmask;            /*    24     4 */
	char                       name[16];             /*    28    16 */

	/* XXX 4 bytes hole, try to pack */

	MemoryRegion               mem;                  /*    48   256 */

	/* size: 304, cachelines: 5, members: 7 */
	/* sum members: 300, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct XHCITransfer {
	XHCIEPContext *            epctx;                /*     0     8 */
	USBPacket                  packet;               /*     8   120 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	QEMUSGList                 sgl;                  /*   128    40 */
	_Bool                      running_async;        /*   168     1 */
	_Bool                      running_retry;        /*   169     1 */
	_Bool                      complete;             /*   170     1 */
	_Bool                      int_req;              /*   171     1 */
	unsigned int               iso_pkts;             /*   172     4 */
	unsigned int               streamid;             /*   176     4 */
	_Bool                      in_xfer;              /*   180     1 */
	_Bool                      iso_xfer;             /*   181     1 */
	_Bool                      timed_xfer;           /*   182     1 */

	/* XXX 1 byte hole, try to pack */

	unsigned int               trb_count;            /*   184     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) --- */
	XHCITRB *                  trbs;                 /*   192     8 */
	TRBCCode                   status;               /*   200     4 */
	unsigned int               pkts;                 /*   204     4 */
	unsigned int               pktsize;              /*   208     4 */
	unsigned int               cur_pkt;              /*   212     4 */
	uint64_t                   mfindex_kick;         /*   216     8 */
	struct {
		struct XHCITransfer * tqe_next;          /*   224     8 */
		struct XHCITransfer * * tqe_prev;        /*   232     8 */
	} next;                                          /*   224    16 */

	/* size: 240, cachelines: 4, members: 20 */
	/* sum members: 235, holes: 2, sum holes: 5 */
	/* last cacheline: 48 bytes */
};
struct XHCISlot {
	_Bool                      enabled;              /*     0     1 */
	_Bool                      addressed;            /*     1     1 */

	/* XXX 6 bytes hole, try to pack */

	dma_addr_t                 ctx;                  /*     8     8 */
	USBPort *                  uport;                /*    16     8 */
	XHCIEPContext *            eps[31];              /*    24   248 */

	/* size: 272, cachelines: 5, members: 5 */
	/* sum members: 266, holes: 1, sum holes: 6 */
	/* last cacheline: 16 bytes */
};
struct XHCIEvent {
	TRBType                    type;                 /*     0     4 */
	TRBCCode                   ccode;                /*     4     4 */
	uint64_t                   ptr;                  /*     8     8 */
	uint32_t                   length;               /*    16     4 */
	uint32_t                   flags;                /*    20     4 */
	uint8_t                    slotid;               /*    24     1 */
	uint8_t                    epid;                 /*    25     1 */

	/* size: 32, cachelines: 1, members: 7 */
	/* padding: 6 */
	/* last cacheline: 32 bytes */
};
struct XHCIInterrupter {
	uint32_t                   iman;                 /*     0     4 */
	uint32_t                   imod;                 /*     4     4 */
	uint32_t                   erstsz;               /*     8     4 */
	uint32_t                   erstba_low;           /*    12     4 */
	uint32_t                   erstba_high;          /*    16     4 */
	uint32_t                   erdp_low;             /*    20     4 */
	uint32_t                   erdp_high;            /*    24     4 */
	_Bool                      msix_used;            /*    28     1 */
	_Bool                      er_pcs;               /*    29     1 */
	_Bool                      er_full;              /*    30     1 */

	/* XXX 1 byte hole, try to pack */

	dma_addr_t                 er_start;             /*    32     8 */
	uint32_t                   er_size;              /*    40     4 */
	unsigned int               er_ep_idx;            /*    44     4 */
	XHCIEvent                  ev_buffer[5632];      /*    48 180224 */
	/* --- cacheline 2816 boundary (180224 bytes) was 48 bytes ago --- */
	unsigned int               ev_buffer_put;        /* 180272     4 */
	unsigned int               ev_buffer_get;        /* 180276     4 */

	/* size: 180280, cachelines: 2817, members: 16 */
	/* sum members: 180279, holes: 1, sum holes: 1 */
	/* last cacheline: 56 bytes */
};
struct XHCIEvRingSeg {
	uint32_t                   addr_low;             /*     0     4 */
	uint32_t                   addr_high;            /*     4     4 */
	uint32_t                   size;                 /*     8     4 */
	uint32_t                   rsvd;                 /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct USBHubPort {
	USBPort                    port;                 /*     0    72 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	uint16_t                   wPortStatus;          /*    72     2 */
	uint16_t                   wPortChange;          /*    74     2 */

	/* size: 80, cachelines: 2, members: 3 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct USBHubState {
	USBDevice                  dev;                  /*     0  5800 */
	/* --- cacheline 90 boundary (5760 bytes) was 40 bytes ago --- */
	USBEndpoint *              intr;                 /*  5800     8 */
	USBHubPort                 ports[8];             /*  5808   640 */

	/* size: 6448, cachelines: 101, members: 3 */
	/* last cacheline: 48 bytes */
};
struct USBHIDState {
	USBDevice                  dev;                  /*     0  5800 */
	/* --- cacheline 90 boundary (5760 bytes) was 40 bytes ago --- */
	USBEndpoint *              intr;                 /*  5800     8 */
	HIDState                   hid;                  /*  5808   304 */
	/* --- cacheline 95 boundary (6080 bytes) was 32 bytes ago --- */
	uint32_t                   usb_version;          /*  6112     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     display;              /*  6120     8 */
	uint32_t                   head;                 /*  6128     4 */

	/* size: 6136, cachelines: 96, members: 6 */
	/* sum members: 6128, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct USBWacomState {
	USBDevice                  dev;                  /*     0  5800 */
	/* --- cacheline 90 boundary (5760 bytes) was 40 bytes ago --- */
	USBEndpoint *              intr;                 /*  5800     8 */
	QEMUPutMouseEntry *        eh_entry;             /*  5808     8 */
	int                        dx;                   /*  5816     4 */
	int                        dy;                   /*  5820     4 */
	/* --- cacheline 91 boundary (5824 bytes) --- */
	int                        dz;                   /*  5824     4 */
	int                        buttons_state;        /*  5828     4 */
	int                        x;                    /*  5832     4 */
	int                        y;                    /*  5836     4 */
	int                        mouse_grabbed;        /*  5840     4 */
	enum {
		WACOM_MODE_HID = 1,
		WACOM_MODE_WACOM = 2,
	} mode;                                          /*  5844     4 */
	uint8_t                    idle;                 /*  5848     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        changed;              /*  5852     4 */

	/* size: 5856, cachelines: 92, members: 13 */
	/* sum members: 5853, holes: 1, sum holes: 3 */
	/* last cacheline: 32 bytes */
};
struct usb_msd_csw {
	uint32_t                   sig;                  /*     0     4 */
	uint32_t                   tag;                  /*     4     4 */
	uint32_t                   residue;              /*     8     4 */
	uint8_t                    status;               /*    12     1 */

	/* size: 16, cachelines: 1, members: 4 */
	/* padding: 3 */
	/* last cacheline: 16 bytes */
};
struct usb_msd_cbw {
	uint32_t                   sig;                  /*     0     4 */
	uint32_t                   tag;                  /*     4     4 */
	uint32_t                   data_len;             /*     8     4 */
	uint8_t                    flags;                /*    12     1 */
	uint8_t                    lun;                  /*    13     1 */
	uint8_t                    cmd_len;              /*    14     1 */
	uint8_t                    cmd[16];              /*    15    16 */

	/* size: 32, cachelines: 1, members: 7 */
	/* padding: 1 */
	/* last cacheline: 32 bytes */
};
struct UASDevice {
	USBDevice                  dev;                  /*     0  5800 */
	/* --- cacheline 90 boundary (5760 bytes) was 40 bytes ago --- */
	SCSIBus                    bus;                  /*  5800   120 */
	/* --- cacheline 92 boundary (5888 bytes) was 32 bytes ago --- */
	QEMUBH *                   status_bh;            /*  5920     8 */
	struct {
		struct UASStatus * tqh_first;            /*  5928     8 */
		struct UASStatus * * tqh_last;           /*  5936     8 */
	} results;                                       /*  5928    16 */
	struct {
		struct UASRequest * tqh_first;           /*  5944     8 */
		/* --- cacheline 93 boundary (5952 bytes) --- */
		struct UASRequest * * tqh_last;          /*  5952     8 */
	} requests;                                      /*  5944    16 */
	uint32_t                   requestlog;           /*  5960     4 */

	/* XXX 4 bytes hole, try to pack */

	USBPacket *                status2;              /*  5968     8 */
	UASRequest *               datain2;              /*  5976     8 */
	UASRequest *               dataout2;             /*  5984     8 */
	USBPacket *                data3[17];            /*  5992   136 */
	/* --- cacheline 95 boundary (6080 bytes) was 48 bytes ago --- */
	USBPacket *                status3[17];          /*  6128   136 */

	/* size: 6264, cachelines: 98, members: 11 */
	/* sum members: 6260, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct UASRequest {
	uint16_t                   tag;                  /*     0     2 */

	/* XXX 6 bytes hole, try to pack */

	uint64_t                   lun;                  /*     8     8 */
	UASDevice *                uas;                  /*    16     8 */
	SCSIDevice *               dev;                  /*    24     8 */
	SCSIRequest *              req;                  /*    32     8 */
	USBPacket *                data;                 /*    40     8 */
	_Bool                      data_async;           /*    48     1 */
	_Bool                      active;               /*    49     1 */
	_Bool                      complete;             /*    50     1 */

	/* XXX 1 byte hole, try to pack */

	uint32_t                   buf_off;              /*    52     4 */
	uint32_t                   buf_size;             /*    56     4 */
	uint32_t                   data_off;             /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint32_t                   data_size;            /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct UASRequest * tqe_next;            /*    72     8 */
		struct UASRequest * * tqe_prev;          /*    80     8 */
	} next;                                          /*    72    16 */

	/* size: 88, cachelines: 2, members: 14 */
	/* sum members: 77, holes: 3, sum holes: 11 */
	/* last cacheline: 24 bytes */
};
struct UASStatus {
	uint32_t                   stream;               /*     0     4 */
	uas_iu                     status;               /*     4    34 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   length;               /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct UASStatus * tqe_next;             /*    48     8 */
		struct UASStatus * * tqe_prev;           /*    56     8 */
	} next;                                          /*    48    16 */

	/* size: 64, cachelines: 1, members: 4 */
	/* sum members: 58, holes: 2, sum holes: 6 */
};
struct streambuf {
	uint8_t *                  data;                 /*     0     8 */
	uint32_t                   size;                 /*     8     4 */
	uint32_t                   prod;                 /*    12     4 */
	uint32_t                   cons;                 /*    16     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct USBAudioState {
	USBDevice                  dev;                  /*     0  5800 */
	/* --- cacheline 90 boundary (5760 bytes) was 40 bytes ago --- */
	QEMUSoundCard              card;                 /*  5800    24 */
	/* --- cacheline 91 boundary (5824 bytes) --- */
	struct {
		enum usb_audio_altset altset;            /*  5824     4 */
		struct audsettings as;                   /*  5828    16 */

		/* XXX 4 bytes hole, try to pack */

		SWVoiceOut *       voice;                /*  5848     8 */
		_Bool              mute;                 /*  5856     1 */
		uint8_t            vol[2];               /*  5857     2 */

		/* XXX 5 bytes hole, try to pack */

		struct streambuf   buf;                  /*  5864    24 */

		/* XXX last struct has 4 bytes of padding */
	} out;                                           /*  5824    64 */
	/* --- cacheline 92 boundary (5888 bytes) --- */
	uint32_t                   debug;                /*  5888     4 */
	uint32_t                   buffer;               /*  5892     4 */

	/* size: 5896, cachelines: 93, members: 5 */
	/* last cacheline: 8 bytes */
};
struct rndis_init_msg_type {
	le32                       MessageType;          /*     0     4 */
	le32                       MessageLength;        /*     4     4 */
	le32                       RequestID;            /*     8     4 */
	le32                       MajorVersion;         /*    12     4 */
	le32                       MinorVersion;         /*    16     4 */
	le32                       MaxTransferSize;      /*    20     4 */

	/* size: 24, cachelines: 1, members: 6 */
	/* last cacheline: 24 bytes */
};
struct rndis_init_cmplt_type {
	le32                       MessageType;          /*     0     4 */
	le32                       MessageLength;        /*     4     4 */
	le32                       RequestID;            /*     8     4 */
	le32                       Status;               /*    12     4 */
	le32                       MajorVersion;         /*    16     4 */
	le32                       MinorVersion;         /*    20     4 */
	le32                       DeviceFlags;          /*    24     4 */
	le32                       Medium;               /*    28     4 */
	le32                       MaxPacketsPerTransfer; /*    32     4 */
	le32                       MaxTransferSize;      /*    36     4 */
	le32                       PacketAlignmentFactor; /*    40     4 */
	le32                       AFListOffset;         /*    44     4 */
	le32                       AFListSize;           /*    48     4 */

	/* size: 52, cachelines: 1, members: 13 */
	/* last cacheline: 52 bytes */
};
struct rndis_query_msg_type {
	le32                       MessageType;          /*     0     4 */
	le32                       MessageLength;        /*     4     4 */
	le32                       RequestID;            /*     8     4 */
	le32                       OID;                  /*    12     4 */
	le32                       InformationBufferLength; /*    16     4 */
	le32                       InformationBufferOffset; /*    20     4 */
	le32                       DeviceVcHandle;       /*    24     4 */

	/* size: 28, cachelines: 1, members: 7 */
	/* last cacheline: 28 bytes */
};
struct rndis_query_cmplt_type {
	le32                       MessageType;          /*     0     4 */
	le32                       MessageLength;        /*     4     4 */
	le32                       RequestID;            /*     8     4 */
	le32                       Status;               /*    12     4 */
	le32                       InformationBufferLength; /*    16     4 */
	le32                       InformationBufferOffset; /*    20     4 */

	/* size: 24, cachelines: 1, members: 6 */
	/* last cacheline: 24 bytes */
};
struct rndis_set_msg_type {
	le32                       MessageType;          /*     0     4 */
	le32                       MessageLength;        /*     4     4 */
	le32                       RequestID;            /*     8     4 */
	le32                       OID;                  /*    12     4 */
	le32                       InformationBufferLength; /*    16     4 */
	le32                       InformationBufferOffset; /*    20     4 */
	le32                       DeviceVcHandle;       /*    24     4 */

	/* size: 28, cachelines: 1, members: 7 */
	/* last cacheline: 28 bytes */
};
struct rndis_set_cmplt_type {
	le32                       MessageType;          /*     0     4 */
	le32                       MessageLength;        /*     4     4 */
	le32                       RequestID;            /*     8     4 */
	le32                       Status;               /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct rndis_reset_msg_type {
	le32                       MessageType;          /*     0     4 */
	le32                       MessageLength;        /*     4     4 */
	le32                       Reserved;             /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
struct rndis_reset_cmplt_type {
	le32                       MessageType;          /*     0     4 */
	le32                       MessageLength;        /*     4     4 */
	le32                       Status;               /*     8     4 */
	le32                       AddressingReset;      /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct rndis_keepalive_msg_type {
	le32                       MessageType;          /*     0     4 */
	le32                       MessageLength;        /*     4     4 */
	le32                       RequestID;            /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
struct rndis_keepalive_cmplt_type {
	le32                       MessageType;          /*     0     4 */
	le32                       MessageLength;        /*     4     4 */
	le32                       RequestID;            /*     8     4 */
	le32                       Status;               /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct rndis_packet_msg_type {
	le32                       MessageType;          /*     0     4 */
	le32                       MessageLength;        /*     4     4 */
	le32                       DataOffset;           /*     8     4 */
	le32                       DataLength;           /*    12     4 */
	le32                       OOBDataOffset;        /*    16     4 */
	le32                       OOBDataLength;        /*    20     4 */
	le32                       NumOOBDataElements;   /*    24     4 */
	le32                       PerPacketInfoOffset;  /*    28     4 */
	le32                       PerPacketInfoLength;  /*    32     4 */
	le32                       VcHandle;             /*    36     4 */
	le32                       Reserved;             /*    40     4 */

	/* size: 44, cachelines: 1, members: 11 */
	/* last cacheline: 44 bytes */
};
struct rndis_response {
	struct {
		struct rndis_response * tqe_next;        /*     0     8 */
		struct rndis_response * * tqe_prev;      /*     8     8 */
	} entries;                                       /*     0    16 */
	uint32_t                   length;               /*    16     4 */
	uint8_t                    buf[];                /*    20     0 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct rndis_resp_head {
	struct rndis_response *    tqh_first;            /*     0     8 */
	struct rndis_response * *  tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct USBNetState {
	USBDevice                  dev;                  /*     0  5800 */
	/* --- cacheline 90 boundary (5760 bytes) was 40 bytes ago --- */
	enum rndis_state           rndis_state;          /*  5800     4 */
	uint32_t                   medium;               /*  5804     4 */
	uint32_t                   speed;                /*  5808     4 */
	uint32_t                   media_state;          /*  5812     4 */
	uint16_t                   filter;               /*  5816     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   vendorid;             /*  5820     4 */
	/* --- cacheline 91 boundary (5824 bytes) --- */
	unsigned int               out_ptr;              /*  5824     4 */
	uint8_t                    out_buf[2048];        /*  5828  2048 */
	/* --- cacheline 123 boundary (7872 bytes) was 4 bytes ago --- */
	unsigned int               in_ptr;               /*  7876     4 */
	unsigned int               in_len;               /*  7880     4 */
	uint8_t                    in_buf[2048];         /*  7884  2048 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 155 boundary (9920 bytes) was 16 bytes ago --- */
	USBEndpoint *              intr;                 /*  9936     8 */
	char                       usbstring_mac[13];    /*  9944    13 */

	/* XXX 3 bytes hole, try to pack */

	NICState *                 nic;                  /*  9960     8 */
	NICConf                    conf;                 /*  9968  8216 */
	/* --- cacheline 284 boundary (18176 bytes) was 8 bytes ago --- */
	struct rndis_resp_head     rndis_resp;           /* 18184    16 */

	/* size: 18200, cachelines: 285, members: 17 */
	/* sum members: 18191, holes: 3, sum holes: 9 */
	/* last cacheline: 24 bytes */
};
struct usb_hci_in_fifo_s {
	uint8_t                    data[8192];           /*     0  8192 */
	/* --- cacheline 128 boundary (8192 bytes) --- */
	struct {
		uint8_t *          data;                 /*  8192     8 */
		int                len;                  /*  8200     4 */
	} fifo[256]; /*  8192  4096 */
	/* --- cacheline 192 boundary (12288 bytes) --- */
	int                        dstart;               /* 12288     4 */
	int                        dlen;                 /* 12292     4 */
	int                        dsize;                /* 12296     4 */
	int                        start;                /* 12300     4 */
	int                        len;                  /* 12304     4 */

	/* size: 12312, cachelines: 193, members: 7 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct usb_hci_out_fifo_s {
	uint8_t                    data[4096];           /*     0  4096 */
	/* --- cacheline 64 boundary (4096 bytes) --- */
	int                        len;                  /*  4096     4 */

	/* size: 4100, cachelines: 65, members: 2 */
	/* last cacheline: 4 bytes */
};
struct USBBtState {
	USBDevice                  dev;                  /*     0  5800 */
	/* --- cacheline 90 boundary (5760 bytes) was 40 bytes ago --- */
	struct HCIInfo *           hci;                  /*  5800     8 */
	USBEndpoint *              intr;                 /*  5808     8 */
	int                        config;               /*  5816     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 91 boundary (5824 bytes) --- */
	struct usb_hci_in_fifo_s   evt;                  /*  5824 12312 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 283 boundary (18112 bytes) was 24 bytes ago --- */
	struct usb_hci_in_fifo_s   acl;                  /* 18136 12312 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 475 boundary (30400 bytes) was 48 bytes ago --- */
	struct usb_hci_in_fifo_s   sco;                  /* 30448 12312 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 668 boundary (42752 bytes) was 8 bytes ago --- */
	struct usb_hci_out_fifo_s  outcmd;               /* 42760  4100 */
	/* --- cacheline 732 boundary (46848 bytes) was 12 bytes ago --- */
	struct usb_hci_out_fifo_s  outacl;               /* 46860  4100 */
	/* --- cacheline 796 boundary (50944 bytes) was 16 bytes ago --- */
	struct usb_hci_out_fifo_s  outsco;               /* 50960  4100 */

	/* size: 55064, cachelines: 861, members: 10 */
	/* sum members: 55056, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* paddings: 3, sum paddings: 12 */
	/* last cacheline: 24 bytes */
};
struct CCIDCardState {
	DeviceState                qdev;                 /*     0   112 */
	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	uint32_t                   slot;                 /*   112     4 */

	/* size: 120, cachelines: 2, members: 2 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct CCIDCardClass {
	DeviceClass                parent_class;         /*     0   192 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	const uint8_t  *           (*get_atr)(CCIDCardState *, uint32_t *); /*   192     8 */
	void                       (*apdu_from_guest)(CCIDCardState *, const uint8_t  *, uint32_t); /*   200     8 */
	void                       (*exitfn)(CCIDCardState *); /*   208     8 */
	int                        (*initfn)(CCIDCardState *); /*   216     8 */

	/* size: 224, cachelines: 4, members: 5 */
	/* last cacheline: 32 bytes */
};
struct CCID_Header {
	uint8_t                    bMessageType;         /*     0     1 */
	uint32_t                   dwLength;             /*     1     4 */
	uint8_t                    bSlot;                /*     5     1 */
	uint8_t                    bSeq;                 /*     6     1 */

	/* size: 7, cachelines: 1, members: 4 */
	/* last cacheline: 7 bytes */
} __attribute__((__packed__));
struct CCID_BULK_IN {
	CCID_Header                hdr;                  /*     0     7 */
	uint8_t                    bStatus;              /*     7     1 */
	uint8_t                    bError;               /*     8     1 */

	/* size: 9, cachelines: 1, members: 3 */
	/* last cacheline: 9 bytes */
} __attribute__((__packed__));
struct CCID_SlotStatus {
	CCID_BULK_IN               b;                    /*     0     9 */
	uint8_t                    bClockStatus;         /*     9     1 */

	/* size: 10, cachelines: 1, members: 2 */
	/* last cacheline: 10 bytes */
} __attribute__((__packed__));
struct CCID_T0ProtocolDataStructure {
	uint8_t                    bmFindexDindex;       /*     0     1 */
	uint8_t                    bmTCCKST0;            /*     1     1 */
	uint8_t                    bGuardTimeT0;         /*     2     1 */
	uint8_t                    bWaitingIntegerT0;    /*     3     1 */
	uint8_t                    bClockStop;           /*     4     1 */

	/* size: 5, cachelines: 1, members: 5 */
	/* last cacheline: 5 bytes */
};
struct CCID_T1ProtocolDataStructure {
	uint8_t                    bmFindexDindex;       /*     0     1 */
	uint8_t                    bmTCCKST1;            /*     1     1 */
	uint8_t                    bGuardTimeT1;         /*     2     1 */
	uint8_t                    bWaitingIntegerT1;    /*     3     1 */
	uint8_t                    bClockStop;           /*     4     1 */
	uint8_t                    bIFSC;                /*     5     1 */
	uint8_t                    bNadValue;            /*     6     1 */

	/* size: 7, cachelines: 1, members: 7 */
	/* last cacheline: 7 bytes */
};
union CCID_ProtocolDataStructure {
	CCID_T0ProtocolDataStructure t0;               /*     0     5 */
	CCID_T1ProtocolDataStructure t1;               /*     0     7 */
	uint8_t                    data[7];            /*     0     7 */
};
struct CCID_Parameter {
	CCID_BULK_IN               b;                    /*     0     9 */
	uint8_t                    bProtocolNum;         /*     9     1 */
	CCID_ProtocolDataStructure abProtocolDataStructure; /*    10     7 */

	/* size: 17, cachelines: 1, members: 3 */
	/* last cacheline: 17 bytes */
} __attribute__((__packed__));
struct CCID_DataBlock {
	CCID_BULK_IN               b;                    /*     0     9 */
	uint8_t                    bChainParameter;      /*     9     1 */
	uint8_t                    abData[];             /*    10     0 */

	/* size: 10, cachelines: 1, members: 3 */
	/* last cacheline: 10 bytes */
} __attribute__((__packed__));
struct CCID_XferBlock {
	CCID_Header                hdr;                  /*     0     7 */
	uint8_t                    bBWI;                 /*     7     1 */
	uint16_t                   wLevelParameter;      /*     8     2 */
	uint8_t                    abData[];             /*    10     0 */

	/* size: 10, cachelines: 1, members: 4 */
	/* last cacheline: 10 bytes */
} __attribute__((__packed__));
struct CCID_IccPowerOn {
	CCID_Header                hdr;                  /*     0     7 */
	uint8_t                    bPowerSelect;         /*     7     1 */
	uint16_t                   abRFU;                /*     8     2 */

	/* size: 10, cachelines: 1, members: 3 */
	/* last cacheline: 10 bytes */
} __attribute__((__packed__));
struct CCID_SetParameters {
	CCID_Header                hdr;                  /*     0     7 */
	uint8_t                    bProtocolNum;         /*     7     1 */
	uint16_t                   abRFU;                /*     8     2 */
	CCID_ProtocolDataStructure abProtocolDataStructure; /*    10     7 */

	/* size: 17, cachelines: 1, members: 4 */
	/* last cacheline: 17 bytes */
} __attribute__((__packed__));
struct Answer {
	uint8_t                    slot;                 /*     0     1 */
	uint8_t                    seq;                  /*     1     1 */

	/* size: 2, cachelines: 1, members: 2 */
	/* last cacheline: 2 bytes */
};
struct BulkIn {
	uint8_t                    data[384];            /*     0   384 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	uint32_t                   len;                  /*   384     4 */
	uint32_t                   pos;                  /*   388     4 */

	/* size: 392, cachelines: 7, members: 3 */
	/* last cacheline: 8 bytes */
};
struct CCIDBus {
	BusState                   qbus;                 /*     0   104 */

	/* size: 104, cachelines: 2, members: 1 */
	/* last cacheline: 40 bytes */
};
struct USBCCIDState {
	USBDevice                  dev;                  /*     0  5800 */
	/* --- cacheline 90 boundary (5760 bytes) was 40 bytes ago --- */
	USBEndpoint *              intr;                 /*  5800     8 */
	USBEndpoint *              bulk;                 /*  5808     8 */
	CCIDBus                    bus;                  /*  5816   104 */
	/* --- cacheline 92 boundary (5888 bytes) was 32 bytes ago --- */
	CCIDCardState *            card;                 /*  5920     8 */
	BulkIn                     bulk_in_pending[8];   /*  5928  3136 */
	/* --- cacheline 141 boundary (9024 bytes) was 40 bytes ago --- */
	uint32_t                   bulk_in_pending_start; /*  9064     4 */
	uint32_t                   bulk_in_pending_end;  /*  9068     4 */
	uint32_t                   bulk_in_pending_num;  /*  9072     4 */

	/* XXX 4 bytes hole, try to pack */

	BulkIn *                   current_bulk_in;      /*  9080     8 */
	/* --- cacheline 142 boundary (9088 bytes) --- */
	uint8_t                    bulk_out_data[65536]; /*  9088 65536 */
	/* --- cacheline 1166 boundary (74624 bytes) --- */
	uint32_t                   bulk_out_pos;         /* 74624     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   last_answer_error;    /* 74632     8 */
	Answer                     pending_answers[128]; /* 74640   256 */
	/* --- cacheline 1170 boundary (74880 bytes) was 16 bytes ago --- */
	uint32_t                   pending_answers_start; /* 74896     4 */
	uint32_t                   pending_answers_end;  /* 74900     4 */
	uint32_t                   pending_answers_num;  /* 74904     4 */
	uint8_t                    bError;               /* 74908     1 */
	uint8_t                    bmCommandStatus;      /* 74909     1 */
	uint8_t                    bProtocolNum;         /* 74910     1 */
	CCID_ProtocolDataStructure abProtocolDataStructure; /* 74911     7 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   ulProtocolDataStructureSize; /* 74920     4 */
	uint32_t                   state_vmstate;        /* 74924     4 */
	uint32_t                   migration_target_ip;  /* 74928     4 */
	uint16_t                   migration_target_port; /* 74932     2 */
	uint8_t                    migration_state;      /* 74934     1 */
	uint8_t                    bmSlotICCState;       /* 74935     1 */
	uint8_t                    powered;              /* 74936     1 */
	uint8_t                    notify_slot_change;   /* 74937     1 */
	uint8_t                    debug;                /* 74938     1 */

	/* size: 74944, cachelines: 1171, members: 30 */
	/* sum members: 74929, holes: 3, sum holes: 10 */
	/* padding: 5 */
};
struct statvfs {
	long unsigned int          f_bsize;              /*     0     8 */
	long unsigned int          f_frsize;             /*     8     8 */
	__fsblkcnt64_t             f_blocks;             /*    16     8 */
	__fsblkcnt64_t             f_bfree;              /*    24     8 */
	__fsblkcnt64_t             f_bavail;             /*    32     8 */
	__fsfilcnt64_t             f_files;              /*    40     8 */
	__fsfilcnt64_t             f_ffree;              /*    48     8 */
	__fsfilcnt64_t             f_favail;             /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	long unsigned int          f_fsid;               /*    64     8 */
	long unsigned int          f_flag;               /*    72     8 */
	long unsigned int          f_namemax;            /*    80     8 */
	int                        __f_spare[6];         /*    88    24 */

	/* size: 112, cachelines: 2, members: 12 */
	/* last cacheline: 48 bytes */
};
struct inotify_event {
	int                        wd;                   /*     0     4 */
	uint32_t                   mask;                 /*     4     4 */
	uint32_t                   cookie;               /*     8     4 */
	uint32_t                   len;                  /*    12     4 */
	char                       name[];               /*    16     0 */

	/* size: 16, cachelines: 1, members: 5 */
	/* last cacheline: 16 bytes */
};
struct MTPState {
	USBDevice                  dev;                  /*     0  5800 */
	/* --- cacheline 90 boundary (5760 bytes) was 40 bytes ago --- */
	char *                     root;                 /*  5800     8 */
	char *                     desc;                 /*  5808     8 */
	uint32_t                   flags;                /*  5816     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 91 boundary (5824 bytes) --- */
	MTPData *                  data_in;              /*  5824     8 */
	MTPData *                  data_out;             /*  5832     8 */
	MTPControl *               result;               /*  5840     8 */
	uint32_t                   session;              /*  5848     4 */
	uint32_t                   next_handle;          /*  5852     4 */
	struct {
		struct MTPObject * tqh_first;            /*  5856     8 */
		struct MTPObject * * tqh_last;           /*  5864     8 */
	} objects;                                       /*  5856    16 */
	int                        inotifyfd;            /*  5872     4 */

	/* XXX 4 bytes hole, try to pack */

	struct events              events;               /*  5880    16 */

	/* size: 5896, cachelines: 93, members: 12 */
	/* sum members: 5888, holes: 2, sum holes: 8 */
	/* last cacheline: 8 bytes */
};
struct MTPControl {
	uint16_t                   code;                 /*     0     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   trans;                /*     4     4 */
	int                        argc;                 /*     8     4 */
	uint32_t                   argv[5];              /*    12    20 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 30, holes: 1, sum holes: 2 */
	/* last cacheline: 32 bytes */
};
struct MTPData {
	uint16_t                   code;                 /*     0     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   trans;                /*     4     4 */
	uint64_t                   offset;               /*     8     8 */
	uint64_t                   length;               /*    16     8 */
	uint32_t                   alloc;                /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  data;                 /*    32     8 */
	_Bool                      first;                /*    40     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        fd;                   /*    44     4 */

	/* size: 48, cachelines: 1, members: 8 */
	/* sum members: 39, holes: 3, sum holes: 9 */
	/* last cacheline: 48 bytes */
};
struct MTPObject {
	uint32_t                   handle;               /*     0     4 */
	uint16_t                   format;               /*     4     2 */

	/* XXX 2 bytes hole, try to pack */

	char *                     name;                 /*     8     8 */
	char *                     path;                 /*    16     8 */
	struct stat                stat;                 /*    24   144 */
	/* --- cacheline 2 boundary (128 bytes) was 40 bytes ago --- */
	int                        watchfd;              /*   168     4 */

	/* XXX 4 bytes hole, try to pack */

	MTPObject *                parent;               /*   176     8 */
	uint32_t                   nchildren;            /*   184     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) --- */
	struct {
		struct MTPObject * lh_first;             /*   192     8 */
	} children;                                      /*   192     8 */
	struct {
		struct MTPObject * le_next;              /*   200     8 */
		struct MTPObject * * le_prev;            /*   208     8 */
	} list;                                          /*   200    16 */
	_Bool                      have_children;        /*   216     1 */

	/* XXX 7 bytes hole, try to pack */

	struct {
		struct MTPObject * tqe_next;             /*   224     8 */
		struct MTPObject * * tqe_prev;           /*   232     8 */
	} next;                                          /*   224    16 */

	/* size: 240, cachelines: 4, members: 12 */
	/* sum members: 223, holes: 4, sum holes: 17 */
	/* last cacheline: 48 bytes */
};
struct MTPMonEntry {
	uint32_t                   event;                /*     0     4 */
	uint32_t                   handle;               /*     4     4 */
	struct {
		struct MTPMonEntry * tqe_next;           /*     8     8 */
		struct MTPMonEntry * * tqe_prev;         /*    16     8 */
	} next;                                          /*     8    16 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct events {
	struct MTPMonEntry *       tqh_first;            /*     0     8 */
	struct MTPMonEntry * *     tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct VirtIORNGConf {
	RngBackend *               rng;                  /*     0     8 */
	uint64_t                   max_bytes;            /*     8     8 */
	uint32_t                   period_ms;            /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	RngRandom *                default_backend;      /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct VirtIORNG {
	VirtIODevice               parent_obj;           /*     0   224 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	VirtQueue *                vq;                   /*   224     8 */
	VirtIORNGConf              conf;                 /*   232    32 */
	/* --- cacheline 4 boundary (256 bytes) was 8 bytes ago --- */
	RngBackend *               rng;                  /*   264     8 */
	QEMUTimer *                rate_limit_timer;     /*   272     8 */
	int64_t                    quota_remaining;      /*   280     8 */
	_Bool                      activate_timer;       /*   288     1 */

	/* size: 296, cachelines: 5, members: 7 */
	/* padding: 7 */
	/* last cacheline: 40 bytes */
};
struct virtio_pci_cap {
	uint8_t                    cap_vndr;             /*     0     1 */
	uint8_t                    cap_next;             /*     1     1 */
	uint8_t                    cap_len;              /*     2     1 */
	uint8_t                    cfg_type;             /*     3     1 */
	uint8_t                    bar;                  /*     4     1 */
	uint8_t                    padding[3];           /*     5     3 */
	uint32_t                   offset;               /*     8     4 */
	uint32_t                   length;               /*    12     4 */

	/* size: 16, cachelines: 1, members: 8 */
	/* last cacheline: 16 bytes */
};
struct virtio_pci_notify_cap {
	struct virtio_pci_cap      cap;                  /*     0    16 */
	uint32_t                   notify_off_multiplier; /*    16     4 */

	/* size: 20, cachelines: 1, members: 2 */
	/* last cacheline: 20 bytes */
};
struct virtio_pci_cfg_cap {
	struct virtio_pci_cap      cap;                  /*     0    16 */
	uint8_t                    pci_cfg_data[4];      /*    16     4 */

	/* size: 20, cachelines: 1, members: 2 */
	/* last cacheline: 20 bytes */
};
struct VirtIOBlkPCI {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VirtIOBlock                vdev;                 /* 33808   368 */

	/* size: 34176, cachelines: 534, members: 2 */
};
struct VirtIOSCSIPCI {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VirtIOSCSI                 vdev;                 /* 33808   448 */

	/* size: 34256, cachelines: 536, members: 2 */
	/* last cacheline: 16 bytes */
};
struct VirtIOBalloonPCI {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VirtIOBalloon              vdev;                 /* 33808   360 */

	/* size: 34176, cachelines: 534, members: 2 */
	/* padding: 8 */
};
struct VirtIOSerialPCI {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VirtIOSerial               vdev;                 /* 33808   440 */

	/* size: 34256, cachelines: 536, members: 2 */
	/* padding: 8 */
	/* last cacheline: 16 bytes */
};
struct VirtIONetPCI {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VirtIONet                  vdev;                 /* 33808  8648 */

	/* size: 42464, cachelines: 664, members: 2 */
	/* padding: 8 */
	/* last cacheline: 32 bytes */
};
struct VHostSCSIPCI {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VHostSCSI                  vdev;                 /* 33808   656 */

	/* size: 34464, cachelines: 539, members: 2 */
	/* last cacheline: 32 bytes */
};
struct VirtIORngPCI {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VirtIORNG                  vdev;                 /* 33808   296 */

	/* size: 34112, cachelines: 533, members: 2 */
	/* padding: 8 */
};
struct VirtIOInputPCI {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VirtIOInput                vdev;                 /* 33808   296 */

	/* size: 34112, cachelines: 533, members: 2 */
	/* padding: 8 */
};
struct VirtIOInputHIDPCI {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VirtIOInputHID             vdev;                 /* 33808   336 */

	/* size: 34144, cachelines: 534, members: 2 */
	/* last cacheline: 32 bytes */
};
struct VirtIOInputHostPCI {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VirtIOInputHost            vdev;                 /* 33808   312 */

	/* size: 34128, cachelines: 534, members: 2 */
	/* padding: 8 */
	/* last cacheline: 16 bytes */
};
struct VHostVSockPCI {
	VirtIOPCIProxy             parent_obj;           /*     0 33808 */
	/* --- cacheline 528 boundary (33792 bytes) was 16 bytes ago --- */
	VHostVSock                 vdev;                 /* 33808   776 */

	/* size: 34592, cachelines: 541, members: 2 */
	/* padding: 8 */
	/* last cacheline: 32 bytes */
};
struct WatchdogTimerModel {
	struct {
		struct WatchdogTimerModel * le_next;     /*     0     8 */
		struct WatchdogTimerModel * * le_prev;   /*     8     8 */
	} entry;                                         /*     0    16 */
	const char  *              wdt_name;             /*    16     8 */
	const char  *              wdt_description;      /*    24     8 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct watchdog_list {
	struct WatchdogTimerModel * lh_first;            /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct I6300State {
	PCIDevice                  dev;                  /*     0  2288 */
	/* --- cacheline 35 boundary (2240 bytes) was 48 bytes ago --- */
	MemoryRegion               io_mem;               /*  2288   256 */
	/* --- cacheline 39 boundary (2496 bytes) was 48 bytes ago --- */
	int                        reboot_enabled;       /*  2544     4 */
	int                        clock_scale;          /*  2548     4 */
	int                        int_type;             /*  2552     4 */
	int                        free_run;             /*  2556     4 */
	/* --- cacheline 40 boundary (2560 bytes) --- */
	int                        locked;               /*  2560     4 */
	int                        enabled;              /*  2564     4 */
	QEMUTimer *                timer;                /*  2568     8 */
	uint32_t                   timer1_preload;       /*  2576     4 */
	uint32_t                   timer2_preload;       /*  2580     4 */
	int                        stage;                /*  2584     4 */
	int                        unlock_state;         /*  2588     4 */
	int                        previous_reboot_flag; /*  2592     4 */

	/* Force padding: */
	int                        :32;
	int                        :32;
	int                        :32;

	/* size: 2608, cachelines: 41, members: 14 */
	/* padding: 12 */
	/* last cacheline: 48 bytes */
};
struct IB700state {
	ISADevice                  parent_obj;           /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	QEMUTimer *                timer;                /*   128     8 */
	PortioList                 port_list;            /*   136    64 */

	/* size: 200, cachelines: 4, members: 3 */
	/* last cacheline: 8 bytes */
};
struct rp_cmd_args {
	ssize_t                    len;                  /*     0     8 */
	const char  *              name;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct SocketConnectData {
	MigrationState *           s;                    /*     0     8 */
	char *                     hostname;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct QIOChannelCommand {
	QIOChannel                 parent;               /*     0    56 */
	int                        writefd;              /*    56     4 */
	int                        readfd;               /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	pid_t                      pid;                  /*    64     4 */

	/* size: 72, cachelines: 2, members: 4 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
struct QEMUFile {
	const QEMUFileOps  *       ops;                  /*     0     8 */
	const QEMUFileHooks  *     hooks;                /*     8     8 */
	void *                     opaque;               /*    16     8 */
	int64_t                    bytes_xfer;           /*    24     8 */
	int64_t                    xfer_limit;           /*    32     8 */
	int64_t                    pos;                  /*    40     8 */
	int                        buf_index;            /*    48     4 */
	int                        buf_size;             /*    52     4 */
	uint8_t                    buf[32768];           /*    56 32768 */
	/* --- cacheline 512 boundary (32768 bytes) was 56 bytes ago --- */
	struct iovec               iov[64];              /* 32824  1024 */
	/* --- cacheline 528 boundary (33792 bytes) was 56 bytes ago --- */
	unsigned int               iovcnt;               /* 33848     4 */
	int                        last_error;           /* 33852     4 */

	/* size: 33856, cachelines: 529, members: 12 */
};
struct QEMUFileHooks {
	QEMURamHookFunc *          before_ram_iterate;   /*     0     8 */
	QEMURamHookFunc *          after_ram_iterate;    /*     8     8 */
	QEMURamHookFunc *          hook_ram_load;        /*    16     8 */
	QEMURamSaveFunc *          save_page;            /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct PostcopyDiscardState {
	const char  *              ramblock_name;        /*     0     8 */
	uint64_t                   offset;               /*     8     8 */
	uint16_t                   cur_entry;            /*    16     2 */

	/* XXX 6 bytes hole, try to pack */

	uint64_t                   start_list[12];       /*    24    96 */
	/* --- cacheline 1 boundary (64 bytes) was 56 bytes ago --- */
	uint64_t                   length_list[12];      /*   120    96 */
	/* --- cacheline 3 boundary (192 bytes) was 24 bytes ago --- */
	unsigned int               nsentwords;           /*   216     4 */
	unsigned int               nsentcmds;            /*   220     4 */

	/* size: 224, cachelines: 4, members: 7 */
	/* sum members: 218, holes: 1, sum holes: 6 */
	/* last cacheline: 32 bytes */
};
struct pollfd {
	int                        fd;                   /*     0     4 */
	short int                  events;               /*     4     2 */
	short int                  revents;              /*     6     2 */

	/* size: 8, cachelines: 1, members: 3 */
	/* last cacheline: 8 bytes */
};
struct uffd_msg {
	__u8                       event;                /*     0     1 */
	__u8                       reserved1;            /*     1     1 */
	__u16                      reserved2;            /*     2     2 */
	__u32                      reserved3;            /*     4     4 */
	union {
		struct {
			__u64      flags;                /*     8     8 */
			__u64      address;              /*    16     8 */
		} pagefault;                             /*     8    16 */
		struct {
			__u64      reserved1;            /*     8     8 */
			__u64      reserved2;            /*    16     8 */
			__u64      reserved3;            /*    24     8 */
		} reserved;                              /*     8    24 */
	} arg;                                           /*     8    24 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct uffdio_api {
	__u64                      api;                  /*     0     8 */
	__u64                      features;             /*     8     8 */
	__u64                      ioctls;               /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct uffdio_range {
	__u64                      start;                /*     0     8 */
	__u64                      len;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct uffdio_register {
	struct uffdio_range        range;                /*     0    16 */
	__u64                      mode;                 /*    16     8 */
	__u64                      ioctls;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct uffdio_copy {
	__u64                      dst;                  /*     0     8 */
	__u64                      src;                  /*     8     8 */
	__u64                      len;                  /*    16     8 */
	__u64                      mode;                 /*    24     8 */
	__s64                      copy;                 /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct uffdio_zeropage {
	struct uffdio_range        range;                /*     0    16 */
	__u64                      mode;                 /*    16     8 */
	__s64                      zeropage;             /*    24     8 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct QJSON {
	QString *                  str;                  /*     0     8 */
	_Bool                      omit_comma;           /*     8     1 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct BlkMigDevState {
	BlockBackend *             blk;                  /*     0     8 */
	char *                     blk_name;             /*     8     8 */
	int                        shared_base;          /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    total_sectors;        /*    24     8 */
	struct {
		struct BlkMigDevState * sqe_next;        /*    32     8 */
	} entry;                                         /*    32     8 */
	Error *                    blocker;              /*    40     8 */
	int                        bulk_completed;       /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    cur_sector;           /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int64_t                    cur_dirty;            /*    64     8 */
	long unsigned int *        aio_bitmap;           /*    72     8 */
	int64_t                    completed_sectors;    /*    80     8 */
	BdrvDirtyBitmap *          dirty_bitmap;         /*    88     8 */

	/* size: 96, cachelines: 2, members: 12 */
	/* sum members: 88, holes: 2, sum holes: 8 */
	/* last cacheline: 32 bytes */
};
struct BlkMigBlock {
	uint8_t *                  buf;                  /*     0     8 */
	BlkMigDevState *           bmds;                 /*     8     8 */
	int64_t                    sector;               /*    16     8 */
	int                        nr_sectors;           /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	struct iovec               iov;                  /*    32    16 */
	QEMUIOVector               qiov;                 /*    48    24 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	BlockAIOCB *               aiocb;                /*    72     8 */
	int                        ret;                  /*    80     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct BlkMigBlock * sqe_next;           /*    88     8 */
	} entry;                                         /*    88     8 */

	/* size: 96, cachelines: 2, members: 9 */
	/* sum members: 88, holes: 2, sum holes: 8 */
	/* last cacheline: 32 bytes */
};
struct bmds_list {
	struct BlkMigDevState *    sqh_first;            /*     0     8 */
	struct BlkMigDevState * *  sqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct blk_list {
	struct BlkMigBlock *       sqh_first;            /*     0     8 */
	struct BlkMigBlock * *     sqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlkMigState {
	int                        blk_enable;           /*     0     4 */
	int                        shared_base;          /*     4     4 */
	struct bmds_list           bmds_list;            /*     8    16 */
	int64_t                    total_sector_sum;     /*    24     8 */
	_Bool                      zero_blocks;          /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	struct blk_list            blk_list;             /*    40    16 */
	int                        submitted;            /*    56     4 */
	int                        read_done;            /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        transferred;          /*    64     4 */
	int                        prev_progress;        /*    68     4 */
	int                        bulk_completed;       /*    72     4 */

	/* XXX 4 bytes hole, try to pack */

	QemuMutex                  lock;                 /*    80    40 */

	/* size: 120, cachelines: 2, members: 12 */
	/* sum members: 109, holes: 2, sum holes: 11 */
	/* last cacheline: 56 bytes */
};
struct sockaddr_in {
	sa_family_t                sin_family;           /*     0     2 */
	in_port_t                  sin_port;             /*     2     2 */
	struct in_addr             sin_addr;             /*     4     4 */
	unsigned char              sin_zero[8];          /*     8     8 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct hostent {
	char *                     h_name;               /*     0     8 */
	char * *                   h_aliases;            /*     8     8 */
	int                        h_addrtype;           /*    16     4 */
	int                        h_length;             /*    20     4 */
	char * *                   h_addr_list;          /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct NetFilterState {
	Object                     parent;               /*     0    40 */
	char *                     netdev_id;            /*    40     8 */
	NetClientState *           netdev;               /*    48     8 */
	NetFilterDirection         direction;            /*    56     4 */
	_Bool                      on;                   /*    60     1 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	struct {
		struct NetFilterState * tqe_next;        /*    64     8 */
		struct NetFilterState * * tqe_prev;      /*    72     8 */
	} next;                                          /*    64    16 */

	/* size: 80, cachelines: 2, members: 6 */
	/* sum members: 77, holes: 1, sum holes: 3 */
	/* last cacheline: 16 bytes */
};
struct NetLegacy {
	_Bool                      has_vlan;             /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	int32_t                    vlan;                 /*     4     4 */
	_Bool                      has_id;               /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     id;                   /*    16     8 */
	_Bool                      has_name;             /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     name;                 /*    32     8 */
	NetLegacyOptions *         opts;                 /*    40     8 */

	/* size: 48, cachelines: 1, members: 7 */
	/* sum members: 31, holes: 3, sum holes: 17 */
	/* last cacheline: 48 bytes */
};
struct NetLegacyNicOptions {
	_Bool                      has_netdev;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     netdev;               /*     8     8 */
	_Bool                      has_macaddr;          /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     macaddr;              /*    24     8 */
	_Bool                      has_model;            /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     model;                /*    40     8 */
	_Bool                      has_addr;             /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     addr;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_vectors;          /*    64     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   vectors;              /*    68     4 */

	/* size: 72, cachelines: 2, members: 10 */
	/* sum members: 41, holes: 5, sum holes: 31 */
	/* last cacheline: 8 bytes */
};
struct NetLegacyOptions {
	NetLegacyOptionsKind       type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		q_obj_NetdevNoneOptions_wrapper none;    /*     8     8 */
		q_obj_NetLegacyNicOptions_wrapper nic;   /*     8     8 */
		q_obj_NetdevUserOptions_wrapper user;    /*     8     8 */
		q_obj_NetdevTapOptions_wrapper tap;      /*     8     8 */
		q_obj_NetdevL2TPv3Options_wrapper l2tpv3; /*     8     8 */
		q_obj_NetdevSocketOptions_wrapper socket; /*     8     8 */
		q_obj_NetdevVdeOptions_wrapper vde;      /*     8     8 */
		q_obj_NetdevDumpOptions_wrapper dump;    /*     8     8 */
		q_obj_NetdevBridgeOptions_wrapper bridge; /*     8     8 */
		q_obj_NetdevNetmapOptions_wrapper netmap; /*     8     8 */
		q_obj_NetdevVhostUserOptions_wrapper vhost_user; /*     8     8 */
	} u;                                             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct Netdev {
	char *                     id;                   /*     0     8 */
	NetClientDriver            type;                 /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		NetdevNoneOptions  none;                 /*    16     1 */
		NetLegacyNicOptions nic;                 /*    16    72 */
		NetdevUserOptions  user;                 /*    16   272 */
		NetdevTapOptions   tap;                  /*    16   176 */
		NetdevL2TPv3Options l2tpv3;              /*    16   112 */
		NetdevSocketOptions socket;              /*    16    96 */
		NetdevVdeOptions   vde;                  /*    16    40 */
		NetdevDumpOptions  dump;                 /*    16    32 */
		NetdevBridgeOptions bridge;              /*    16    32 */
		NetdevHubPortOptions hubport;            /*    16     4 */
		NetdevNetmapOptions netmap;              /*    16    24 */
		NetdevVhostUserOptions vhost_user;       /*    16    24 */
	} u;                                             /*    16   272 */

	/* size: 288, cachelines: 5, members: 3 */
	/* sum members: 284, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct NetdevBridgeOptions {
	_Bool                      has_br;               /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     br;                   /*     8     8 */
	_Bool                      has_helper;           /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     helper;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 18, holes: 2, sum holes: 14 */
	/* last cacheline: 32 bytes */
};
struct NetdevDumpOptions {
	_Bool                      has_len;              /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	uint64_t                   len;                  /*     8     8 */
	_Bool                      has_file;             /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     file;                 /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 18, holes: 2, sum holes: 14 */
	/* last cacheline: 32 bytes */
};
struct NetdevHubPortOptions {
	int32_t                    hubid;                /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct NetdevL2TPv3Options {
	char *                     src;                  /*     0     8 */
	char *                     dst;                  /*     8     8 */
	_Bool                      has_srcport;          /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     srcport;              /*    24     8 */
	_Bool                      has_dstport;          /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     dstport;              /*    40     8 */
	_Bool                      has_ipv6;             /*    48     1 */
	_Bool                      ipv6;                 /*    49     1 */
	_Bool                      has_udp;              /*    50     1 */
	_Bool                      udp;                  /*    51     1 */
	_Bool                      has_cookie64;         /*    52     1 */
	_Bool                      cookie64;             /*    53     1 */
	_Bool                      has_counter;          /*    54     1 */
	_Bool                      counter;              /*    55     1 */
	_Bool                      has_pincounter;       /*    56     1 */
	_Bool                      pincounter;           /*    57     1 */
	_Bool                      has_txcookie;         /*    58     1 */

	/* XXX 5 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	uint64_t                   txcookie;             /*    64     8 */
	_Bool                      has_rxcookie;         /*    72     1 */

	/* XXX 7 bytes hole, try to pack */

	uint64_t                   rxcookie;             /*    80     8 */
	uint32_t                   txsession;            /*    88     4 */
	_Bool                      has_rxsession;        /*    92     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   rxsession;            /*    96     4 */
	_Bool                      has_offset;           /*   100     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   offset;               /*   104     4 */

	/* size: 112, cachelines: 2, members: 25 */
	/* sum members: 76, holes: 6, sum holes: 32 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct NetdevNetmapOptions {
	char *                     ifname;               /*     0     8 */
	_Bool                      has_devname;          /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     devname;              /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct NetdevNoneOptions {
	char                       qapi_dummy_for_empty_struct; /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
};
struct NetdevSocketOptions {
	_Bool                      has_fd;               /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     fd;                   /*     8     8 */
	_Bool                      has_listen;           /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     listen;               /*    24     8 */
	_Bool                      has_connect;          /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     connect;              /*    40     8 */
	_Bool                      has_mcast;            /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     mcast;                /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_localaddr;        /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     localaddr;            /*    72     8 */
	_Bool                      has_udp;              /*    80     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     udp;                  /*    88     8 */

	/* size: 96, cachelines: 2, members: 12 */
	/* sum members: 54, holes: 6, sum holes: 42 */
	/* last cacheline: 32 bytes */
};
struct NetdevTapOptions {
	_Bool                      has_ifname;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     ifname;               /*     8     8 */
	_Bool                      has_fd;               /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     fd;                   /*    24     8 */
	_Bool                      has_fds;              /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     fds;                  /*    40     8 */
	_Bool                      has_script;           /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     script;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_downscript;       /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     downscript;           /*    72     8 */
	_Bool                      has_br;               /*    80     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     br;                   /*    88     8 */
	_Bool                      has_helper;           /*    96     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     helper;               /*   104     8 */
	_Bool                      has_sndbuf;           /*   112     1 */

	/* XXX 7 bytes hole, try to pack */

	uint64_t                   sndbuf;               /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	_Bool                      has_vnet_hdr;         /*   128     1 */
	_Bool                      vnet_hdr;             /*   129     1 */
	_Bool                      has_vhost;            /*   130     1 */
	_Bool                      vhost;                /*   131     1 */
	_Bool                      has_vhostfd;          /*   132     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     vhostfd;              /*   136     8 */
	_Bool                      has_vhostfds;         /*   144     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     vhostfds;             /*   152     8 */
	_Bool                      has_vhostforce;       /*   160     1 */
	_Bool                      vhostforce;           /*   161     1 */
	_Bool                      has_queues;           /*   162     1 */

	/* XXX 1 byte hole, try to pack */

	uint32_t                   queues;               /*   164     4 */
	_Bool                      has_poll_us;          /*   168     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   poll_us;              /*   172     4 */

	/* size: 176, cachelines: 3, members: 30 */
	/* sum members: 106, holes: 12, sum holes: 70 */
	/* last cacheline: 48 bytes */
};
struct NetdevUserOptions {
	_Bool                      has_hostname;         /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     hostname;             /*     8     8 */
	_Bool                      has_q_restrict;       /*    16     1 */
	_Bool                      q_restrict;           /*    17     1 */
	_Bool                      has_ipv4;             /*    18     1 */
	_Bool                      ipv4;                 /*    19     1 */
	_Bool                      has_ipv6;             /*    20     1 */
	_Bool                      ipv6;                 /*    21     1 */
	_Bool                      has_ip;               /*    22     1 */

	/* XXX 1 byte hole, try to pack */

	char *                     ip;                   /*    24     8 */
	_Bool                      has_net;              /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     net;                  /*    40     8 */
	_Bool                      has_host;             /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     host;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      has_tftp;             /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     tftp;                 /*    72     8 */
	_Bool                      has_bootfile;         /*    80     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     bootfile;             /*    88     8 */
	_Bool                      has_dhcpstart;        /*    96     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     dhcpstart;            /*   104     8 */
	_Bool                      has_dns;              /*   112     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     dns;                  /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	_Bool                      has_dnssearch;        /*   128     1 */

	/* XXX 7 bytes hole, try to pack */

	StringList *               dnssearch;            /*   136     8 */
	_Bool                      has_ipv6_prefix;      /*   144     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     ipv6_prefix;          /*   152     8 */
	_Bool                      has_ipv6_prefixlen;   /*   160     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    ipv6_prefixlen;       /*   168     8 */
	_Bool                      has_ipv6_host;        /*   176     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     ipv6_host;            /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	_Bool                      has_ipv6_dns;         /*   192     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     ipv6_dns;             /*   200     8 */
	_Bool                      has_smb;              /*   208     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     smb;                  /*   216     8 */
	_Bool                      has_smbserver;        /*   224     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     smbserver;            /*   232     8 */
	_Bool                      has_hostfwd;          /*   240     1 */

	/* XXX 7 bytes hole, try to pack */

	StringList *               hostfwd;              /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	_Bool                      has_guestfwd;         /*   256     1 */

	/* XXX 7 bytes hole, try to pack */

	StringList *               guestfwd;             /*   264     8 */

	/* size: 272, cachelines: 5, members: 40 */
	/* sum members: 159, holes: 17, sum holes: 113 */
	/* last cacheline: 16 bytes */
};
struct NetdevVdeOptions {
	_Bool                      has_sock;             /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     sock;                 /*     8     8 */
	_Bool                      has_port;             /*    16     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   port;                 /*    18     2 */
	_Bool                      has_group;            /*    20     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     group;                /*    24     8 */
	_Bool                      has_mode;             /*    32     1 */

	/* XXX 1 byte hole, try to pack */

	uint16_t                   mode;                 /*    34     2 */

	/* size: 40, cachelines: 1, members: 8 */
	/* sum members: 24, holes: 4, sum holes: 12 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct NetdevVhostUserOptions {
	char *                     chardev;              /*     0     8 */
	_Bool                      has_vhostforce;       /*     8     1 */
	_Bool                      vhostforce;           /*     9     1 */
	_Bool                      has_queues;           /*    10     1 */

	/* XXX 5 bytes hole, try to pack */

	int64_t                    queues;               /*    16     8 */

	/* size: 24, cachelines: 1, members: 5 */
	/* sum members: 19, holes: 1, sum holes: 5 */
	/* last cacheline: 24 bytes */
};
struct StringList {
	StringList *               next;                 /*     0     8 */
	String *                   value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_NetLegacyNicOptions_wrapper {
	NetLegacyNicOptions *      data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_NetdevBridgeOptions_wrapper {
	NetdevBridgeOptions *      data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_NetdevDumpOptions_wrapper {
	NetdevDumpOptions *        data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_NetdevL2TPv3Options_wrapper {
	NetdevL2TPv3Options *      data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_NetdevNetmapOptions_wrapper {
	NetdevNetmapOptions *      data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_NetdevNoneOptions_wrapper {
	NetdevNoneOptions *        data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_NetdevSocketOptions_wrapper {
	NetdevSocketOptions *      data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_NetdevTapOptions_wrapper {
	NetdevTapOptions *         data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_NetdevUserOptions_wrapper {
	NetdevUserOptions *        data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_NetdevVdeOptions_wrapper {
	NetdevVdeOptions *         data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_NetdevVhostUserOptions_wrapper {
	NetdevVhostUserOptions *   data;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct SocketReadState {
	int                        state;                /*     0     4 */
	uint32_t                   index;                /*     4     4 */
	uint32_t                   packet_len;           /*     8     4 */
	uint8_t                    buf[69632];           /*    12 69632 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1088 boundary (69632 bytes) was 16 bytes ago --- */
	SocketReadStateFinalize *  finalize;             /* 69648     8 */

	/* size: 69656, cachelines: 1089, members: 5 */
	/* sum members: 69652, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct NetPacket {
	struct {
		struct NetPacket * tqe_next;             /*     0     8 */
		struct NetPacket * * tqe_prev;           /*     8     8 */
	} entry;                                         /*     0    16 */
	NetClientState *           sender;               /*    16     8 */
	unsigned int               flags;                /*    24     4 */
	int                        size;                 /*    28     4 */
	NetPacketSent *            sent_cb;              /*    32     8 */
	uint8_t                    data[];               /*    40     0 */

	/* size: 40, cachelines: 1, members: 6 */
	/* last cacheline: 40 bytes */
};
struct NetQueue {
	void *                     opaque;               /*     0     8 */
	uint32_t                   nq_maxlen;            /*     8     4 */
	uint32_t                   nq_count;             /*    12     4 */
	NetQueueDeliverFunc *      deliver;              /*    16     8 */
	struct packets             packets;              /*    24    16 */
	unsigned int               delivering:1;         /*    40: 0  4 */

	/* size: 48, cachelines: 1, members: 6 */
	/* padding: 4 */
	/* bit_padding: 31 bits */
	/* last cacheline: 48 bytes */
};
struct packets {
	struct NetPacket *         tqh_first;            /*     0     8 */
	struct NetPacket * *       tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct NetHub {
	int                        id;                   /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct NetHub *    le_next;              /*     8     8 */
		struct NetHub * *  le_prev;              /*    16     8 */
	} next;                                          /*     8    16 */
	int                        num_ports;            /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct NetHubPort * lh_first;            /*    32     8 */
	} ports;                                         /*    32     8 */

	/* size: 40, cachelines: 1, members: 4 */
	/* sum members: 32, holes: 2, sum holes: 8 */
	/* last cacheline: 40 bytes */
};
struct NetHubPort {
	NetClientState             nc;                   /*     0   368 */
	/* --- cacheline 5 boundary (320 bytes) was 48 bytes ago --- */
	struct {
		struct NetHubPort * le_next;             /*   368     8 */
		struct NetHubPort * * le_prev;           /*   376     8 */
	} next;                                          /*   368    16 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	NetHub *                   hub;                  /*   384     8 */
	int                        id;                   /*   392     4 */

	/* size: 400, cachelines: 7, members: 4 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct sockaddr_in6 {
	sa_family_t                sin6_family;          /*     0     2 */
	in_port_t                  sin6_port;            /*     2     2 */
	uint32_t                   sin6_flowinfo;        /*     4     4 */
	struct in6_addr            sin6_addr;            /*     8    16 */
	uint32_t                   sin6_scope_id;        /*    24     4 */

	/* size: 28, cachelines: 1, members: 5 */
	/* last cacheline: 28 bytes */
};
struct in6_addr {
	union {
		uint8_t            __u6_addr8[16];       /*     0    16 */
		uint16_t           __u6_addr16[8];       /*     0    16 */
		uint32_t           __u6_addr32[4];       /*     0    16 */
	} __in6_u;                                       /*     0    16 */

	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */
};
struct ip_mreq {
	struct in_addr             imr_multiaddr;        /*     0     4 */
	struct in_addr             imr_interface;        /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct NetSocketState {
	NetClientState             nc;                   /*     0   368 */
	/* --- cacheline 5 boundary (320 bytes) was 48 bytes ago --- */
	int                        listen_fd;            /*   368     4 */
	int                        fd;                   /*   372     4 */
	SocketReadState            rs;                   /*   376 69656 */
	/* --- cacheline 1094 boundary (70016 bytes) was 16 bytes ago --- */
	unsigned int               send_index;           /* 70032     4 */
	struct sockaddr_in         dgram_dst;            /* 70036    16 */

	/* XXX 4 bytes hole, try to pack */

	IOHandler *                send_fn;              /* 70056     8 */
	_Bool                      read_poll;            /* 70064     1 */
	_Bool                      write_poll;           /* 70065     1 */

	/* size: 70072, cachelines: 1095, members: 9 */
	/* sum members: 70062, holes: 1, sum holes: 4 */
	/* padding: 6 */
	/* last cacheline: 56 bytes */
};
struct NetFilterClass {
	ObjectClass                parent_class;         /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	FilterSetup *              setup;                /*    96     8 */
	FilterCleanup *            cleanup;              /*   104     8 */
	FilterStatusChanged *      status_changed;       /*   112     8 */
	FilterReceiveIOV *         receive_iov;          /*   120     8 */

	/* size: 128, cachelines: 2, members: 5 */
};
struct pcap_file_hdr {
	uint32_t                   magic;                /*     0     4 */
	uint16_t                   version_major;        /*     4     2 */
	uint16_t                   version_minor;        /*     6     2 */
	int32_t                    thiszone;             /*     8     4 */
	uint32_t                   sigfigs;              /*    12     4 */
	uint32_t                   snaplen;              /*    16     4 */
	uint32_t                   linktype;             /*    20     4 */

	/* size: 24, cachelines: 1, members: 7 */
	/* last cacheline: 24 bytes */
};
struct pcap_sf_pkthdr {
	struct {
		int32_t            tv_sec;               /*     0     4 */
		int32_t            tv_usec;              /*     4     4 */
	} ts;                                            /*     0     8 */
	uint32_t                   caplen;               /*     8     4 */
	uint32_t                   len;                  /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct DumpNetClient {
	NetClientState             nc;                   /*     0   368 */
	/* --- cacheline 5 boundary (320 bytes) was 48 bytes ago --- */
	DumpState                  ds;                   /*   368    16 */

	/* size: 384, cachelines: 6, members: 2 */
};
struct NetFilterDumpState {
	NetFilterState             nfs;                  /*     0    80 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	DumpState                  ds;                   /*    80    16 */
	char *                     filename;             /*    96     8 */
	uint32_t                   maxlen;               /*   104     4 */

	/* size: 112, cachelines: 2, members: 4 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct ip6_pseudo_header {
	struct in6_address         ip6_src;              /*     0    16 */
	struct in6_address         ip6_dst;              /*    16    16 */
	uint32_t                   len;                  /*    32     4 */
	uint8_t                    zero[3];              /*    36     3 */
	uint8_t                    next_hdr;             /*    39     1 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct ip6_ext_hdr {
	uint8_t                    ip6r_nxt;             /*     0     1 */
	uint8_t                    ip6r_len;             /*     1     1 */

	/* size: 2, cachelines: 1, members: 2 */
	/* last cacheline: 2 bytes */
};
struct ip6_ext_hdr_routing {
	uint8_t                    nxt;                  /*     0     1 */
	uint8_t                    len;                  /*     1     1 */
	uint8_t                    rtype;                /*     2     1 */
	uint8_t                    segleft;              /*     3     1 */
	uint8_t                    rsvd[4];              /*     4     4 */

	/* size: 8, cachelines: 1, members: 5 */
	/* last cacheline: 8 bytes */
};
struct ip6_option_hdr {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    len;                  /*     1     1 */

	/* size: 2, cachelines: 1, members: 2 */
	/* last cacheline: 2 bytes */
};
struct msghdr {
	void *                     msg_name;             /*     0     8 */
	socklen_t                  msg_namelen;          /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	struct iovec *             msg_iov;              /*    16     8 */
	size_t                     msg_iovlen;           /*    24     8 */
	void *                     msg_control;          /*    32     8 */
	size_t                     msg_controllen;       /*    40     8 */
	int                        msg_flags;            /*    48     4 */

	/* size: 56, cachelines: 1, members: 7 */
	/* sum members: 48, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct mmsghdr {
	struct msghdr              msg_hdr;              /*     0    56 */

	/* XXX last struct has 4 bytes of padding */

	unsigned int               msg_len;              /*    56     4 */

	/* size: 64, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* paddings: 1, sum paddings: 4 */
};
struct addrinfo {
	int                        ai_flags;             /*     0     4 */
	int                        ai_family;            /*     4     4 */
	int                        ai_socktype;          /*     8     4 */
	int                        ai_protocol;          /*    12     4 */
	socklen_t                  ai_addrlen;           /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	struct sockaddr *          ai_addr;              /*    24     8 */
	char *                     ai_canonname;         /*    32     8 */
	struct addrinfo *          ai_next;              /*    40     8 */

	/* size: 48, cachelines: 1, members: 8 */
	/* sum members: 44, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct NetL2TPV3State {
	NetClientState             nc;                   /*     0   368 */
	/* --- cacheline 5 boundary (320 bytes) was 48 bytes ago --- */
	int                        fd;                   /*   368     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  header_buf;           /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	struct iovec *             vec;                  /*   384     8 */
	struct mmsghdr *           msgvec;               /*   392     8 */
	struct sockaddr_storage *  dgram_dst;            /*   400     8 */
	uint32_t                   dst_size;             /*   408     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   rx_cookie;            /*   416     8 */
	uint64_t                   tx_cookie;            /*   424     8 */
	uint32_t                   rx_session;           /*   432     4 */
	uint32_t                   tx_session;           /*   436     4 */
	uint32_t                   header_size;          /*   440     4 */
	uint32_t                   counter;              /*   444     4 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	_Bool                      header_mismatch;      /*   448     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        queue_head;           /*   452     4 */
	int                        queue_tail;           /*   456     4 */
	int                        queue_depth;          /*   460     4 */
	uint32_t                   offset;               /*   464     4 */
	uint32_t                   cookie_offset;        /*   468     4 */
	uint32_t                   counter_offset;       /*   472     4 */
	uint32_t                   session_offset;       /*   476     4 */
	_Bool                      read_poll;            /*   480     1 */
	_Bool                      write_poll;           /*   481     1 */
	_Bool                      ipv6;                 /*   482     1 */
	_Bool                      udp;                  /*   483     1 */
	_Bool                      has_counter;          /*   484     1 */
	_Bool                      pin_counter;          /*   485     1 */
	_Bool                      cookie;               /*   486     1 */
	_Bool                      cookie_is_64;         /*   487     1 */

	/* size: 488, cachelines: 8, members: 29 */
	/* sum members: 477, holes: 3, sum holes: 11 */
	/* last cacheline: 40 bytes */
};
struct cmsghdr {
	size_t                     cmsg_len;             /*     0     8 */
	int                        cmsg_level;           /*     8     4 */
	int                        cmsg_type;            /*    12     4 */
	unsigned char              __cmsg_data[];        /*    16     0 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct TAPState {
	NetClientState             nc;                   /*     0   368 */
	/* --- cacheline 5 boundary (320 bytes) was 48 bytes ago --- */
	int                        fd;                   /*   368     4 */
	char                       down_script[1024];    /*   372  1024 */
	/* --- cacheline 21 boundary (1344 bytes) was 52 bytes ago --- */
	char                       down_script_arg[128]; /*  1396   128 */
	/* --- cacheline 23 boundary (1472 bytes) was 52 bytes ago --- */
	uint8_t                    buf[69632];           /*  1524 69632 */
	/* --- cacheline 1111 boundary (71104 bytes) was 52 bytes ago --- */
	_Bool                      read_poll;            /* 71156     1 */
	_Bool                      write_poll;           /* 71157     1 */
	_Bool                      using_vnet_hdr;       /* 71158     1 */
	_Bool                      has_ufo;              /* 71159     1 */
	_Bool                      enabled;              /* 71160     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1112 boundary (71168 bytes) --- */
	VHostNetState *            vhost_net;            /* 71168     8 */
	unsigned int               host_vnet_hdr_len;    /* 71176     4 */

	/* XXX 4 bytes hole, try to pack */

	Notifier                   exit;                 /* 71184    24 */

	/* size: 71208, cachelines: 1113, members: 13 */
	/* sum members: 71197, holes: 2, sum holes: 11 */
	/* last cacheline: 40 bytes */
};
struct VhostUserState {
	NetClientState             nc;                   /*     0   368 */
	/* --- cacheline 5 boundary (320 bytes) was 48 bytes ago --- */
	CharBackend                chr;                  /*   368    48 */
	/* --- cacheline 6 boundary (384 bytes) was 32 bytes ago --- */
	VHostNetState *            vhost_net;            /*   416     8 */
	guint                      watch;                /*   424     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   acked_features;       /*   432     8 */
	_Bool                      started;              /*   440     1 */

	/* size: 448, cachelines: 7, members: 6 */
	/* sum members: 437, holes: 1, sum holes: 4 */
	/* padding: 7 */
};
struct ifmap {
	long unsigned int          mem_start;            /*     0     8 */
	long unsigned int          mem_end;              /*     8     8 */
	short unsigned int         base_addr;            /*    16     2 */
	unsigned char              irq;                  /*    18     1 */
	unsigned char              dma;                  /*    19     1 */
	unsigned char              port;                 /*    20     1 */

	/* size: 24, cachelines: 1, members: 6 */
	/* padding: 3 */
	/* last cacheline: 24 bytes */
};
struct ifreq {
	union {
		char               ifrn_name[16];        /*     0    16 */
	} ifr_ifrn;                                      /*     0    16 */
	union {
		struct sockaddr    ifru_addr;            /*    16    16 */
		struct sockaddr    ifru_dstaddr;         /*    16    16 */
		struct sockaddr    ifru_broadaddr;       /*    16    16 */
		struct sockaddr    ifru_netmask;         /*    16    16 */
		struct sockaddr    ifru_hwaddr;          /*    16    16 */
		short int          ifru_flags;           /*    16     2 */
		int                ifru_ivalue;          /*    16     4 */
		int                ifru_mtu;             /*    16     4 */
		struct ifmap       ifru_map;             /*    16    24 */
		char               ifru_slave[16];       /*    16    16 */
		char               ifru_newname[16];     /*    16    16 */
		__caddr_t          ifru_data;            /*    16     8 */
	} ifr_ifru;                                      /*    16    24 */

	/* size: 40, cachelines: 1, members: 2 */
	/* last cacheline: 40 bytes */
};
struct slirp_config_str {
	struct slirp_config_str *  next;                 /*     0     8 */
	int                        flags;                /*     8     4 */
	char                       str[1024];            /*    12  1024 */
	/* --- cacheline 16 boundary (1024 bytes) was 12 bytes ago --- */
	int                        legacy_format;        /*  1036     4 */

	/* size: 1040, cachelines: 17, members: 4 */
	/* last cacheline: 16 bytes */
};
struct SlirpState {
	NetClientState             nc;                   /*     0   368 */
	/* --- cacheline 5 boundary (320 bytes) was 48 bytes ago --- */
	struct {
		struct SlirpState * tqe_next;            /*   368     8 */
		struct SlirpState * * tqe_prev;          /*   376     8 */
	} entry;                                         /*   368    16 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	Slirp *                    slirp;                /*   384     8 */
	Notifier                   exit_notifier;        /*   392    24 */
	char                       smb_dir[128];         /*   416   128 */

	/* size: 544, cachelines: 9, members: 5 */
	/* last cacheline: 32 bytes */
};
struct slirp_stacks {
	struct SlirpState *        tqh_first;            /*     0     8 */
	struct SlirpState * *      tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct GuestFwd {
	CharBackend                hd;                   /*     0    48 */
	struct in_addr             server;               /*    48     4 */
	int                        port;                 /*    52     4 */
	Slirp *                    slirp;                /*    56     8 */

	/* size: 64, cachelines: 1, members: 4 */
};
struct FilterBufferState {
	NetFilterState             parent_obj;           /*     0    80 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	NetQueue *                 incoming_queue;       /*    80     8 */
	uint32_t                   interval;             /*    88     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUTimer                  release_timer;        /*    96    48 */

	/* size: 144, cachelines: 3, members: 4 */
	/* sum members: 140, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct MirrorState {
	NetFilterState             parent_obj;           /*     0    80 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	char *                     indev;                /*    80     8 */
	char *                     outdev;               /*    88     8 */
	CharBackend                chr_in;               /*    96    48 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	CharBackend                chr_out;              /*   144    48 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	SocketReadState            rs;                   /*   192 69656 */

	/* size: 69848, cachelines: 1092, members: 6 */
	/* last cacheline: 24 bytes */
};
struct ip {
	uint8_t                    ip_hl:4;              /*     0: 0  1 */
	uint8_t                    ip_v:4;               /*     0: 4  1 */
	uint8_t                    ip_tos;               /*     1     1 */
	uint16_t                   ip_len;               /*     2     2 */
	uint16_t                   ip_id;                /*     4     2 */
	uint16_t                   ip_off;               /*     6     2 */
	uint8_t                    ip_ttl;               /*     8     1 */
	uint8_t                    ip_p;                 /*     9     1 */
	uint16_t                   ip_sum;               /*    10     2 */
	struct in_addr             ip_src;               /*    12     4 */
	struct in_addr             ip_dst;               /*    16     4 */

	/* size: 20, cachelines: 1, members: 11 */
	/* last cacheline: 20 bytes */
};
struct slirp_tcphdr {
	uint16_t                   th_sport;             /*     0     2 */
	uint16_t                   th_dport;             /*     2     2 */
	uint32_t                   th_seq;               /*     4     4 */
	uint32_t                   th_ack;               /*     8     4 */
	uint8_t                    th_x2:4;              /*    12: 0  1 */
	uint8_t                    th_off:4;             /*    12: 4  1 */
	uint8_t                    th_flags;             /*    13     1 */
	uint16_t                   th_win;               /*    14     2 */
	uint16_t                   th_sum;               /*    16     2 */
	uint16_t                   th_urp;               /*    18     2 */

	/* size: 20, cachelines: 1, members: 10 */
	/* last cacheline: 20 bytes */
};
struct Packet {
	void *                     data;                 /*     0     8 */
	union {
		uint8_t *          network_header;       /*     8     8 */
		struct ip *        ip;                   /*     8     8 */
	};                                               /*     8     8 */
	uint8_t *                  transport_header;     /*    16     8 */
	int                        size;                 /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    creation_ms;          /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct ConnectionKey {
	struct in_addr             src;                  /*     0     4 */
	struct in_addr             dst;                  /*     4     4 */
	uint16_t                   src_port;             /*     8     2 */
	uint16_t                   dst_port;             /*    10     2 */
	uint8_t                    ip_proto;             /*    12     1 */

	/* size: 13, cachelines: 1, members: 5 */
	/* last cacheline: 13 bytes */
} __attribute__((__packed__));
struct Connection {
	GQueue                     primary_list;         /*     0    24 */
	GQueue                     secondary_list;       /*    24    24 */
	_Bool                      processing;           /*    48     1 */
	uint8_t                    ip_proto;             /*    49     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   offset;               /*    52     4 */
	int                        syn_flag;             /*    56     4 */

	/* size: 64, cachelines: 1, members: 6 */
	/* sum members: 58, holes: 1, sum holes: 2 */
	/* padding: 4 */
};
struct CompareState {
	Object                     parent;               /*     0    40 */
	char *                     pri_indev;            /*    40     8 */
	char *                     sec_indev;            /*    48     8 */
	char *                     outdev;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	CharBackend                chr_pri_in;           /*    64    48 */
	CharBackend                chr_sec_in;           /*   112    48 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	CharBackend                chr_out;              /*   160    48 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	SocketReadState            pri_rs;               /*   208 69656 */
	/* --- cacheline 1091 boundary (69824 bytes) was 40 bytes ago --- */
	SocketReadState            sec_rs;               /* 69864 69656 */
	/* --- cacheline 2180 boundary (139520 bytes) --- */
	GQueue                     conn_list;            /* 139520    24 */
	GHashTable *               connection_track_table; /* 139544     8 */
	QemuThread                 thread;               /* 139552     8 */
	QEMUTimer *                timer;                /* 139560     8 */
	QemuMutex                  timer_check_lock;     /* 139568    40 */

	/* size: 139608, cachelines: 2182, members: 14 */
	/* last cacheline: 24 bytes */
};
struct RewriterState {
	NetFilterState             parent_obj;           /*     0    80 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	NetQueue *                 incoming_queue;       /*    80     8 */
	GHashTable *               connection_track_table; /*    88     8 */

	/* size: 96, cachelines: 2, members: 3 */
	/* last cacheline: 32 bytes */
};
struct ReplayState {
	int64_t                    cached_clock[2];      /*     0    16 */
	uint64_t                   current_step;         /*    16     8 */
	int                        instructions_count;   /*    24     4 */
	unsigned int               data_kind;            /*    28     4 */
	unsigned int               has_unread_data;      /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   file_offset;          /*    40     8 */
	uint64_t                   block_request_id;     /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct Event {
	ReplayAsyncEventKind       event_kind;           /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     opaque;               /*     8     8 */
	void *                     opaque2;              /*    16     8 */
	uint64_t                   id;                   /*    24     8 */
	struct {
		struct Event *     tqe_next;             /*    32     8 */
		struct Event * *   tqe_prev;             /*    40     8 */
	} events;                                        /*    32    16 */

	/* size: 48, cachelines: 1, members: 5 */
	/* sum members: 44, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct CharEvent {
	int                        id;                   /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  buf;                  /*     8     8 */
	size_t                     len;                  /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct Slirp {
	struct {
		struct Slirp *     tqe_next;             /*     0     8 */
		struct Slirp * *   tqe_prev;             /*     8     8 */
	} entry;                                         /*     0    16 */
	u_int                      time_fasttimo;        /*    16     4 */
	u_int                      last_slowtimo;        /*    20     4 */
	_Bool                      do_slowtimo;          /*    24     1 */
	_Bool                      in_enabled;           /*    25     1 */
	_Bool                      in6_enabled;          /*    26     1 */

	/* XXX 1 byte hole, try to pack */

	struct in_addr             vnetwork_addr;        /*    28     4 */
	struct in_addr             vnetwork_mask;        /*    32     4 */
	struct in_addr             vhost_addr;           /*    36     4 */
	struct in6_addr            vprefix_addr6;        /*    40    16 */
	uint8_t                    vprefix_len;          /*    56     1 */

	/* XXX 3 bytes hole, try to pack */

	struct in6_addr            vhost_addr6;          /*    60    16 */
	/* --- cacheline 1 boundary (64 bytes) was 12 bytes ago --- */
	struct in_addr             vdhcp_startaddr;      /*    76     4 */
	struct in_addr             vnameserver_addr;     /*    80     4 */
	struct in6_addr            vnameserver_addr6;    /*    84    16 */
	struct in_addr             client_ipaddr;        /*   100     4 */
	char                       client_hostname[33];  /*   104    33 */

	/* XXX 3 bytes hole, try to pack */

	/* --- cacheline 2 boundary (128 bytes) was 12 bytes ago --- */
	int                        restricted;           /*   140     4 */
	struct ex_list *           exec_list;            /*   144     8 */
	struct slirp_quehead       m_freelist;           /*   152    16 */
	struct slirp_quehead       m_usedlist;           /*   168    16 */
	int                        mbuf_alloced;         /*   184     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) --- */
	struct slirp_quehead       if_fastq;             /*   192    16 */
	struct slirp_quehead       if_batchq;            /*   208    16 */
	struct mbuf *              next_m;               /*   224     8 */
	_Bool                      if_start_busy;        /*   232     1 */
	struct ipq                 ipq;                  /*   233    44 */

	/* XXX 1 byte hole, try to pack */

	/* --- cacheline 4 boundary (256 bytes) was 22 bytes ago --- */
	uint16_t                   ip_id;                /*   278     2 */
	BOOTPClient                bootp_clients[16];    /*   280   128 */
	/* --- cacheline 6 boundary (384 bytes) was 24 bytes ago --- */
	char *                     bootp_filename;       /*   408     8 */
	size_t                     vdnssearch_len;       /*   416     8 */
	uint8_t *                  vdnssearch;           /*   424     8 */
	struct socket              tcb;                  /*   432   416 */
	/* --- cacheline 13 boundary (832 bytes) was 16 bytes ago --- */
	struct socket *            tcp_last_so;          /*   848     8 */
	uint32_t                   tcp_iss;              /*   856     4 */
	uint32_t                   tcp_now;              /*   860     4 */
	struct socket              udb;                  /*   864   416 */
	/* --- cacheline 20 boundary (1280 bytes) --- */
	struct socket *            udp_last_so;          /*  1280     8 */
	struct socket              icmp;                 /*  1288   416 */
	/* --- cacheline 26 boundary (1664 bytes) was 40 bytes ago --- */
	struct socket *            icmp_last_so;         /*  1704     8 */
	char *                     tftp_prefix;          /*  1712     8 */
	struct tftp_session        tftp_sessions[20];    /*  1720  3360 */
	/* --- cacheline 79 boundary (5056 bytes) was 24 bytes ago --- */
	ArpTable                   arp_table;            /*  5080   452 */
	/* --- cacheline 86 boundary (5504 bytes) was 28 bytes ago --- */
	NdpTable                   ndp_table;            /*  5532   356 */
	/* --- cacheline 92 boundary (5888 bytes) --- */
	GRand *                    grand;                /*  5888     8 */
	QEMUTimer *                ra_timer;             /*  5896     8 */
	void *                     opaque;               /*  5904     8 */

	/* size: 5912, cachelines: 93, members: 47 */
	/* sum members: 5900, holes: 5, sum holes: 12 */
	/* last cacheline: 24 bytes */
};
struct mbuf_ptr {
	struct mbuf *              mptr;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct mbuf {
	struct mbuf *              m_next;               /*     0     8 */
	struct mbuf *              m_prev;               /*     8     8 */
	struct mbuf *              m_nextpkt;            /*    16     8 */
	struct mbuf *              m_prevpkt;            /*    24     8 */
	int                        m_flags;              /*    32     4 */
	int                        m_size;               /*    36     4 */
	struct socket *            m_so;                 /*    40     8 */
	caddr_t                    m_data;               /*    48     8 */
	int                        m_len;                /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	Slirp *                    slirp;                /*    64     8 */
	_Bool                      resolution_requested; /*    72     1 */

	/* XXX 7 bytes hole, try to pack */

	uint64_t                   expiration_date;      /*    80     8 */
	char *                     m_ext;                /*    88     8 */
	char                       m_dat[];              /*    96     0 */

	/* size: 96, cachelines: 2, members: 14 */
	/* sum members: 85, holes: 2, sum holes: 11 */
	/* last cacheline: 32 bytes */
};
struct qlink {
	void *                     next;                 /*     0     8 */
	void *                     prev;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct ipq {
	struct qlink               frag_link;            /*     0    16 */
	struct qlink               ip_link;              /*    16    16 */
	uint8_t                    ipq_ttl;              /*    32     1 */
	uint8_t                    ipq_p;                /*    33     1 */
	uint16_t                   ipq_id;               /*    34     2 */
	struct in_addr             ipq_src;              /*    36     4 */
	struct in_addr             ipq_dst;              /*    40     4 */

	/* size: 44, cachelines: 1, members: 7 */
	/* last cacheline: 44 bytes */
} __attribute__((__packed__));
struct ip6 {
	uint32_t                   ip_tc_hi:4;           /*     0: 0  4 */
	uint32_t                   ip_v:4;               /*     0: 4  4 */
	uint32_t                   ip_fl_hi:4;           /*     0: 8  4 */
	uint32_t                   ip_tc_lo:4;           /*     0:12  4 */
	uint32_t                   ip_fl_lo:16;          /*     0:16  4 */
	uint16_t                   ip_pl;                /*     4     2 */
	uint8_t                    ip_nh;                /*     6     1 */
	uint8_t                    ip_hl;                /*     7     1 */
	struct in6_addr            ip_src;               /*     8    16 */
	struct in6_addr            ip_dst;               /*    24    16 */

	/* size: 40, cachelines: 1, members: 10 */
	/* last cacheline: 40 bytes */
};
struct ip6_pseudohdr {
	struct in6_addr            ih_src;               /*     0    16 */
	struct in6_addr            ih_dst;               /*    16    16 */
	uint32_t                   ih_pl;                /*    32     4 */
	uint16_t                   ih_zero_hi;           /*    36     2 */
	uint8_t                    ih_zero_lo;           /*    38     1 */
	uint8_t                    ih_nh;                /*    39     1 */

	/* size: 40, cachelines: 1, members: 6 */
	/* last cacheline: 40 bytes */
};
struct tcpiphdr {
	struct mbuf_ptr            ih_mbuf;              /*     0     8 */
	union {
		struct {
			struct in_addr ih_src;           /*     8     4 */
			struct in_addr ih_dst;           /*    12     4 */
			uint8_t    ih_x1;                /*    16     1 */
			uint8_t    ih_pr;                /*    17     1 */
		} ti_i4;                                 /*     8    12 */
		struct {
			struct in6_addr ih_src;          /*     8    16 */
			struct in6_addr ih_dst;          /*    24    16 */
			uint8_t    ih_x1;                /*    40     1 */
			uint8_t    ih_nh;                /*    41     1 */
		} ti_i6;                                 /*     8    36 */
	} ti;                                            /*     8    36 */
	uint16_t                   ti_x0;                /*    44     2 */
	uint16_t                   ti_len;               /*    46     2 */
	struct slirp_tcphdr        ti_t;                 /*    48    20 */

	/* size: 68, cachelines: 2, members: 5 */
	/* last cacheline: 4 bytes */
} __attribute__((__packed__));
struct tcpcb {
	struct tcpiphdr *          seg_next;             /*     0     8 */
	struct tcpiphdr *          seg_prev;             /*     8     8 */
	short int                  t_state;              /*    16     2 */
	short int                  t_timer[4];           /*    18     8 */
	short int                  t_rxtshift;           /*    26     2 */
	short int                  t_rxtcur;             /*    28     2 */
	short int                  t_dupacks;            /*    30     2 */
	u_short                    t_maxseg;             /*    32     2 */
	char                       t_force;              /*    34     1 */

	/* XXX 1 byte hole, try to pack */

	u_short                    t_flags;              /*    36     2 */

	/* XXX 2 bytes hole, try to pack */

	struct tcpiphdr            t_template;           /*    40    68 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) was 48 bytes ago --- */
	struct socket *            t_socket;             /*   112     8 */
	uint32_t                   snd_una;              /*   120     4 */
	uint32_t                   snd_nxt;              /*   124     4 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint32_t                   snd_up;               /*   128     4 */
	uint32_t                   snd_wl1;              /*   132     4 */
	uint32_t                   snd_wl2;              /*   136     4 */
	uint32_t                   iss;                  /*   140     4 */
	uint32_t                   snd_wnd;              /*   144     4 */
	uint32_t                   rcv_wnd;              /*   148     4 */
	uint32_t                   rcv_nxt;              /*   152     4 */
	uint32_t                   rcv_up;               /*   156     4 */
	uint32_t                   irs;                  /*   160     4 */
	uint32_t                   rcv_adv;              /*   164     4 */
	uint32_t                   snd_max;              /*   168     4 */
	uint32_t                   snd_cwnd;             /*   172     4 */
	uint32_t                   snd_ssthresh;         /*   176     4 */
	short int                  t_idle;               /*   180     2 */
	short int                  t_rtt;                /*   182     2 */
	uint32_t                   t_rtseq;              /*   184     4 */
	short int                  t_srtt;               /*   188     2 */
	short int                  t_rttvar;             /*   190     2 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	u_short                    t_rttmin;             /*   192     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   max_sndwnd;           /*   196     4 */
	char                       t_oobflags;           /*   200     1 */
	char                       t_iobc;               /*   201     1 */
	short int                  t_softerror;          /*   202     2 */
	u_char                     snd_scale;            /*   204     1 */
	u_char                     rcv_scale;            /*   205     1 */
	u_char                     request_r_scale;      /*   206     1 */
	u_char                     requested_s_scale;    /*   207     1 */
	uint32_t                   ts_recent;            /*   208     4 */
	uint32_t                   ts_recent_age;        /*   212     4 */
	uint32_t                   last_ack_sent;        /*   216     4 */

	/* size: 224, cachelines: 4, members: 44 */
	/* sum members: 211, holes: 4, sum holes: 9 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct socket {
	struct socket *            so_next;              /*     0     8 */
	struct socket *            so_prev;              /*     8     8 */
	int                        s;                    /*    16     4 */
	int                        pollfds_idx;          /*    20     4 */
	Slirp *                    slirp;                /*    24     8 */
	struct mbuf *              so_m;                 /*    32     8 */
	struct tcpiphdr *          so_ti;                /*    40     8 */
	int                        so_urgc;              /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		struct sockaddr_storage ss;              /*    56   128 */
		struct sockaddr_in sin;                  /*    56    16 */
		struct sockaddr_in6 sin6;                /*    56    28 */
	} fhost;                                         /*    56   128 */
	/* --- cacheline 2 boundary (128 bytes) was 56 bytes ago --- */
	union {
		struct sockaddr_storage ss;              /*   184   128 */
		struct sockaddr_in sin;                  /*   184    16 */
		struct sockaddr_in6 sin6;                /*   184    28 */
	} lhost;                                         /*   184   128 */
	/* --- cacheline 4 boundary (256 bytes) was 56 bytes ago --- */
	uint8_t                    so_iptos;             /*   312     1 */
	uint8_t                    so_emu;               /*   313     1 */
	u_char                     so_type;              /*   314     1 */

	/* XXX 1 byte hole, try to pack */

	int                        so_state;             /*   316     4 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	struct tcpcb *             so_tcpcb;             /*   320     8 */
	u_int                      so_expire;            /*   328     4 */
	int                        so_queued;            /*   332     4 */
	int                        so_nqueued;           /*   336     4 */

	/* XXX 4 bytes hole, try to pack */

	struct sbuf                so_rcv;               /*   344    32 */
	struct sbuf                so_snd;               /*   376    32 */
	/* --- cacheline 6 boundary (384 bytes) was 24 bytes ago --- */
	void *                     extra;                /*   408     8 */

	/* size: 416, cachelines: 7, members: 21 */
	/* sum members: 407, holes: 3, sum holes: 9 */
	/* last cacheline: 32 bytes */
};
struct sbuf {
	u_int                      sb_cc;                /*     0     4 */
	u_int                      sb_datalen;           /*     4     4 */
	char *                     sb_wptr;              /*     8     8 */
	char *                     sb_rptr;              /*    16     8 */
	char *                     sb_data;              /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct ex_list {
	int                        ex_pty;               /*     0     4 */
	struct in_addr             ex_addr;              /*     4     4 */
	int                        ex_fport;             /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              ex_exec;              /*    16     8 */
	struct ex_list *           ex_next;              /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 28, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct slirp_quehead {
	struct slirp_quehead *     qh_link;              /*     0     8 */
	struct slirp_quehead *     qh_rlink;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct tftp_session {
	Slirp *                    slirp;                /*     0     8 */
	char *                     filename;             /*     8     8 */
	int                        fd;                   /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	struct sockaddr_storage    client_addr;          /*    24   128 */
	/* --- cacheline 2 boundary (128 bytes) was 24 bytes ago --- */
	uint16_t                   client_port;          /*   152     2 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   block_nr;             /*   156     4 */
	int                        timestamp;            /*   160     4 */

	/* size: 168, cachelines: 3, members: 7 */
	/* sum members: 158, holes: 2, sum holes: 6 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct slirp_arphdr {
	short unsigned int         ar_hrd;               /*     0     2 */
	short unsigned int         ar_pro;               /*     2     2 */
	unsigned char              ar_hln;               /*     4     1 */
	unsigned char              ar_pln;               /*     5     1 */
	short unsigned int         ar_op;                /*     6     2 */
	unsigned char              ar_sha[6];            /*     8     6 */
	uint32_t                   ar_sip;               /*    14     4 */
	unsigned char              ar_tha[6];            /*    18     6 */
	uint32_t                   ar_tip;               /*    24     4 */

	/* size: 28, cachelines: 1, members: 9 */
	/* last cacheline: 28 bytes */
} __attribute__((__packed__));
struct ArpTable {
	struct slirp_arphdr        table[16];            /*     0   448 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	int                        next_victim;          /*   448     4 */

	/* size: 452, cachelines: 8, members: 2 */
	/* last cacheline: 4 bytes */
};
struct ndpentry {
	unsigned char              eth_addr[6];          /*     0     6 */
	struct in6_addr            ip_addr;              /*     6    16 */

	/* size: 22, cachelines: 1, members: 2 */
	/* last cacheline: 22 bytes */
} __attribute__((__packed__));
struct NdpTable {
	struct ndpentry            table[16];            /*     0   352 */
	/* --- cacheline 5 boundary (320 bytes) was 32 bytes ago --- */
	int                        next_victim;          /*   352     4 */

	/* size: 356, cachelines: 6, members: 2 */
	/* last cacheline: 36 bytes */
};
struct ih_idseq {
	u_short                    icd_id;               /*     0     2 */
	u_short                    icd_seq;              /*     2     2 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
struct ih_pmtu {
	u_short                    ipm_void;             /*     0     2 */
	u_short                    ipm_nextmtu;          /*     2     2 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
struct id_ts {
	n_time                     its_otime;            /*     0     4 */
	n_time                     its_rtime;            /*     4     4 */
	n_time                     its_ttime;            /*     8     4 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
};
struct id_ip {
	struct ip                  idi_ip;               /*     0    20 */

	/* size: 20, cachelines: 1, members: 1 */
	/* last cacheline: 20 bytes */
};
struct icmp {
	u_char                     icmp_type;            /*     0     1 */
	u_char                     icmp_code;            /*     1     1 */
	u_short                    icmp_cksum;           /*     2     2 */
	union {
		u_char             ih_pptr;              /*     4     1 */
		struct in_addr     ih_gwaddr;            /*     4     4 */
		struct ih_idseq    ih_idseq;             /*     4     4 */
		int                ih_void;              /*     4     4 */
		struct ih_pmtu     ih_pmtu;              /*     4     4 */
	} icmp_hun;                                      /*     4     4 */
	union {
		struct id_ts       id_ts;                /*     8    12 */
		struct id_ip       id_ip;                /*     8    20 */
		uint32_t           id_mask;              /*     8     4 */
		char               id_data[1];           /*     8     1 */
	} icmp_dun;                                      /*     8    20 */

	/* size: 28, cachelines: 1, members: 5 */
	/* last cacheline: 28 bytes */
};
struct icmp6_echo {
	uint16_t                   id;                   /*     0     2 */
	uint16_t                   seq_num;              /*     2     2 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
union icmp6_error_body {
	uint32_t                   unused;             /*     0     4 */
	uint32_t                   pointer;            /*     0     4 */
	uint32_t                   mtu;                /*     0     4 */
};
struct ndp_rs {
	uint32_t                   reserved;             /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct ndp_ra {
	uint8_t                    chl;                  /*     0     1 */
	uint8_t                    reserved:6;           /*     1: 0  1 */
	uint8_t                    O:1;                  /*     1: 6  1 */
	uint8_t                    M:1;                  /*     1: 7  1 */
	uint16_t                   lifetime;             /*     2     2 */
	uint32_t                   reach_time;           /*     4     4 */
	uint32_t                   retrans_time;         /*     8     4 */

	/* size: 12, cachelines: 1, members: 7 */
	/* last cacheline: 12 bytes */
};
struct ndp_ns {
	uint32_t                   reserved;             /*     0     4 */
	struct in6_addr            target;               /*     4    16 */

	/* size: 20, cachelines: 1, members: 2 */
	/* last cacheline: 20 bytes */
};
struct ndp_na {
	uint32_t                   reserved_hi:5;        /*     0: 0  4 */
	uint32_t                   O:1;                  /*     0: 5  4 */
	uint32_t                   S:1;                  /*     0: 6  4 */
	uint32_t                   R:1;                  /*     0: 7  4 */
	uint32_t                   reserved_lo:24;       /*     0: 8  4 */
	struct in6_addr            target;               /*     4    16 */

	/* size: 20, cachelines: 1, members: 6 */
	/* last cacheline: 20 bytes */
};
struct ndp_redirect {
	uint32_t                   reserved;             /*     0     4 */
	struct in6_addr            target;               /*     4    16 */
	struct in6_addr            dest;                 /*    20    16 */

	/* size: 36, cachelines: 1, members: 3 */
	/* last cacheline: 36 bytes */
};
struct icmp6 {
	uint8_t                    icmp6_type;           /*     0     1 */
	uint8_t                    icmp6_code;           /*     1     1 */
	uint16_t                   icmp6_cksum;          /*     2     2 */
	union {
		union icmp6_error_body error_body;       /*     4     4 */
		struct icmp6_echo  echo;                 /*     4     4 */
		struct ndp_rs      ndp_rs;               /*     4     4 */
		struct ndp_ra      ndp_ra;               /*     4    12 */
		struct ndp_ns      ndp_ns;               /*     4    20 */
		struct ndp_na      ndp_na;               /*     4    20 */
		struct ndp_redirect ndp_redirect;        /*     4    36 */
	} icmp6_body;                                    /*     4    36 */

	/* size: 40, cachelines: 1, members: 4 */
	/* last cacheline: 40 bytes */
};
struct prefixinfo {
	uint8_t                    prefix_length;        /*     0     1 */
	uint8_t                    reserved1:6;          /*     1: 0  1 */
	uint8_t                    A:1;                  /*     1: 6  1 */
	uint8_t                    L:1;                  /*     1: 7  1 */
	uint32_t                   valid_lt;             /*     2     4 */
	uint32_t                   pref_lt;              /*     6     4 */
	uint32_t                   reserved2;            /*    10     4 */
	struct in6_addr            prefix;               /*    14    16 */

	/* size: 30, cachelines: 1, members: 8 */
	/* last cacheline: 30 bytes */
} __attribute__((__packed__));
struct rdnss {
	uint16_t                   reserved;             /*     0     2 */
	uint32_t                   lifetime;             /*     2     4 */
	struct in6_addr            addr;                 /*     6    16 */

	/* size: 22, cachelines: 1, members: 3 */
	/* last cacheline: 22 bytes */
} __attribute__((__packed__));
struct ndpopt {
	uint8_t                    ndpopt_type;          /*     0     1 */
	uint8_t                    ndpopt_len;           /*     1     1 */
	union {
		unsigned char      linklayer_addr[6];    /*     2     6 */
		struct prefixinfo  prefixinfo;           /*     2    30 */
		struct rdnss       rdnss;                /*     2    22 */
	} ndpopt_body;                                   /*     2    30 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
} __attribute__((__packed__));
struct ethhdr {
	unsigned char              h_dest[6];            /*     0     6 */
	unsigned char              h_source[6];          /*     6     6 */
	short unsigned int         h_proto;              /*    12     2 */

	/* size: 14, cachelines: 1, members: 3 */
	/* last cacheline: 14 bytes */
};
struct ipasfrag {
	struct qlink               ipf_link;             /*     0    16 */
	struct ip                  ipf_ip;               /*    16    20 */

	/* size: 36, cachelines: 1, members: 2 */
	/* last cacheline: 36 bytes */
} __attribute__((__packed__));
struct compact_domain {
	struct compact_domain *    self;                 /*     0     8 */
	struct compact_domain *    refdom;               /*     8     8 */
	uint8_t *                  labels;               /*    16     8 */
	size_t                     len;                  /*    24     8 */
	size_t                     common_octets;        /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct requested_infos {
	uint8_t *                  client_id;            /*     0     8 */
	int                        client_id_len;        /*     8     4 */
	_Bool                      want_dns;             /*    12     1 */
	_Bool                      want_boot_url;        /*    13     1 */

	/* size: 16, cachelines: 1, members: 4 */
	/* padding: 2 */
	/* last cacheline: 16 bytes */
};
struct slirp_instances {
	struct Slirp *             tqh_first;            /*     0     8 */
	struct Slirp * *           tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct tcpiphdr_2 {
	struct tcpiphdr            dummy;                /*     0    68 */
	/* --- cacheline 1 boundary (64 bytes) was 4 bytes ago --- */
	char                       first_char;           /*    68     1 */

	/* size: 72, cachelines: 2, members: 2 */
	/* padding: 3 */
	/* last cacheline: 8 bytes */
};
struct tos_t {
	uint16_t                   lport;                /*     0     2 */
	uint16_t                   fport;                /*     2     2 */
	uint8_t                    tos;                  /*     4     1 */
	uint8_t                    emu;                  /*     5     1 */

	/* size: 6, cachelines: 1, members: 4 */
	/* last cacheline: 6 bytes */
};
struct emu_t {
	uint16_t                   lport;                /*     0     2 */
	uint16_t                   fport;                /*     2     2 */
	uint8_t                    tos;                  /*     4     1 */
	uint8_t                    emu;                  /*     5     1 */

	/* XXX 2 bytes hole, try to pack */

	struct emu_t *             next;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 5 */
	/* sum members: 14, holes: 1, sum holes: 2 */
	/* last cacheline: 16 bytes */
};
struct ipovly {
	struct mbuf_ptr            ih_mbuf;              /*     0     8 */
	uint8_t                    ih_x1;                /*     8     1 */
	uint8_t                    ih_pr;                /*     9     1 */
	uint16_t                   ih_len;               /*    10     2 */
	struct in_addr             ih_src;               /*    12     4 */
	struct in_addr             ih_dst;               /*    16     4 */

	/* size: 20, cachelines: 1, members: 6 */
	/* last cacheline: 20 bytes */
} __attribute__((__packed__));
struct udphdr {
	uint16_t                   uh_sport;             /*     0     2 */
	uint16_t                   uh_dport;             /*     2     2 */
	int16_t                    uh_ulen;              /*     4     2 */
	uint16_t                   uh_sum;               /*     6     2 */

	/* size: 8, cachelines: 1, members: 4 */
	/* last cacheline: 8 bytes */
};
struct udpiphdr {
	struct ipovly              ui_i;                 /*     0    20 */
	struct udphdr              ui_u;                 /*    20     8 */

	/* size: 28, cachelines: 1, members: 2 */
	/* last cacheline: 28 bytes */
} __attribute__((__packed__));
struct bootp_t {
	struct ip                  ip;                   /*     0    20 */
	struct udphdr              udp;                  /*    20     8 */
	uint8_t                    bp_op;                /*    28     1 */
	uint8_t                    bp_htype;             /*    29     1 */
	uint8_t                    bp_hlen;              /*    30     1 */
	uint8_t                    bp_hops;              /*    31     1 */
	uint32_t                   bp_xid;               /*    32     4 */
	uint16_t                   bp_secs;              /*    36     2 */
	uint16_t                   unused;               /*    38     2 */
	struct in_addr             bp_ciaddr;            /*    40     4 */
	struct in_addr             bp_yiaddr;            /*    44     4 */
	struct in_addr             bp_siaddr;            /*    48     4 */
	struct in_addr             bp_giaddr;            /*    52     4 */
	uint8_t                    bp_hwaddr[16];        /*    56    16 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	uint8_t                    bp_sname[64];         /*    72    64 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	uint8_t                    bp_file[128];         /*   136   128 */
	/* --- cacheline 4 boundary (256 bytes) was 8 bytes ago --- */
	uint8_t                    bp_vend[312];         /*   264   312 */

	/* size: 576, cachelines: 9, members: 17 */
};
struct tftp_t {
	struct udphdr              udp;                  /*     0     8 */
	uint16_t                   tp_op;                /*     8     2 */
	union {
		struct {
			uint16_t   tp_block_nr;          /*    10     2 */
			uint8_t    tp_buf[512];          /*    12   512 */
		} tp_data;                               /*    10   514 */
		struct {
			uint16_t   tp_error_code;        /*    10     2 */
			uint8_t    tp_msg[512];          /*    12   512 */
		} tp_error;                              /*    10   514 */
		char               tp_buf[514];          /*    10   514 */
	} x;                                             /*    10   514 */

	/* size: 524, cachelines: 9, members: 3 */
	/* last cacheline: 12 bytes */
};
struct key_range {
	int                        start;                /*     0     4 */
	int                        end;                  /*     4     4 */
	struct key_range *         next;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct DisplayChangeListener {
	uint64_t                   update_interval;      /*     0     8 */
	const DisplayChangeListenerOps  * ops;           /*     8     8 */
	DisplayState *             ds;                   /*    16     8 */
	QemuConsole *              con;                  /*    24     8 */
	struct {
		struct DisplayChangeListener * le_next;  /*    32     8 */
		struct DisplayChangeListener * * le_prev; /*    40     8 */
	} next;                                          /*    32    16 */

	/* size: 48, cachelines: 1, members: 5 */
	/* last cacheline: 48 bytes */
};
struct DisplayState {
	QEMUTimer *                gui_timer;            /*     0     8 */
	uint64_t                   last_update;          /*     8     8 */
	uint64_t                   update_interval;      /*    16     8 */
	_Bool                      refreshing;           /*    24     1 */
	_Bool                      have_gfx;             /*    25     1 */
	_Bool                      have_text;            /*    26     1 */

	/* XXX 5 bytes hole, try to pack */

	struct {
		struct DisplayChangeListener * lh_first; /*    32     8 */
	} listeners;                                     /*    32     8 */

	/* size: 40, cachelines: 1, members: 7 */
	/* sum members: 35, holes: 1, sum holes: 5 */
	/* last cacheline: 40 bytes */
};
struct QemuConsole {
	Object                     parent;               /*     0    40 */
	int                        index;                /*    40     4 */
	console_type_t             console_type;         /*    44     4 */
	DisplayState *             ds;                   /*    48     8 */
	DisplaySurface *           surface;              /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        dcls;                 /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	DisplayChangeListener *    gl;                   /*    72     8 */
	_Bool                      gl_block;             /*    80     1 */

	/* XXX 7 bytes hole, try to pack */

	Object *                   device;               /*    88     8 */
	uint32_t                   head;                 /*    96     4 */
	QemuUIInfo                 ui_info;              /*   100    16 */

	/* XXX 4 bytes hole, try to pack */

	QEMUTimer *                ui_timer;             /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	const GraphicHwOps  *      hw_ops;               /*   128     8 */
	void *                     hw;                   /*   136     8 */
	int                        width;                /*   144     4 */
	int                        height;               /*   148     4 */
	int                        total_height;         /*   152     4 */
	int                        backscroll_height;    /*   156     4 */
	int                        x;                    /*   160     4 */
	int                        y;                    /*   164     4 */
	int                        x_saved;              /*   168     4 */
	int                        y_saved;              /*   172     4 */
	int                        y_displayed;          /*   176     4 */
	int                        y_base;               /*   180     4 */
	TextAttributes             t_attrib_default;     /*   184     2 */
	TextAttributes             t_attrib;             /*   186     2 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) --- */
	TextCell *                 cells;                /*   192     8 */
	int                        text_x[2];            /*   200     8 */
	int                        text_y[2];            /*   208     8 */
	int                        cursor_invalidate;    /*   216     4 */
	int                        echo;                 /*   220     4 */
	int                        update_x0;            /*   224     4 */
	int                        update_y0;            /*   228     4 */
	int                        update_x1;            /*   232     4 */
	int                        update_y1;            /*   236     4 */
	enum TTYState              state;                /*   240     4 */
	int                        esc_params[3];        /*   244    12 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	int                        nb_esc_params;        /*   256     4 */

	/* XXX 4 bytes hole, try to pack */

	CharDriverState *          chr;                  /*   264     8 */
	QEMUFIFO                   out_fifo;             /*   272    24 */
	uint8_t                    out_fifo_buf[16];     /*   296    16 */
	QEMUTimer *                kbd_timer;            /*   312     8 */

	/* size: 320, cachelines: 5, members: 42 */
	/* sum members: 297, holes: 5, sum holes: 23 */
};
struct pixman_color {
	uint16_t                   red;                  /*     0     2 */
	uint16_t                   green;                /*     2     2 */
	uint16_t                   blue;                 /*     4     2 */
	uint16_t                   alpha;                /*     6     2 */

	/* size: 8, cachelines: 1, members: 4 */
	/* last cacheline: 8 bytes */
};
struct pixman_rectangle16 {
	int16_t                    x;                    /*     0     2 */
	int16_t                    y;                    /*     2     2 */
	uint16_t                   width;                /*     4     2 */
	uint16_t                   height;               /*     6     2 */

	/* size: 8, cachelines: 1, members: 4 */
	/* last cacheline: 8 bytes */
};
struct QEMUGLParams {
	int                        major_ver;            /*     0     4 */
	int                        minor_ver;            /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct DisplayChangeListenerOps {
	const char  *              dpy_name;             /*     0     8 */
	void                       (*dpy_refresh)(DisplayChangeListener *); /*     8     8 */
	void                       (*dpy_gfx_update)(DisplayChangeListener *, int, int, int, int); /*    16     8 */
	void                       (*dpy_gfx_switch)(DisplayChangeListener *, struct DisplaySurface *); /*    24     8 */
	_Bool                      (*dpy_gfx_check_format)(DisplayChangeListener *, pixman_format_code_t); /*    32     8 */
	void                       (*dpy_text_cursor)(DisplayChangeListener *, int, int); /*    40     8 */
	void                       (*dpy_text_resize)(DisplayChangeListener *, int, int); /*    48     8 */
	void                       (*dpy_text_update)(DisplayChangeListener *, int, int, int, int); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*dpy_mouse_set)(DisplayChangeListener *, int, int, int); /*    64     8 */
	void                       (*dpy_cursor_define)(DisplayChangeListener *, QEMUCursor *); /*    72     8 */
	QEMUGLContext              (*dpy_gl_ctx_create)(DisplayChangeListener *, QEMUGLParams *); /*    80     8 */
	void                       (*dpy_gl_ctx_destroy)(DisplayChangeListener *, QEMUGLContext); /*    88     8 */
	int                        (*dpy_gl_ctx_make_current)(DisplayChangeListener *, QEMUGLContext); /*    96     8 */
	QEMUGLContext              (*dpy_gl_ctx_get_current)(DisplayChangeListener *); /*   104     8 */
	void                       (*dpy_gl_scanout)(DisplayChangeListener *, uint32_t, _Bool, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t); /*   112     8 */
	void                       (*dpy_gl_update)(DisplayChangeListener *, uint32_t, uint32_t, uint32_t, uint32_t); /*   120     8 */

	/* size: 128, cachelines: 2, members: 16 */
};
struct TextAttributes {
	uint8_t                    fgcol:4;              /*     0: 0  1 */
	uint8_t                    bgcol:4;              /*     0: 4  1 */
	uint8_t                    bold:1;               /*     1: 0  1 */
	uint8_t                    uline:1;              /*     1: 1  1 */
	uint8_t                    blink:1;              /*     1: 2  1 */
	uint8_t                    invers:1;             /*     1: 3  1 */
	uint8_t                    unvisible:1;          /*     1: 4  1 */

	/* size: 2, cachelines: 1, members: 7 */
	/* bit_padding: 3 bits */
	/* last cacheline: 2 bytes */
};
struct TextCell {
	uint8_t                    ch;                   /*     0     1 */
	TextAttributes             t_attrib;             /*     1     2 */

	/* size: 3, cachelines: 1, members: 2 */
	/* last cacheline: 3 bytes */
};
struct QEMUFIFO {
	uint8_t *                  buf;                  /*     0     8 */
	int                        buf_size;             /*     8     4 */
	int                        count;                /*    12     4 */
	int                        wptr;                 /*    16     4 */
	int                        rptr;                 /*    20     4 */

	/* size: 24, cachelines: 1, members: 5 */
	/* last cacheline: 24 bytes */
};
struct QemuInputHandlerState {
	DeviceState *              dev;                  /*     0     8 */
	QemuInputHandler *         handler;              /*     8     8 */
	int                        id;                   /*    16     4 */
	int                        events;               /*    20     4 */
	QemuConsole *              con;                  /*    24     8 */
	struct {
		struct QemuInputHandlerState * tqe_next; /*    32     8 */
		struct QemuInputHandlerState * * tqe_prev; /*    40     8 */
	} node;                                          /*    32    16 */

	/* size: 48, cachelines: 1, members: 6 */
	/* last cacheline: 48 bytes */
};
struct QemuInputEventQueue {
	enum {
		QEMU_INPUT_QUEUE_DELAY = 1,
		QEMU_INPUT_QUEUE_EVENT = 2,
		QEMU_INPUT_QUEUE_SYNC = 3,
	} type;                                          /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUTimer *                timer;                /*     8     8 */
	uint32_t                   delay_ms;             /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	QemuConsole *              src;                  /*    24     8 */
	InputEvent *               evt;                  /*    32     8 */
	struct {
		struct QemuInputEventQueue * tqe_next;   /*    40     8 */
		struct QemuInputEventQueue * * tqe_prev; /*    48     8 */
	} node;                                          /*    40    16 */

	/* size: 56, cachelines: 1, members: 6 */
	/* sum members: 48, holes: 2, sum holes: 8 */
	/* last cacheline: 56 bytes */
};
struct QemuInputEventQueueHead {
	struct QemuInputEventQueue * tqh_first;          /*     0     8 */
	struct QemuInputEventQueue * * tqh_last;         /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct QEMUPutMouseEntry {
	QEMUPutMouseEvent *        qemu_put_mouse_event; /*     0     8 */
	void *                     qemu_put_mouse_event_opaque; /*     8     8 */
	int                        qemu_put_mouse_event_absolute; /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	QemuInputHandler           h;                    /*    24    32 */
	QemuInputHandlerState *    s;                    /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        axis[2];              /*    64     8 */
	int                        buttons;              /*    72     4 */

	/* size: 80, cachelines: 2, members: 7 */
	/* sum members: 72, holes: 1, sum holes: 4 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct QEMUPutKbdEntry {
	QEMUPutKBDEvent *          put_kbd;              /*     0     8 */
	void *                     opaque;               /*     8     8 */
	QemuInputHandlerState *    s;                    /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct QEMUPutLEDEntry {
	QEMUPutLEDEvent *          put_led;              /*     0     8 */
	void *                     opaque;               /*     8     8 */
	struct {
		struct QEMUPutLEDEntry * tqe_next;       /*    16     8 */
		struct QEMUPutLEDEntry * * tqe_prev;     /*    24     8 */
	} next;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct InputLinux {
	Object                     parent;               /*     0    40 */
	char *                     evdev;                /*    40     8 */
	int                        fd;                   /*    48     4 */
	_Bool                      repeat;               /*    52     1 */
	_Bool                      grab_request;         /*    53     1 */
	_Bool                      grab_active;          /*    54     1 */
	_Bool                      grab_all;             /*    55     1 */
	_Bool                      keydown[768];         /*    56   768 */
	/* --- cacheline 12 boundary (768 bytes) was 56 bytes ago --- */
	int                        keycount;             /*   824     4 */
	int                        wheel;                /*   828     4 */
	/* --- cacheline 13 boundary (832 bytes) --- */
	_Bool                      initialized;          /*   832     1 */
	_Bool                      has_rel_x;            /*   833     1 */
	_Bool                      has_abs_x;            /*   834     1 */

	/* XXX 1 byte hole, try to pack */

	int                        num_keys;             /*   836     4 */
	int                        num_btns;             /*   840     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct InputLinux * tqe_next;            /*   848     8 */
		struct InputLinux * * tqe_prev;          /*   856     8 */
	} next;                                          /*   848    16 */

	/* size: 864, cachelines: 14, members: 16 */
	/* sum members: 859, holes: 2, sum holes: 5 */
	/* last cacheline: 32 bytes */
};
struct VncServerInfo {
	char *                     host;                 /*     0     8 */
	char *                     service;              /*     8     8 */
	NetworkAddressFamily       family;               /*    16     4 */
	_Bool                      websocket;            /*    20     1 */
	_Bool                      has_auth;             /*    21     1 */

	/* XXX 2 bytes hole, try to pack */

	char *                     auth;                 /*    24     8 */

	/* size: 32, cachelines: 1, members: 6 */
	/* sum members: 30, holes: 1, sum holes: 2 */
	/* last cacheline: 32 bytes */
};
struct Buffer {
	char *                     name;                 /*     0     8 */
	size_t                     capacity;             /*     8     8 */
	size_t                     offset;               /*    16     8 */
	uint64_t                   avg_size;             /*    24     8 */
	uint8_t *                  buffer;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct VncPaletteEntry {
	int                        idx;                  /*     0     4 */
	uint32_t                   color;                /*     4     4 */
	struct {
		struct VncPaletteEntry * le_next;        /*     8     8 */
		struct VncPaletteEntry * * le_prev;      /*    16     8 */
	} next;                                          /*     8    16 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct VncPalette {
	VncPaletteEntry            pool[256];            /*     0  6144 */
	/* --- cacheline 96 boundary (6144 bytes) --- */
	size_t                     size;                 /*  6144     8 */
	size_t                     max;                  /*  6152     8 */
	int                        bpp;                  /*  6160     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct VncPaletteEntry * lh_first;       /*  6168     8 */
	} table[256]; /*  6168  2048 */

	/* size: 8216, cachelines: 129, members: 5 */
	/* sum members: 8212, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct VncState {
	QIOChannelSocket *         sioc;                 /*     0     8 */
	QIOChannel *               ioc;                  /*     8     8 */
	guint                      ioc_tag;              /*    16     4 */
	gboolean                   disconnecting;        /*    20     4 */
	long unsigned int          dirty[2048][3];       /*    24 49152 */
	/* --- cacheline 768 boundary (49152 bytes) was 24 bytes ago --- */
	uint8_t * *                lossy_rect;           /* 49176     8 */
	VncDisplay *               vd;                   /* 49184     8 */
	int                        need_update;          /* 49192     4 */
	int                        force_update;         /* 49196     4 */
	int                        has_dirty;            /* 49200     4 */
	uint32_t                   features;             /* 49204     4 */
	int                        absolute;             /* 49208     4 */
	int                        last_x;               /* 49212     4 */
	/* --- cacheline 769 boundary (49216 bytes) --- */
	int                        last_y;               /* 49216     4 */
	uint32_t                   last_bmask;           /* 49220     4 */
	int                        client_width;         /* 49224     4 */
	int                        client_height;        /* 49228     4 */
	VncShareMode               share_mode;           /* 49232     4 */
	uint32_t                   vnc_encoding;         /* 49236     4 */
	int                        major;                /* 49240     4 */
	int                        minor;                /* 49244     4 */
	int                        auth;                 /* 49248     4 */
	int                        subauth;              /* 49252     4 */
	char                       challenge[16];        /* 49256    16 */
	QCryptoTLSSession *        tls;                  /* 49272     8 */
	/* --- cacheline 770 boundary (49280 bytes) --- */
	_Bool                      encode_ws;            /* 49280     1 */
	_Bool                      websocket;            /* 49281     1 */

	/* XXX 6 bytes hole, try to pack */

	VncClientInfo *            info;                 /* 49288     8 */
	Buffer                     output;               /* 49296    40 */
	Buffer                     input;                /* 49336    40 */
	/* --- cacheline 771 boundary (49344 bytes) was 32 bytes ago --- */
	VncWritePixels *           write_pixels;         /* 49376     8 */
	PixelFormat                client_pf;            /* 49384    32 */
	/* --- cacheline 772 boundary (49408 bytes) was 8 bytes ago --- */
	pixman_format_code_t       client_format;        /* 49416     4 */
	_Bool                      client_be;            /* 49420     1 */

	/* XXX 3 bytes hole, try to pack */

	CaptureVoiceOut *          audio_cap;            /* 49424     8 */
	struct audsettings         as;                   /* 49432    16 */
	VncReadEvent *             read_handler;         /* 49448     8 */
	size_t                     read_handler_expect;  /* 49456     8 */
	uint8_t                    modifiers_state[256]; /* 49464   256 */
	/* --- cacheline 776 boundary (49664 bytes) was 56 bytes ago --- */
	QEMUPutLEDEntry *          led;                  /* 49720     8 */
	/* --- cacheline 777 boundary (49728 bytes) --- */
	_Bool                      abort;                /* 49728     1 */

	/* XXX 7 bytes hole, try to pack */

	QemuMutex                  output_mutex;         /* 49736    40 */
	QEMUBH *                   bh;                   /* 49776     8 */
	Buffer                     jobs_buffer;          /* 49784    40 */
	/* --- cacheline 778 boundary (49792 bytes) was 32 bytes ago --- */
	VncTight                   tight;                /* 49824   632 */
	/* --- cacheline 788 boundary (50432 bytes) was 24 bytes ago --- */
	VncZlib                    zlib;                 /* 50456   200 */
	/* --- cacheline 791 boundary (50624 bytes) was 32 bytes ago --- */
	VncHextile                 hextile;              /* 50656     8 */
	VncZrle                    zrle;                 /* 50664  8496 */
	/* --- cacheline 924 boundary (59136 bytes) was 24 bytes ago --- */
	VncZywrle                  zywrle;               /* 59160 16384 */
	/* --- cacheline 1180 boundary (75520 bytes) was 24 bytes ago --- */
	Notifier                   mouse_mode_notifier;  /* 75544    24 */
	struct {
		struct VncState *  tqe_next;             /* 75568     8 */
		struct VncState * * tqe_prev;            /* 75576     8 */
	} next;                                          /* 75568    16 */

	/* size: 75584, cachelines: 1181, members: 51 */
	/* sum members: 75568, holes: 3, sum holes: 16 */
};
struct VncJob {
	VncState *                 vs;                   /*     0     8 */
	struct {
		struct VncRectEntry * lh_first;          /*     8     8 */
	} rectangles;                                    /*     8     8 */
	struct {
		struct VncJob *    tqe_next;             /*    16     8 */
		struct VncJob * *  tqe_prev;             /*    24     8 */
	} next;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct VncRect {
	int                        x;                    /*     0     4 */
	int                        y;                    /*     4     4 */
	int                        w;                    /*     8     4 */
	int                        h;                    /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct VncRectEntry {
	struct VncRect             rect;                 /*     0    16 */
	struct {
		struct VncRectEntry * le_next;           /*    16     8 */
		struct VncRectEntry * * le_prev;         /*    24     8 */
	} next;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 2 */
	/* last cacheline: 32 bytes */
};
struct VncDisplay {
	struct {
		struct VncState *  tqh_first;            /*     0     8 */
		struct VncState * * tqh_last;            /*     8     8 */
	} clients;                                       /*     0    16 */
	int                        num_connecting;       /*    16     4 */
	int                        num_shared;           /*    20     4 */
	int                        num_exclusive;        /*    24     4 */
	int                        connections_limit;    /*    28     4 */
	VncSharePolicy             share_policy;         /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	QIOChannelSocket *         lsock;                /*    40     8 */
	guint                      lsock_tag;            /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	QIOChannelSocket *         lwebsock;             /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	guint                      lwebsock_tag;         /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	DisplaySurface *           ds;                   /*    72     8 */
	DisplayChangeListener      dcl;                  /*    80    48 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	kbd_layout_t *             kbd_layout;           /*   128     8 */
	int                        lock_key_sync;        /*   136     4 */
	int                        key_delay_ms;         /*   140     4 */
	QemuMutex                  mutex;                /*   144    40 */
	QEMUCursor *               cursor;               /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        cursor_msize;         /*   192     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  cursor_mask;          /*   200     8 */
	struct VncSurface          guest;                /*   208 284704 */

	/* XXX last struct has 4 bytes of padding */

	/* --- cacheline 4451 boundary (284864 bytes) was 48 bytes ago --- */
	pixman_image_t *           server;               /* 284912     8 */
	const char  *              id;                   /* 284920     8 */
	/* --- cacheline 4452 boundary (284928 bytes) --- */
	struct {
		struct VncDisplay * tqe_next;            /* 284928     8 */
		struct VncDisplay * * tqe_prev;          /* 284936     8 */
	} next;                                          /* 284928    16 */
	_Bool                      is_unix;              /* 284944     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     password;             /* 284952     8 */
	time_t                     expires;              /* 284960     8 */
	int                        auth;                 /* 284968     4 */
	int                        subauth;              /* 284972     4 */
	int                        ws_auth;              /* 284976     4 */
	int                        ws_subauth;           /* 284980     4 */
	_Bool                      lossy;                /* 284984     1 */
	_Bool                      non_adaptive;         /* 284985     1 */

	/* XXX 6 bytes hole, try to pack */

	/* --- cacheline 4453 boundary (284992 bytes) --- */
	QCryptoTLSCreds *          tlscreds;             /* 284992     8 */
	char *                     tlsaclname;           /* 285000     8 */

	/* size: 285008, cachelines: 4454, members: 34 */
	/* sum members: 284979, holes: 6, sum holes: 29 */
	/* paddings: 1, sum paddings: 4 */
	/* last cacheline: 16 bytes */
};
struct VncRectStat {
	struct timeval             times[10];            /*     0   160 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	int                        idx;                  /*   160     4 */

	/* XXX 4 bytes hole, try to pack */

	double                     freq;                 /*   168     8 */
	_Bool                      updated;              /*   176     1 */

	/* size: 184, cachelines: 3, members: 4 */
	/* sum members: 173, holes: 1, sum holes: 4 */
	/* padding: 7 */
	/* last cacheline: 56 bytes */
};
struct VncSurface {
	struct timeval             last_freq_check;      /*     0    16 */
	long unsigned int          dirty[2048][3];       /*    16 49152 */
	/* --- cacheline 768 boundary (49152 bytes) was 16 bytes ago --- */
	VncRectStat                stats[32][40];        /* 49168 235520 */
	/* --- cacheline 4448 boundary (284672 bytes) was 16 bytes ago --- */
	pixman_image_t *           fb;                   /* 284688     8 */
	pixman_format_code_t       format;               /* 284696     4 */

	/* size: 284704, cachelines: 4449, members: 5 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct VncTight {
	int                        type;                 /*     0     4 */
	uint8_t                    quality;              /*     4     1 */
	uint8_t                    compression;          /*     5     1 */
	uint8_t                    pixel24;              /*     6     1 */

	/* XXX 1 byte hole, try to pack */

	Buffer                     tight;                /*     8    40 */
	Buffer                     tmp;                  /*    48    40 */
	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	Buffer                     zlib;                 /*    88    40 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	Buffer                     gradient;             /*   128    40 */
	int                        levels[4];            /*   168    16 */
	z_stream                   stream[4];            /*   184   448 */

	/* size: 632, cachelines: 10, members: 10 */
	/* sum members: 631, holes: 1, sum holes: 1 */
	/* last cacheline: 56 bytes */
};
struct VncHextile {
	VncSendHextileTile *       send_tile;            /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct VncZlib {
	Buffer                     zlib;                 /*     0    40 */
	Buffer                     tmp;                  /*    40    40 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	z_stream                   stream;               /*    80   112 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        level;                /*   192     4 */

	/* size: 200, cachelines: 4, members: 4 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
struct VncZrle {
	int                        type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	Buffer                     fb;                   /*     8    40 */
	Buffer                     zrle;                 /*    48    40 */
	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	Buffer                     tmp;                  /*    88    40 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	Buffer                     zlib;                 /*   128    40 */
	z_stream                   stream;               /*   168   112 */
	/* --- cacheline 4 boundary (256 bytes) was 24 bytes ago --- */
	VncPalette                 palette;              /*   280  8216 */

	/* size: 8496, cachelines: 133, members: 7 */
	/* sum members: 8492, holes: 1, sum holes: 4 */
	/* last cacheline: 48 bytes */
};
struct VncZywrle {
	int                        buf[4096];            /*     0 16384 */

	/* size: 16384, cachelines: 256, members: 1 */
};
struct palette_cb_priv {
	VncState *                 vs;                   /*     0     8 */
	uint8_t *                  header;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct QIOChannelWebsock {
	QIOChannel                 parent;               /*     0    56 */
	QIOChannel *               master;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	Buffer                     encinput;             /*    64    40 */
	Buffer                     encoutput;            /*   104    40 */
	/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */
	Buffer                     rawinput;             /*   144    40 */
	Buffer                     rawoutput;            /*   184    40 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	size_t                     payload_remain;       /*   224     8 */
	QIOChannelWebsockMask      mask;                 /*   232     4 */
	guint                      io_tag;               /*   236     4 */
	Error *                    io_err;               /*   240     8 */
	gboolean                   io_eof;               /*   248     4 */

	/* size: 256, cachelines: 4, members: 11 */
	/* padding: 4 */
};
union QIOChannelWebsockMask {
	char                       c[4];               /*     0     4 */
	uint32_t                   u;                  /*     0     4 */
};
struct VncJobQueue {
	QemuCond                   cond;                 /*     0    48 */
	QemuMutex                  mutex;                /*    48    40 */
	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	QemuThread                 thread;               /*    88     8 */
	_Bool                      exit;                 /*    96     1 */

	/* XXX 7 bytes hole, try to pack */

	struct {
		struct VncJob *    tqh_first;            /*   104     8 */
		struct VncJob * *  tqh_last;             /*   112     8 */
	} jobs;                                          /*   104    16 */

	/* size: 120, cachelines: 2, members: 5 */
	/* sum members: 113, holes: 1, sum holes: 7 */
	/* last cacheline: 56 bytes */
};
struct TypeImpl {
	const char  *              name;                 /*     0     8 */
	size_t                     class_size;           /*     8     8 */
	size_t                     instance_size;        /*    16     8 */
	void                       (*class_init)(ObjectClass *, void *); /*    24     8 */
	void                       (*class_base_init)(ObjectClass *, void *); /*    32     8 */
	void                       (*class_finalize)(ObjectClass *, void *); /*    40     8 */
	void *                     class_data;           /*    48     8 */
	void                       (*instance_init)(Object *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*instance_post_init)(Object *); /*    64     8 */
	void                       (*instance_finalize)(Object *); /*    72     8 */
	_Bool                      abstract;             /*    80     1 */

	/* XXX 7 bytes hole, try to pack */

	const char  *              parent;               /*    88     8 */
	TypeImpl *                 parent_type;          /*    96     8 */
	ObjectClass *              class;                /*   104     8 */
	int                        num_interfaces;       /*   112     4 */

	/* XXX 4 bytes hole, try to pack */

	InterfaceImpl              interfaces[32];       /*   120   256 */

	/* size: 376, cachelines: 6, members: 16 */
	/* sum members: 365, holes: 2, sum holes: 11 */
	/* last cacheline: 56 bytes */
};
struct InterfaceImpl {
	const char  *              typename;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct OCFData {
	void                       (*fn)(ObjectClass *, void *); /*     0     8 */
	const char  *              implements_type;      /*     8     8 */
	_Bool                      include_abstract;     /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	void *                     opaque;               /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 25, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct EnumProperty {
	const char  * const *      strings;              /*     0     8 */
	int                        (*get)(Object *, Error * *); /*     8     8 */
	void                       (*set)(Object *, int, Error * *); /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct StringProperty {
	char *                     (*get)(Object *, Error * *); /*     0     8 */
	void                       (*set)(Object *, const char  *, Error * *); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BoolProperty {
	_Bool                      (*get)(Object *, Error * *); /*     0     8 */
	void                       (*set)(Object *, _Bool, Error * *); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct TMProperty {
	void                       (*get)(Object *, struct tm *, Error * *); /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct QEMUBH {
	AioContext *               ctx;                  /*     0     8 */
	QEMUBHFunc *               cb;                   /*     8     8 */
	void *                     opaque;               /*    16     8 */
	QEMUBH *                   next;                 /*    24     8 */
	_Bool                      scheduled;            /*    32     1 */
	_Bool                      idle;                 /*    33     1 */
	_Bool                      deleted;              /*    34     1 */

	/* size: 40, cachelines: 1, members: 7 */
	/* padding: 5 */
	/* last cacheline: 40 bytes */
};
struct ThreadPool {
	AioContext *               ctx;                  /*     0     8 */
	QEMUBH *                   completion_bh;        /*     8     8 */
	QemuMutex                  lock;                 /*    16    40 */
	QemuCond                   worker_stopped;       /*    56    48 */
	/* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */
	QemuSemaphore              sem;                  /*   104    32 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	int                        max_threads;          /*   136     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUBH *                   new_thread_bh;        /*   144     8 */
	struct {
		struct ThreadPoolElement * lh_first;     /*   152     8 */
	} head;                                          /*   152     8 */
	struct {
		struct ThreadPoolElement * tqh_first;    /*   160     8 */
		struct ThreadPoolElement * * tqh_last;   /*   168     8 */
	} request_list;                                  /*   160    16 */
	int                        cur_threads;          /*   176     4 */
	int                        idle_threads;         /*   180     4 */
	int                        new_threads;          /*   184     4 */
	int                        pending_threads;      /*   188     4 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	_Bool                      stopping;             /*   192     1 */

	/* size: 200, cachelines: 4, members: 14 */
	/* sum members: 189, holes: 1, sum holes: 4 */
	/* padding: 7 */
	/* last cacheline: 8 bytes */
};
struct ThreadPoolElement {
	BlockAIOCB                 common;               /*     0    40 */
	ThreadPool *               pool;                 /*    40     8 */
	ThreadPoolFunc *           func;                 /*    48     8 */
	void *                     arg;                  /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	enum ThreadState           state;                /*    64     4 */
	int                        ret;                  /*    68     4 */
	struct {
		struct ThreadPoolElement * tqe_next;     /*    72     8 */
		struct ThreadPoolElement * * tqe_prev;   /*    80     8 */
	} reqs;                                          /*    72    16 */
	struct {
		struct ThreadPoolElement * le_next;      /*    88     8 */
		struct ThreadPoolElement * * le_prev;    /*    96     8 */
	} all;                                           /*    88    16 */

	/* size: 104, cachelines: 2, members: 8 */
	/* last cacheline: 40 bytes */
};
struct ThreadPoolCo {
	Coroutine *                co;                   /*     0     8 */
	int                        ret;                  /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct BlockReopenQueueEntry {
	_Bool                      prepared;             /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	BDRVReopenState            state;                /*     8    40 */
	struct {
		struct BlockReopenQueueEntry * sqe_next; /*    48     8 */
	} entry;                                         /*    48     8 */

	/* size: 56, cachelines: 1, members: 3 */
	/* sum members: 49, holes: 1, sum holes: 7 */
	/* last cacheline: 56 bytes */
};
struct BdrvOpBlocker {
	Error *                    reason;               /*     0     8 */
	struct {
		struct BdrvOpBlocker * le_next;          /*     8     8 */
		struct BdrvOpBlocker * * le_prev;        /*    16     8 */
	} list;                                          /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* last cacheline: 24 bytes */
};
struct CreateCo {
	BlockDriver *              drv;                  /*     0     8 */
	char *                     filename;             /*     8     8 */
	QemuOpts *                 opts;                 /*    16     8 */
	int                        ret;                  /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	Error *                    err;                  /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct BlockJobTxn {
	_Bool                      aborting;             /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	struct {
		struct BlockJob *  lh_first;             /*     8     8 */
	} jobs;                                          /*     8     8 */
	int                        refcnt;               /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 13, holes: 1, sum holes: 7 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct ChildProcessRecord {
	int                        pid;                  /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct ChildProcessRecord * le_next;     /*     8     8 */
		struct ChildProcessRecord * * le_prev;   /*    16     8 */
	} next;                                          /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct QEMUTimerList {
	QEMUClock *                clock;                /*     0     8 */
	QemuMutex                  active_timers_lock;   /*     8    40 */
	QEMUTimer *                active_timers;        /*    48     8 */
	struct {
		struct QEMUTimerList * le_next;          /*    56     8 */
		/* --- cacheline 1 boundary (64 bytes) --- */
		struct QEMUTimerList * * le_prev;        /*    64     8 */
	} list;                                          /*    56    16 */
	QEMUTimerListNotifyCB *    notify_cb;            /*    72     8 */
	void *                     notify_opaque;        /*    80     8 */
	QemuEvent                  timers_done_ev;       /*    88     4 */

	/* size: 96, cachelines: 2, members: 7 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct QEMUClock {
	struct {
		struct QEMUTimerList * lh_first;         /*     0     8 */
	} timerlists;                                    /*     0     8 */
	NotifierList               reset_notifiers;      /*     8     8 */
	int64_t                    last;                 /*    16     8 */
	QEMUClockType              type;                 /*    24     4 */
	_Bool                      enabled;              /*    28     1 */

	/* size: 32, cachelines: 1, members: 5 */
	/* padding: 3 */
	/* last cacheline: 32 bytes */
};
struct AioHandler {
	GPollFD                    pfd;                  /*     0     8 */
	IOHandler *                io_read;              /*     8     8 */
	IOHandler *                io_write;             /*    16     8 */
	int                        deleted;              /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	void *                     opaque;               /*    32     8 */
	_Bool                      is_external;          /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	struct {
		struct AioHandler * le_next;             /*    48     8 */
		struct AioHandler * * le_prev;           /*    56     8 */
	} node;                                          /*    48    16 */

	/* size: 64, cachelines: 1, members: 7 */
	/* sum members: 53, holes: 2, sum holes: 11 */
};
union epoll_data {
	void *                     ptr;                /*     0     8 */
	int                        fd;                 /*     0     4 */
	uint32_t                   u32;                /*     0     4 */
	uint64_t                   u64;                /*     0     8 */
};
struct epoll_event {
	uint32_t                   events;               /*     0     4 */
	epoll_data_t               data;                 /*     4     8 */

	/* size: 12, cachelines: 1, members: 2 */
	/* last cacheline: 12 bytes */
} __attribute__((__packed__));
struct cmdinfo {
	const char  *              name;                 /*     0     8 */
	const char  *              altname;              /*     8     8 */
	cfunc_t                    cfunc;                /*    16     8 */
	int                        argmin;               /*    24     4 */
	int                        argmax;               /*    28     4 */
	int                        canpush;              /*    32     4 */
	int                        flags;                /*    36     4 */
	const char  *              args;                 /*    40     8 */
	const char  *              oneline;              /*    48     8 */
	helpfunc_t                 help;                 /*    56     8 */

	/* size: 64, cachelines: 1, members: 10 */
};
struct aio_ctx {
	BlockBackend *             blk;                  /*     0     8 */
	QEMUIOVector               qiov;                 /*     8    24 */
	int64_t                    offset;               /*    32     8 */
	char *                     buf;                  /*    40     8 */
	_Bool                      qflag;                /*    48     1 */
	_Bool                      vflag;                /*    49     1 */
	_Bool                      Cflag;                /*    50     1 */
	_Bool                      Pflag;                /*    51     1 */
	_Bool                      zflag;                /*    52     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockAcctCookie            acct;                 /*    56    24 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	int                        pattern;              /*    80     4 */

	/* XXX 4 bytes hole, try to pack */

	struct timeval             t1;                   /*    88    16 */

	/* size: 104, cachelines: 2, members: 12 */
	/* sum members: 97, holes: 2, sum holes: 7 */
	/* last cacheline: 40 bytes */
};
struct ReplicationOps {
	void                       (*start)(ReplicationState *, ReplicationMode, Error * *); /*     0     8 */
	void                       (*stop)(ReplicationState *, _Bool, Error * *); /*     8     8 */
	void                       (*checkpoint)(ReplicationState *, Error * *); /*    16     8 */
	void                       (*get_error)(ReplicationState *, Error * *); /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct ReplicationState {
	void *                     opaque;               /*     0     8 */
	ReplicationOps *           ops;                  /*     8     8 */
	struct {
		struct ReplicationState * le_next;       /*    16     8 */
		struct ReplicationState * * le_prev;     /*    24     8 */
	} node;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct BDRVRawState {
	uint64_t                   offset;               /*     0     8 */
	uint64_t                   size;                 /*     8     8 */
	_Bool                      has_size;             /*    16     1 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct CoMutex {
	_Bool                      locked;               /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	Coroutine *                holder;               /*     8     8 */
	CoQueue                    queue;                /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* sum members: 25, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct QCowHeader {
	uint32_t                   magic;                /*     0     4 */
	uint32_t                   version;              /*     4     4 */
	uint64_t                   backing_file_offset;  /*     8     8 */
	uint32_t                   backing_file_size;    /*    16     4 */
	uint32_t                   mtime;                /*    20     4 */
	uint64_t                   size;                 /*    24     8 */
	uint8_t                    cluster_bits;         /*    32     1 */
	uint8_t                    l2_bits;              /*    33     1 */
	uint16_t                   padding;              /*    34     2 */
	uint32_t                   crypt_method;         /*    36     4 */
	uint64_t                   l1_table_offset;      /*    40     8 */

	/* size: 48, cachelines: 1, members: 11 */
	/* last cacheline: 48 bytes */
};
struct BDRVQcowState {
	int                        cluster_bits;         /*     0     4 */
	int                        cluster_size;         /*     4     4 */
	int                        cluster_sectors;      /*     8     4 */
	int                        l2_bits;              /*    12     4 */
	int                        l2_size;              /*    16     4 */
	unsigned int               l1_size;              /*    20     4 */
	uint64_t                   cluster_offset_mask;  /*    24     8 */
	uint64_t                   l1_table_offset;      /*    32     8 */
	uint64_t *                 l1_table;             /*    40     8 */
	uint64_t *                 l2_cache;             /*    48     8 */
	uint64_t                   l2_cache_offsets[16]; /*    56   128 */
	/* --- cacheline 2 boundary (128 bytes) was 56 bytes ago --- */
	uint32_t                   l2_cache_counts[16];  /*   184    64 */
	/* --- cacheline 3 boundary (192 bytes) was 56 bytes ago --- */
	uint8_t *                  cluster_cache;        /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	uint8_t *                  cluster_data;         /*   256     8 */
	uint64_t                   cluster_cache_offset; /*   264     8 */
	QCryptoCipher *            cipher;               /*   272     8 */
	uint32_t                   crypt_method_header;  /*   280     4 */

	/* XXX 4 bytes hole, try to pack */

	CoMutex                    lock;                 /*   288    32 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	Error *                    migration_blocker;    /*   320     8 */

	/* size: 328, cachelines: 6, members: 19 */
	/* sum members: 324, holes: 1, sum holes: 4 */
	/* last cacheline: 8 bytes */
};
struct VmdkExtent {
	BdrvChild *                file;                 /*     0     8 */
	_Bool                      flat;                 /*     8     1 */
	_Bool                      compressed;           /*     9     1 */
	_Bool                      has_marker;           /*    10     1 */
	_Bool                      has_zero_grain;       /*    11     1 */
	int                        version;              /*    12     4 */
	int64_t                    sectors;              /*    16     8 */
	int64_t                    end_sector;           /*    24     8 */
	int64_t                    flat_start_offset;    /*    32     8 */
	int64_t                    l1_table_offset;      /*    40     8 */
	int64_t                    l1_backup_table_offset; /*    48     8 */
	uint32_t *                 l1_table;             /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint32_t *                 l1_backup_table;      /*    64     8 */
	unsigned int               l1_size;              /*    72     4 */
	uint32_t                   l1_entry_sectors;     /*    76     4 */
	unsigned int               l2_size;              /*    80     4 */

	/* XXX 4 bytes hole, try to pack */

	uint32_t *                 l2_cache;             /*    88     8 */
	uint32_t                   l2_cache_offsets[16]; /*    96    64 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	uint32_t                   l2_cache_counts[16];  /*   160    64 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	int64_t                    cluster_sectors;      /*   224     8 */
	int64_t                    next_cluster_sector;  /*   232     8 */
	char *                     type;                 /*   240     8 */

	/* size: 248, cachelines: 4, members: 22 */
	/* sum members: 244, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct BDRVVmdkState {
	CoMutex                    lock;                 /*     0    32 */
	uint64_t                   desc_offset;          /*    32     8 */
	_Bool                      cid_updated;          /*    40     1 */
	_Bool                      cid_checked;          /*    41     1 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   cid;                  /*    44     4 */
	uint32_t                   parent_cid;           /*    48     4 */
	int                        num_extents;          /*    52     4 */
	VmdkExtent *               extents;              /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	Error *                    migration_blocker;    /*    64     8 */
	char *                     create_type;          /*    72     8 */

	/* size: 80, cachelines: 2, members: 10 */
	/* sum members: 78, holes: 1, sum holes: 2 */
	/* last cacheline: 16 bytes */
};
struct VmdkMetaData {
	unsigned int               l1_index;             /*     0     4 */
	unsigned int               l2_index;             /*     4     4 */
	unsigned int               l2_offset;            /*     8     4 */
	int                        valid;                /*    12     4 */
	uint32_t *                 l2_cache_entry;       /*    16     8 */

	/* size: 24, cachelines: 1, members: 5 */
	/* last cacheline: 24 bytes */
};
struct VmdkGrainMarker {
	uint64_t                   lba;                  /*     0     8 */
	uint32_t                   size;                 /*     8     4 */
	uint8_t                    data[];               /*    12     0 */

	/* size: 12, cachelines: 1, members: 3 */
	/* last cacheline: 12 bytes */
} __attribute__((__packed__));
struct BDRVCloopState {
	CoMutex                    lock;                 /*     0    32 */
	uint32_t                   block_size;           /*    32     4 */
	uint32_t                   n_blocks;             /*    36     4 */
	uint64_t *                 offsets;              /*    40     8 */
	uint32_t                   sectors_per_block;    /*    48     4 */
	uint32_t                   current_block;        /*    52     4 */
	uint8_t *                  compressed_block;     /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint8_t *                  uncompressed_block;   /*    64     8 */
	z_stream                   zstream;              /*    72   112 */

	/* size: 184, cachelines: 3, members: 9 */
	/* last cacheline: 56 bytes */
};
struct bochs_header {
	char                       magic[32];            /*     0    32 */
	char                       type[16];             /*    32    16 */
	char                       subtype[16];          /*    48    16 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint32_t                   version;              /*    64     4 */
	uint32_t                   header;               /*    68     4 */
	uint32_t                   catalog;              /*    72     4 */
	uint32_t                   bitmap;               /*    76     4 */
	uint32_t                   extent;               /*    80     4 */
	union {
		struct {
			uint32_t   reserved;             /*    84     4 */
			uint64_t   disk;                 /*    88     8 */
			char       padding[416];         /*    96   416 */
		} __attribute__((__packed__)) redolog;   /*    84   428 */
		struct {
			uint64_t   disk;                 /*    84     8 */
			char       padding[420];         /*    92   420 */
		} __attribute__((__packed__)) redolog_v1; /*    84   428 */
		char               padding[428];         /*    84   428 */
	} extra;                                         /*    84   428 */

	/* size: 512, cachelines: 8, members: 9 */
} __attribute__((__packed__));
struct BDRVBochsState {
	CoMutex                    lock;                 /*     0    32 */
	uint32_t *                 catalog_bitmap;       /*    32     8 */
	uint32_t                   catalog_size;         /*    40     4 */
	uint32_t                   data_offset;          /*    44     4 */
	uint32_t                   bitmap_blocks;        /*    48     4 */
	uint32_t                   extent_blocks;        /*    52     4 */
	uint32_t                   extent_size;          /*    56     4 */

	/* size: 64, cachelines: 1, members: 7 */
	/* padding: 4 */
};
struct vhd_footer {
	char                       creator[8];           /*     0     8 */
	uint32_t                   features;             /*     8     4 */
	uint32_t                   version;              /*    12     4 */
	uint64_t                   data_offset;          /*    16     8 */
	uint32_t                   timestamp;            /*    24     4 */
	char                       creator_app[4];       /*    28     4 */
	uint16_t                   major;                /*    32     2 */
	uint16_t                   minor;                /*    34     2 */
	char                       creator_os[4];        /*    36     4 */
	uint64_t                   orig_size;            /*    40     8 */
	uint64_t                   current_size;         /*    48     8 */
	uint16_t                   cyls;                 /*    56     2 */
	uint8_t                    heads;                /*    58     1 */
	uint8_t                    secs_per_cyl;         /*    59     1 */
	uint32_t                   type;                 /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint32_t                   checksum;             /*    64     4 */
	QemuUUID                   uuid;                 /*    68    16 */
	uint8_t                    in_saved_state;       /*    84     1 */

	/* size: 85, cachelines: 2, members: 18 */
	/* last cacheline: 21 bytes */
} __attribute__((__packed__));
struct vhd_dyndisk_header {
	char                       magic[8];             /*     0     8 */
	uint64_t                   data_offset;          /*     8     8 */
	uint64_t                   table_offset;         /*    16     8 */
	uint32_t                   version;              /*    24     4 */
	uint32_t                   max_table_entries;    /*    28     4 */
	uint32_t                   block_size;           /*    32     4 */
	uint32_t                   checksum;             /*    36     4 */
	uint8_t                    parent_uuid[16];      /*    40    16 */
	uint32_t                   parent_timestamp;     /*    56     4 */
	uint32_t                   reserved;             /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint8_t                    parent_name[512];     /*    64   512 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	struct {
		uint32_t           platform;             /*   576     4 */
		uint32_t           data_space;           /*   580     4 */
		uint32_t           data_length;          /*   584     4 */
		uint32_t           reserved;             /*   588     4 */
		uint64_t           data_offset;          /*   592     8 */
	} parent_locator[8]; /*   576   192 */

	/* size: 768, cachelines: 12, members: 12 */
};
struct BDRVVPCState {
	CoMutex                    lock;                 /*     0    32 */
	uint8_t                    footer_buf[512];      /*    32   512 */
	/* --- cacheline 8 boundary (512 bytes) was 32 bytes ago --- */
	uint64_t                   free_data_block_offset; /*   544     8 */
	int                        max_table_entries;    /*   552     4 */

	/* XXX 4 bytes hole, try to pack */

	uint32_t *                 pagetable;            /*   560     8 */
	uint64_t                   bat_offset;           /*   568     8 */
	/* --- cacheline 9 boundary (576 bytes) --- */
	uint64_t                   last_bitmap_offset;   /*   576     8 */
	uint32_t                   block_size;           /*   584     4 */
	uint32_t                   bitmap_size;          /*   588     4 */
	_Bool                      force_use_chs;        /*   592     1 */
	_Bool                      force_use_sz;         /*   593     1 */

	/* XXX 6 bytes hole, try to pack */

	Error *                    migration_blocker;    /*   600     8 */

	/* size: 608, cachelines: 10, members: 12 */
	/* sum members: 598, holes: 2, sum holes: 10 */
	/* last cacheline: 32 bytes */
};
struct array_t {
	char *                     pointer;              /*     0     8 */
	unsigned int               size;                 /*     8     4 */
	unsigned int               next;                 /*    12     4 */
	unsigned int               item_size;            /*    16     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct bootsector_t {
	uint8_t                    jump[3];              /*     0     3 */
	uint8_t                    name[8];              /*     3     8 */
	uint16_t                   sector_size;          /*    11     2 */
	uint8_t                    sectors_per_cluster;  /*    13     1 */
	uint16_t                   reserved_sectors;     /*    14     2 */
	uint8_t                    number_of_fats;       /*    16     1 */
	uint16_t                   root_entries;         /*    17     2 */
	uint16_t                   total_sectors16;      /*    19     2 */
	uint8_t                    media_type;           /*    21     1 */
	uint16_t                   sectors_per_fat;      /*    22     2 */
	uint16_t                   sectors_per_track;    /*    24     2 */
	uint16_t                   number_of_heads;      /*    26     2 */
	uint32_t                   hidden_sectors;       /*    28     4 */
	uint32_t                   total_sectors;        /*    32     4 */
	union {
		struct {
			uint8_t    drive_number;         /*    36     1 */
			uint8_t    current_head;         /*    37     1 */
			uint8_t    signature;            /*    38     1 */
			uint32_t   id;                   /*    39     4 */
			uint8_t    volume_label[11];     /*    43    11 */
		} __attribute__((__packed__)) fat16;     /*    36    18 */
		struct {
			uint32_t   sectors_per_fat;      /*    36     4 */
			uint16_t   flags;                /*    40     2 */
			uint8_t    major;                /*    42     1 */
			uint8_t    minor;                /*    43     1 */
			uint32_t   first_cluster_of_root_directory; /*    44     4 */
			uint16_t   info_sector;          /*    48     2 */
			uint16_t   backup_boot_sector;   /*    50     2 */
			uint16_t   ignored;              /*    52     2 */
		} __attribute__((__packed__)) fat32;     /*    36    18 */
	} u;                                             /*    36    18 */
	uint8_t                    fat_type[8];          /*    54     8 */
	uint8_t                    ignored[448];         /*    62   448 */
	/* --- cacheline 7 boundary (448 bytes) was 62 bytes ago --- */
	uint8_t                    magic[2];             /*   510     2 */

	/* size: 512, cachelines: 8, members: 18 */
} __attribute__((__packed__));
struct partition_t {
	uint8_t                    attributes;           /*     0     1 */
	mbr_chs_t                  start_CHS;            /*     1     3 */
	uint8_t                    fs_type;              /*     4     1 */
	mbr_chs_t                  end_CHS;              /*     5     3 */
	uint32_t                   start_sector_long;    /*     8     4 */
	uint32_t                   length_sector_long;   /*    12     4 */

	/* size: 16, cachelines: 1, members: 6 */
	/* last cacheline: 16 bytes */
};
struct mbr_t {
	uint8_t                    ignored[440];         /*     0   440 */
	/* --- cacheline 6 boundary (384 bytes) was 56 bytes ago --- */
	uint32_t                   nt_id;                /*   440     4 */
	uint8_t                    ignored2[2];          /*   444     2 */
	partition_t                partition[4];         /*   446    64 */
	/* --- cacheline 7 boundary (448 bytes) was 62 bytes ago --- */
	uint8_t                    magic[2];             /*   510     2 */

	/* size: 512, cachelines: 8, members: 5 */
} __attribute__((__packed__));
struct direntry_t {
	uint8_t                    name[11];             /*     0    11 */
	uint8_t                    attributes;           /*    11     1 */
	uint8_t                    reserved[2];          /*    12     2 */
	uint16_t                   ctime;                /*    14     2 */
	uint16_t                   cdate;                /*    16     2 */
	uint16_t                   adate;                /*    18     2 */
	uint16_t                   begin_hi;             /*    20     2 */
	uint16_t                   mtime;                /*    22     2 */
	uint16_t                   mdate;                /*    24     2 */
	uint16_t                   begin;                /*    26     2 */
	uint32_t                   size;                 /*    28     4 */

	/* size: 32, cachelines: 1, members: 11 */
	/* last cacheline: 32 bytes */
};
struct mapping_t {
	uint32_t                   begin;                /*     0     4 */
	uint32_t                   end;                  /*     4     4 */
	unsigned int               dir_index;            /*     8     4 */
	int                        first_mapping_index;  /*    12     4 */
	union {
		struct {
			uint32_t   offset;               /*    16     4 */
		} file;                                  /*    16     4 */
		struct {
			int        parent_mapping_index; /*    16     4 */
			int        first_dir_index;      /*    20     4 */
		} dir;                                   /*    16     8 */
	} info;                                          /*    16     8 */
	char *                     path;                 /*    24     8 */
	enum {
		MODE_UNDEFINED = 0,
		MODE_NORMAL = 1,
		MODE_MODIFIED = 2,
		MODE_DIRECTORY = 4,
		MODE_FAKED = 8,
		MODE_DELETED = 16,
		MODE_RENAMED = 32,
	} mode;                                          /*    32     4 */
	int                        read_only;            /*    36     4 */

	/* size: 40, cachelines: 1, members: 8 */
	/* last cacheline: 40 bytes */
};
struct BDRVVVFATState {
	CoMutex                    lock;                 /*     0    32 */
	BlockDriverState *         bs;                   /*    32     8 */
	unsigned int               first_sectors_number; /*    40     4 */
	unsigned char              first_sectors[32768]; /*    44 32768 */
	/* --- cacheline 512 boundary (32768 bytes) was 44 bytes ago --- */
	int                        fat_type;             /* 32812     4 */
	array_t                    fat;                  /* 32816    24 */
	/* --- cacheline 513 boundary (32832 bytes) was 8 bytes ago --- */
	array_t                    directory;            /* 32840    24 */
	array_t                    mapping;              /* 32864    24 */
	char                       volume_label[11];     /* 32888    11 */

	/* XXX 1 byte hole, try to pack */

	/* --- cacheline 514 boundary (32896 bytes) was 4 bytes ago --- */
	unsigned int               cluster_size;         /* 32900     4 */
	unsigned int               sectors_per_cluster;  /* 32904     4 */
	unsigned int               sectors_per_fat;      /* 32908     4 */
	unsigned int               sectors_of_root_directory; /* 32912     4 */
	uint32_t                   last_cluster_of_root_directory; /* 32916     4 */
	unsigned int               faked_sectors;        /* 32920     4 */
	uint32_t                   sector_count;         /* 32924     4 */
	uint32_t                   cluster_count;        /* 32928     4 */
	uint32_t                   max_fat_value;        /* 32932     4 */
	int                        current_fd;           /* 32936     4 */

	/* XXX 4 bytes hole, try to pack */

	mapping_t *                current_mapping;      /* 32944     8 */
	unsigned char *            cluster;              /* 32952     8 */
	/* --- cacheline 515 boundary (32960 bytes) --- */
	unsigned char *            cluster_buffer;       /* 32960     8 */
	unsigned int               current_cluster;      /* 32968     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     qcow_filename;        /* 32976     8 */
	BdrvChild *                qcow;                 /* 32984     8 */
	void *                     fat2;                 /* 32992     8 */
	char *                     used_clusters;        /* 33000     8 */
	array_t                    commits;              /* 33008    24 */
	/* --- cacheline 516 boundary (33024 bytes) was 8 bytes ago --- */
	const char  *              path;                 /* 33032     8 */
	int                        downcase_short_names; /* 33040     4 */

	/* XXX 4 bytes hole, try to pack */

	Error *                    migration_blocker;    /* 33048     8 */

	/* size: 33056, cachelines: 517, members: 31 */
	/* sum members: 33043, holes: 4, sum holes: 13 */
	/* last cacheline: 32 bytes */
};
struct commit_t {
	char *                     path;                 /*     0     8 */
	union {
		struct {
			uint32_t   cluster;              /*     8     4 */
		} rename;                                /*     8     4 */
		struct {
			int        dir_index;            /*     8     4 */
			uint32_t   modified_offset;      /*    12     4 */
		} writeout;                              /*     8     8 */
		struct {
			uint32_t   first_cluster;        /*     8     4 */
		} new_file;                              /*     8     4 */
		struct {
			uint32_t   cluster;              /*     8     4 */
		} mkdir;                                 /*     8     4 */
	} param;                                         /*     8     8 */
	enum {
		ACTION_RENAME = 0,
		ACTION_WRITEOUT = 1,
		ACTION_NEW_FILE = 2,
		ACTION_MKDIR = 3,
	} action;                                        /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct BDRVDMGState {
	CoMutex                    lock;                 /*     0    32 */
	uint32_t                   n_chunks;             /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	uint32_t *                 types;                /*    40     8 */
	uint64_t *                 offsets;              /*    48     8 */
	uint64_t *                 lengths;              /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint64_t *                 sectors;              /*    64     8 */
	uint64_t *                 sectorcounts;         /*    72     8 */
	uint32_t                   current_chunk;        /*    80     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  compressed_chunk;     /*    88     8 */
	uint8_t *                  uncompressed_chunk;   /*    96     8 */
	z_stream                   zstream;              /*   104   112 */

	/* size: 216, cachelines: 4, members: 11 */
	/* sum members: 208, holes: 2, sum holes: 8 */
	/* last cacheline: 24 bytes */
};
struct DmgHeaderState {
	uint64_t                   data_fork_offset;     /*     0     8 */
	uint32_t                   max_compressed_size;  /*     8     4 */
	uint32_t                   max_sectors_per_chunk; /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct QemuOpt {
	char *                     name;                 /*     0     8 */
	char *                     str;                  /*     8     8 */
	const QemuOptDesc  *       desc;                 /*    16     8 */
	union {
		_Bool              boolean;              /*    24     1 */
		uint64_t           uint;                 /*    24     8 */
	} value;                                         /*    24     8 */
	QemuOpts *                 opts;                 /*    32     8 */
	struct {
		struct QemuOpt *   tqe_next;             /*    40     8 */
		struct QemuOpt * * tqe_prev;             /*    48     8 */
	} next;                                          /*    40    16 */

	/* size: 56, cachelines: 1, members: 6 */
	/* last cacheline: 56 bytes */
};
struct QemuOpts {
	char *                     id;                   /*     0     8 */
	QemuOptsList *             list;                 /*     8     8 */
	Location                   loc;                  /*    16    24 */
	struct QemuOptHead         head;                 /*    40    16 */
	struct {
		struct QemuOpts *  tqe_next;             /*    56     8 */
		/* --- cacheline 1 boundary (64 bytes) --- */
		struct QemuOpts * * tqe_prev;            /*    64     8 */
	} next;                                          /*    56    16 */

	/* size: 72, cachelines: 2, members: 5 */
	/* last cacheline: 8 bytes */
};
struct QCowSnapshot {
	uint64_t                   l1_table_offset;      /*     0     8 */
	uint32_t                   l1_size;              /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     id_str;               /*    16     8 */
	char *                     name;                 /*    24     8 */
	uint64_t                   disk_size;            /*    32     8 */
	uint64_t                   vm_state_size;        /*    40     8 */
	uint32_t                   date_sec;             /*    48     4 */
	uint32_t                   date_nsec;            /*    52     4 */
	uint64_t                   vm_clock_nsec;        /*    56     8 */

	/* size: 64, cachelines: 1, members: 9 */
	/* sum members: 60, holes: 1, sum holes: 4 */
};
struct Qcow2UnknownHeaderExtension {
	uint32_t                   magic;                /*     0     4 */
	uint32_t                   len;                  /*     4     4 */
	struct {
		struct Qcow2UnknownHeaderExtension * le_next; /*     8     8 */
		struct Qcow2UnknownHeaderExtension * * le_prev; /*    16     8 */
	} next;                                          /*     8    16 */
	uint8_t                    data[];               /*    24     0 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct Qcow2Feature {
	uint8_t                    type;                 /*     0     1 */
	uint8_t                    bit;                  /*     1     1 */
	char                       name[46];             /*     2    46 */

	/* size: 48, cachelines: 1, members: 3 */
	/* last cacheline: 48 bytes */
};
struct Qcow2DiscardRegion {
	BlockDriverState *         bs;                   /*     0     8 */
	uint64_t                   offset;               /*     8     8 */
	uint64_t                   bytes;                /*    16     8 */
	struct {
		struct Qcow2DiscardRegion * tqe_next;    /*    24     8 */
		struct Qcow2DiscardRegion * * tqe_prev;  /*    32     8 */
	} next;                                          /*    24    16 */

	/* size: 40, cachelines: 1, members: 4 */
	/* last cacheline: 40 bytes */
};
struct QCowClusterAlloc {
	struct QCowL2Meta *        lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct QCowL2Meta {
	uint64_t                   offset;               /*     0     8 */
	uint64_t                   alloc_offset;         /*     8     8 */
	int                        nb_clusters;          /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	CoQueue                    dependent_requests;   /*    24    16 */
	Qcow2COWRegion             cow_start;            /*    40    16 */
	Qcow2COWRegion             cow_end;              /*    56    16 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	struct QCowL2Meta *        next;                 /*    72     8 */
	struct {
		struct QCowL2Meta * le_next;             /*    80     8 */
		struct QCowL2Meta * * le_prev;           /*    88     8 */
	} next_in_flight;                                /*    80    16 */

	/* size: 96, cachelines: 2, members: 8 */
	/* sum members: 92, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct BDRVQcow2State {
	int                        cluster_bits;         /*     0     4 */
	int                        cluster_size;         /*     4     4 */
	int                        cluster_sectors;      /*     8     4 */
	int                        l2_bits;              /*    12     4 */
	int                        l2_size;              /*    16     4 */
	int                        l1_size;              /*    20     4 */
	int                        l1_vm_state_index;    /*    24     4 */
	int                        refcount_block_bits;  /*    28     4 */
	int                        refcount_block_size;  /*    32     4 */
	int                        csize_shift;          /*    36     4 */
	int                        csize_mask;           /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   cluster_offset_mask;  /*    48     8 */
	uint64_t                   l1_table_offset;      /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint64_t *                 l1_table;             /*    64     8 */
	Qcow2Cache *               l2_table_cache;       /*    72     8 */
	Qcow2Cache *               refcount_block_cache; /*    80     8 */
	QEMUTimer *                cache_clean_timer;    /*    88     8 */
	unsigned int               cache_clean_interval; /*    96     4 */

	/* XXX 4 bytes hole, try to pack */

	uint8_t *                  cluster_cache;        /*   104     8 */
	uint8_t *                  cluster_data;         /*   112     8 */
	uint64_t                   cluster_cache_offset; /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	struct QCowClusterAlloc    cluster_allocs;       /*   128     8 */
	uint64_t *                 refcount_table;       /*   136     8 */
	uint64_t                   refcount_table_offset; /*   144     8 */
	uint32_t                   refcount_table_size;  /*   152     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   free_cluster_index;   /*   160     8 */
	uint64_t                   free_byte_offset;     /*   168     8 */
	CoMutex                    lock;                 /*   176    32 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	QCryptoCipher *            cipher;               /*   208     8 */
	uint32_t                   crypt_method_header;  /*   216     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   snapshots_offset;     /*   224     8 */
	int                        snapshots_size;       /*   232     4 */
	unsigned int               nb_snapshots;         /*   236     4 */
	QCowSnapshot *             snapshots;            /*   240     8 */
	int                        flags;                /*   248     4 */
	int                        qcow_version;         /*   252     4 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	_Bool                      use_lazy_refcounts;   /*   256     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        refcount_order;       /*   260     4 */
	int                        refcount_bits;        /*   264     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   refcount_max;         /*   272     8 */
	Qcow2GetRefcountFunc *     get_refcount;         /*   280     8 */
	Qcow2SetRefcountFunc *     set_refcount;         /*   288     8 */
	_Bool                      discard_passthrough[5]; /*   296     5 */

	/* XXX 3 bytes hole, try to pack */

	int                        overlap_check;        /*   304     4 */
	_Bool                      signaled_corruption;  /*   308     1 */

	/* XXX 3 bytes hole, try to pack */

	uint64_t                   incompatible_features; /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	uint64_t                   compatible_features;  /*   320     8 */
	uint64_t                   autoclear_features;   /*   328     8 */
	size_t                     unknown_header_fields_size; /*   336     8 */
	void *                     unknown_header_fields; /*   344     8 */
	struct {
		struct Qcow2UnknownHeaderExtension * lh_first; /*   352     8 */
	} unknown_header_ext;                            /*   352     8 */
	struct {
		struct Qcow2DiscardRegion * tqh_first;   /*   360     8 */
		struct Qcow2DiscardRegion * * tqh_last;  /*   368     8 */
	} discards;                                      /*   360    16 */
	_Bool                      cache_discards;       /*   376     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 6 boundary (384 bytes) --- */
	char *                     image_backing_file;   /*   384     8 */
	char *                     image_backing_format; /*   392     8 */

	/* size: 400, cachelines: 7, members: 55 */
	/* sum members: 364, holes: 9, sum holes: 36 */
	/* last cacheline: 16 bytes */
};
struct Qcow2COWRegion {
	uint64_t                   offset;               /*     0     8 */
	int                        nb_bytes;             /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct QemuOptHead {
	struct QemuOpt *           tqh_first;            /*     0     8 */
	struct QemuOpt * *         tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct Qcow2ReopenState {
	Qcow2Cache *               l2_table_cache;       /*     0     8 */
	Qcow2Cache *               refcount_block_cache; /*     8     8 */
	_Bool                      use_lazy_refcounts;   /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        overlap_check;        /*    20     4 */
	_Bool                      discard_passthrough[5]; /*    24     5 */

	/* XXX 3 bytes hole, try to pack */

	uint64_t                   cache_clean_interval; /*    32     8 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 34, holes: 2, sum holes: 6 */
	/* last cacheline: 40 bytes */
};
struct Qcow2AmendHelperCBInfo {
	BlockDriverAmendStatusCB * original_status_cb;   /*     0     8 */
	void *                     original_cb_opaque;   /*     8     8 */
	Qcow2AmendOperation        current_operation;    /*    16     4 */
	int                        total_operations;     /*    20     4 */
	int                        operations_completed; /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    offset_completed;     /*    32     8 */
	Qcow2AmendOperation        last_operation;       /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    last_work_size;       /*    48     8 */

	/* size: 56, cachelines: 1, members: 8 */
	/* sum members: 48, holes: 2, sum holes: 8 */
	/* last cacheline: 56 bytes */
};
struct QCowSnapshotHeader {
	uint64_t                   l1_table_offset;      /*     0     8 */
	uint32_t                   l1_size;              /*     8     4 */
	uint16_t                   id_str_size;          /*    12     2 */
	uint16_t                   name_size;            /*    14     2 */
	uint32_t                   date_sec;             /*    16     4 */
	uint32_t                   date_nsec;            /*    20     4 */
	uint64_t                   vm_clock_nsec;        /*    24     8 */
	uint32_t                   vm_state_size;        /*    32     4 */
	uint32_t                   extra_data_size;      /*    36     4 */

	/* size: 40, cachelines: 1, members: 9 */
	/* last cacheline: 40 bytes */
};
struct QCowSnapshotExtraData {
	uint64_t                   vm_state_size_large;  /*     0     8 */
	uint64_t                   disk_size;            /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct Qcow2Cache {
	Qcow2CachedTable *         entries;              /*     0     8 */
	struct Qcow2Cache *        depends;              /*     8     8 */
	int                        size;                 /*    16     4 */
	_Bool                      depends_on_flush;     /*    20     1 */

	/* XXX 3 bytes hole, try to pack */

	void *                     table_array;          /*    24     8 */
	uint64_t                   lru_counter;          /*    32     8 */
	uint64_t                   cache_clean_lru_counter; /*    40     8 */

	/* size: 48, cachelines: 1, members: 7 */
	/* sum members: 45, holes: 1, sum holes: 3 */
	/* last cacheline: 48 bytes */
};
struct Qcow2CachedTable {
	int64_t                    offset;               /*     0     8 */
	uint64_t                   lru_counter;          /*     8     8 */
	int                        ref;                  /*    16     4 */
	_Bool                      dirty;                /*    20     1 */

	/* size: 24, cachelines: 1, members: 4 */
	/* padding: 3 */
	/* last cacheline: 24 bytes */
};
struct CachedL2Table {
	QEDTable *                 table;                /*     0     8 */
	uint64_t                   offset;               /*     8     8 */
	struct {
		struct CachedL2Table * tqe_next;         /*    16     8 */
		struct CachedL2Table * * tqe_prev;       /*    24     8 */
	} node;                                          /*    16    16 */
	int                        ref;                  /*    32     4 */

	/* size: 40, cachelines: 1, members: 4 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct QEDRequest {
	CachedL2Table *            l2_table;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct QEDAIOCB {
	BlockAIOCB                 common;               /*     0    40 */
	int                        bh_ret;               /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct QEDAIOCB *  sqe_next;             /*    48     8 */
	} next;                                          /*    48     8 */
	int                        flags;                /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	uint64_t                   end_pos;              /*    64     8 */
	QEMUIOVector *             qiov;                 /*    72     8 */
	size_t                     qiov_offset;          /*    80     8 */
	QEMUIOVector               cur_qiov;             /*    88    24 */
	QEMUIOVector *             backing_qiov;         /*   112     8 */
	uint64_t                   cur_pos;              /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	uint64_t                   cur_cluster;          /*   128     8 */
	unsigned int               cur_nclusters;        /*   136     4 */
	int                        find_cluster_ret;     /*   140     4 */
	QEDRequest                 request;              /*   144     8 */

	/* size: 152, cachelines: 3, members: 14 */
	/* sum members: 144, holes: 2, sum holes: 8 */
	/* last cacheline: 24 bytes */
};
struct MSGUID {
	uint32_t                   data1;                /*     0     4 */
	uint16_t                   data2;                /*     4     2 */
	uint16_t                   data3;                /*     6     2 */
	uint8_t                    data4[8];             /*     8     8 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct VHDXHeader {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   checksum;             /*     4     4 */
	uint64_t                   sequence_number;      /*     8     8 */
	MSGUID                     file_write_guid;      /*    16    16 */
	MSGUID                     data_write_guid;      /*    32    16 */
	MSGUID                     log_guid;             /*    48    16 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	uint16_t                   log_version;          /*    64     2 */
	uint16_t                   version;              /*    66     2 */
	uint32_t                   log_length;           /*    68     4 */
	uint64_t                   log_offset;           /*    72     8 */

	/* size: 80, cachelines: 2, members: 10 */
	/* last cacheline: 16 bytes */
};
struct VHDXRegionTableHeader {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   checksum;             /*     4     4 */
	uint32_t                   entry_count;          /*     8     4 */
	uint32_t                   reserved;             /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
struct VHDXRegionTableEntry {
	MSGUID                     guid;                 /*     0    16 */
	uint64_t                   file_offset;          /*    16     8 */
	uint32_t                   length;               /*    24     4 */
	uint32_t                   data_bits;            /*    28     4 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct VHDXLogEntryHeader {
	uint32_t                   signature;            /*     0     4 */
	uint32_t                   checksum;             /*     4     4 */
	uint32_t                   entry_length;         /*     8     4 */
	uint32_t                   tail;                 /*    12     4 */
	uint64_t                   sequence_number;      /*    16     8 */
	uint32_t                   descriptor_count;     /*    24     4 */
	uint32_t                   reserved;             /*    28     4 */
	MSGUID                     log_guid;             /*    32    16 */
	uint64_t                   flushed_file_offset;  /*    48     8 */
	uint64_t                   last_file_offset;     /*    56     8 */

	/* size: 64, cachelines: 1, members: 10 */
};
struct VHDXMetadataTableHeader {
	uint64_t                   signature;            /*     0     8 */
	uint16_t                   reserved;             /*     8     2 */
	uint16_t                   entry_count;          /*    10     2 */
	uint32_t                   reserved2[5];         /*    12    20 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct VHDXMetadataTableEntry {
	MSGUID                     item_id;              /*     0    16 */
	uint32_t                   offset;               /*    16     4 */
	uint32_t                   length;               /*    20     4 */
	uint32_t                   data_bits;            /*    24     4 */
	uint32_t                   reserved2;            /*    28     4 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct VHDXFileParameters {
	uint32_t                   block_size;           /*     0     4 */
	uint32_t                   data_bits;            /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct VHDXVirtualDiskSize {
	uint64_t                   virtual_disk_size;    /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct VHDXPage83Data {
	MSGUID                     page_83_data;         /*     0    16 */

	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */
};
struct VHDXVirtualDiskLogicalSectorSize {
	uint32_t                   logical_sector_size;  /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct VHDXVirtualDiskPhysicalSectorSize {
	uint32_t                   physical_sector_size; /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct VHDXParentLocatorHeader {
	MSGUID                     locator_type;         /*     0    16 */
	uint16_t                   reserved;             /*    16     2 */
	uint16_t                   key_value_count;      /*    18     2 */

	/* size: 20, cachelines: 1, members: 3 */
	/* last cacheline: 20 bytes */
};
struct VHDXParentLocatorEntry {
	uint32_t                   key_offset;           /*     0     4 */
	uint32_t                   value_offset;         /*     4     4 */
	uint16_t                   key_length;           /*     8     2 */
	uint16_t                   value_length;         /*    10     2 */

	/* size: 12, cachelines: 1, members: 4 */
	/* last cacheline: 12 bytes */
};
struct VHDXMetadataEntries {
	VHDXMetadataTableEntry     file_parameters_entry; /*     0    32 */
	VHDXMetadataTableEntry     virtual_disk_size_entry; /*    32    32 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	VHDXMetadataTableEntry     page83_data_entry;    /*    64    32 */
	VHDXMetadataTableEntry     logical_sector_size_entry; /*    96    32 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	VHDXMetadataTableEntry     phys_sector_size_entry; /*   128    32 */
	VHDXMetadataTableEntry     parent_locator_entry; /*   160    32 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	uint16_t                   present;              /*   192     2 */

	/* size: 194, cachelines: 4, members: 7 */
	/* last cacheline: 2 bytes */
} __attribute__((__packed__));
struct VHDXLogEntries {
	uint64_t                   offset;               /*     0     8 */
	uint64_t                   length;               /*     8     8 */
	uint32_t                   write;                /*    16     4 */
	uint32_t                   read;                 /*    20     4 */
	VHDXLogEntryHeader *       hdr;                  /*    24     8 */
	void *                     desc_buffer;          /*    32     8 */
	uint64_t                   sequence;             /*    40     8 */
	uint32_t                   tail;                 /*    48     4 */

	/* size: 56, cachelines: 1, members: 8 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct VHDXRegionEntry {
	uint64_t                   start;                /*     0     8 */
	uint64_t                   end;                  /*     8     8 */
	struct {
		struct VHDXRegionEntry * le_next;        /*    16     8 */
		struct VHDXRegionEntry * * le_prev;      /*    24     8 */
	} entries;                                       /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct VHDXRegionHead {
	struct VHDXRegionEntry *   lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct BDRVVHDXState {
	CoMutex                    lock;                 /*     0    32 */
	int                        curr_header;          /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	VHDXHeader *               headers[2];           /*    40    16 */
	VHDXRegionTableHeader      rt;                   /*    56    16 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	VHDXRegionTableEntry       bat_rt;               /*    72    32 */
	VHDXRegionTableEntry       metadata_rt;          /*   104    32 */
	/* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
	VHDXMetadataTableHeader    metadata_hdr;         /*   136    32 */
	VHDXMetadataEntries        metadata_entries;     /*   168   194 */
	/* --- cacheline 5 boundary (320 bytes) was 42 bytes ago --- */
	VHDXFileParameters         params;               /*   362     8 */

	/* XXX 2 bytes hole, try to pack */

	uint32_t                   block_size;           /*   372     4 */
	uint32_t                   block_size_bits;      /*   376     4 */
	uint32_t                   sectors_per_block;    /*   380     4 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	uint32_t                   sectors_per_block_bits; /*   384     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   virtual_disk_size;    /*   392     8 */
	uint32_t                   logical_sector_size;  /*   400     4 */
	uint32_t                   physical_sector_size; /*   404     4 */
	uint64_t                   chunk_ratio;          /*   408     8 */
	uint32_t                   chunk_ratio_bits;     /*   416     4 */
	uint32_t                   logical_sector_size_bits; /*   420     4 */
	uint32_t                   bat_entries;          /*   424     4 */

	/* XXX 4 bytes hole, try to pack */

	VHDXBatEntry *             bat;                  /*   432     8 */
	uint64_t                   bat_offset;           /*   440     8 */
	/* --- cacheline 7 boundary (448 bytes) --- */
	_Bool                      first_visible_write;  /*   448     1 */
	MSGUID                     session_guid;         /*   449    16 */

	/* XXX 7 bytes hole, try to pack */

	VHDXLogEntries             log;                  /*   472    56 */
	/* --- cacheline 8 boundary (512 bytes) was 16 bytes ago --- */
	VHDXParentLocatorHeader    parent_header;        /*   528    20 */

	/* XXX 4 bytes hole, try to pack */

	VHDXParentLocatorEntry *   parent_entries;       /*   552     8 */
	Error *                    migration_blocker;    /*   560     8 */
	_Bool                      log_replayed_on_open; /*   568     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 9 boundary (576 bytes) --- */
	struct VHDXRegionHead      regions;              /*   576     8 */

	/* size: 584, cachelines: 10, members: 30 */
	/* sum members: 552, holes: 7, sum holes: 32 */
	/* last cacheline: 8 bytes */
};
struct VHDXSectorInfo {
	uint32_t                   bat_idx;              /*     0     4 */
	uint32_t                   sectors_avail;        /*     4     4 */
	uint32_t                   bytes_left;           /*     8     4 */
	uint32_t                   bytes_avail;          /*    12     4 */
	uint64_t                   file_offset;          /*    16     8 */
	uint64_t                   block_offset;         /*    24     8 */

	/* size: 32, cachelines: 1, members: 6 */
	/* last cacheline: 32 bytes */
};
struct VHDXLogDescriptor {
	uint32_t                   signature;            /*     0     4 */
	union {
		uint32_t           reserved;             /*     4     4 */
		uint32_t           trailing_bytes;       /*     4     4 */
	};                                               /*     4     4 */
	union {
		uint64_t           zero_length;          /*     8     8 */
		uint64_t           leading_bytes;        /*     8     8 */
	};                                               /*     8     8 */
	uint64_t                   file_offset;          /*    16     8 */
	uint64_t                   sequence_number;      /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct VHDXLogDataSector {
	uint32_t                   data_signature;       /*     0     4 */
	uint32_t                   sequence_high;        /*     4     4 */
	uint8_t                    data[4084];           /*     8  4084 */
	/* --- cacheline 63 boundary (4032 bytes) was 60 bytes ago --- */
	uint32_t                   sequence_low;         /*  4092     4 */

	/* size: 4096, cachelines: 64, members: 4 */
};
struct VHDXLogSequence {
	_Bool                      valid;                /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   count;                /*     4     4 */
	VHDXLogEntries             log;                  /*     8    56 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	VHDXLogEntryHeader         hdr;                  /*    64    64 */

	/* size: 128, cachelines: 2, members: 4 */
	/* sum members: 125, holes: 1, sum holes: 3 */
};
struct VHDXLogDescEntries {
	VHDXLogEntryHeader         hdr;                  /*     0    64 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	VHDXLogDescriptor          desc[];               /*    64     0 */

	/* size: 64, cachelines: 1, members: 2 */
};
union QuorumVoteValue {
	uint8_t                    h[32];              /*     0    32 */
	int64_t                    l;                  /*     0     8 */
};
struct QuorumVoteItem {
	int                        index;                /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	struct {
		struct QuorumVoteItem * le_next;         /*     8     8 */
		struct QuorumVoteItem * * le_prev;       /*    16     8 */
	} next;                                          /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct QuorumVoteVersion {
	QuorumVoteValue            value;                /*     0    32 */
	int                        index;                /*    32     4 */
	int                        vote_count;           /*    36     4 */
	struct {
		struct QuorumVoteItem * lh_first;        /*    40     8 */
	} items;                                         /*    40     8 */
	struct {
		struct QuorumVoteVersion * le_next;      /*    48     8 */
		struct QuorumVoteVersion * * le_prev;    /*    56     8 */
	} next;                                          /*    48    16 */

	/* size: 64, cachelines: 1, members: 5 */
};
struct QuorumVotes {
	struct {
		struct QuorumVoteVersion * lh_first;     /*     0     8 */
	} vote_list;                                     /*     0     8 */
	_Bool                      (*compare)(QuorumVoteValue *, QuorumVoteValue *); /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BDRVQuorumState {
	BdrvChild * *              children;             /*     0     8 */
	int                        num_children;         /*     8     4 */
	unsigned int               next_child_index;     /*    12     4 */
	int                        threshold;            /*    16     4 */
	_Bool                      is_blkverify;         /*    20     1 */
	_Bool                      rewrite_corrupted;    /*    21     1 */

	/* XXX 2 bytes hole, try to pack */

	QuorumReadPattern          read_pattern;         /*    24     4 */

	/* size: 32, cachelines: 1, members: 7 */
	/* sum members: 26, holes: 1, sum holes: 2 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct QuorumAIOCB {
	BlockAIOCB                 common;               /*     0    40 */
	uint64_t                   sector_num;           /*    40     8 */
	int                        nb_sectors;           /*    48     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUIOVector *             qiov;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	QuorumChildRequest *       qcrs;                 /*    64     8 */
	int                        count;                /*    72     4 */
	int                        success_count;        /*    76     4 */
	int                        rewrite_count;        /*    80     4 */

	/* XXX 4 bytes hole, try to pack */

	QuorumVotes                votes;                /*    88    16 */
	_Bool                      is_read;              /*   104     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        vote_ret;             /*   108     4 */
	int                        children_read;        /*   112     4 */

	/* size: 120, cachelines: 2, members: 12 */
	/* sum members: 105, holes: 3, sum holes: 11 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct QuorumChildRequest {
	BlockAIOCB *               aiocb;                /*     0     8 */
	QEMUIOVector               qiov;                 /*     8    24 */
	uint8_t *                  buf;                  /*    32     8 */
	int                        ret;                  /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	QuorumAIOCB *              parent;               /*    48     8 */

	/* size: 56, cachelines: 1, members: 5 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct ParallelsHeader {
	char                       magic[16];            /*     0    16 */
	uint32_t                   version;              /*    16     4 */
	uint32_t                   heads;                /*    20     4 */
	uint32_t                   cylinders;            /*    24     4 */
	uint32_t                   tracks;               /*    28     4 */
	uint32_t                   bat_entries;          /*    32     4 */
	uint64_t                   nb_sectors;           /*    36     8 */
	uint32_t                   inuse;                /*    44     4 */
	uint32_t                   data_off;             /*    48     4 */
	char                       padding[12];          /*    52    12 */

	/* size: 64, cachelines: 1, members: 10 */
} __attribute__((__packed__));
struct BDRVParallelsState {
	CoMutex                    lock;                 /*     0    32 */
	ParallelsHeader *          header;               /*    32     8 */
	uint32_t                   header_size;          /*    40     4 */
	_Bool                      header_unclean;       /*    44     1 */

	/* XXX 3 bytes hole, try to pack */

	long unsigned int *        bat_dirty_bmap;       /*    48     8 */
	unsigned int               bat_dirty_block;      /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	uint32_t *                 bat_bitmap;           /*    64     8 */
	unsigned int               bat_size;             /*    72     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    data_end;             /*    80     8 */
	uint64_t                   prealloc_size;        /*    88     8 */
	ParallelsPreallocMode      prealloc_mode;        /*    96     4 */
	unsigned int               tracks;               /*   100     4 */
	unsigned int               off_multiplier;       /*   104     4 */

	/* size: 112, cachelines: 2, members: 13 */
	/* sum members: 97, holes: 3, sum holes: 11 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct BlkdebugRule {
	BlkdebugEvent              event;                /*     0     4 */
	int                        action;               /*     4     4 */
	int                        state;                /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		struct {
			int        error;                /*    16     4 */
			int        immediately;          /*    20     4 */
			int        once;                 /*    24     4 */

			/* XXX 4 bytes hole, try to pack */

			int64_t    sector;               /*    32     8 */
		} inject;                                /*    16    24 */
		struct {
			int        new_state;            /*    16     4 */
		} set_state;                             /*    16     4 */
		struct {
			char *     tag;                  /*    16     8 */
		} suspend;                               /*    16     8 */
	} options;                                       /*    16    24 */
	struct {
		struct BlkdebugRule * le_next;           /*    40     8 */
		struct BlkdebugRule * * le_prev;         /*    48     8 */
	} next;                                          /*    40    16 */
	struct {
		struct BlkdebugRule * sqe_next;          /*    56     8 */
	} active_next;                                   /*    56     8 */

	/* size: 64, cachelines: 1, members: 6 */
	/* sum members: 60, holes: 1, sum holes: 4 */
};
struct BlkdebugSuspendedReq {
	Coroutine *                co;                   /*     0     8 */
	char *                     tag;                  /*     8     8 */
	struct {
		struct BlkdebugSuspendedReq * le_next;   /*    16     8 */
		struct BlkdebugSuspendedReq * * le_prev; /*    24     8 */
	} next;                                          /*    16    16 */

	/* size: 32, cachelines: 1, members: 3 */
	/* last cacheline: 32 bytes */
};
struct BDRVBlkdebugState {
	int                        state;                /*     0     4 */
	int                        new_state;            /*     4     4 */
	int                        align;                /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     config_file;          /*    16     8 */
	struct {
		struct BlkdebugRule * lh_first;          /*    24     8 */
	} rules[43]; /*    24   344 */
	/* --- cacheline 5 boundary (320 bytes) was 48 bytes ago --- */
	struct {
		struct BlkdebugRule * sqh_first;         /*   368     8 */
		struct BlkdebugRule * * sqh_last;        /*   376     8 */
	} active_rules;                                  /*   368    16 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	struct {
		struct BlkdebugSuspendedReq * lh_first;  /*   384     8 */
	} suspended_reqs;                                /*   384     8 */

	/* size: 392, cachelines: 7, members: 7 */
	/* sum members: 388, holes: 1, sum holes: 4 */
	/* last cacheline: 8 bytes */
};
struct BlkdebugAIOCB {
	BlockAIOCB                 common;               /*     0    40 */
	int                        ret;                  /*    40     4 */

	/* size: 48, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct add_rule_data {
	BDRVBlkdebugState *        s;                    /*     0     8 */
	int                        action;               /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct BlkverifyAIOCB {
	BlockAIOCB                 common;               /*     0    40 */
	_Bool                      is_write;             /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    sector_num;           /*    48     8 */
	int                        nb_sectors;           /*    56     4 */
	int                        ret;                  /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	unsigned int               done;                 /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	QEMUIOVector *             qiov;                 /*    72     8 */
	QEMUIOVector               raw_qiov;             /*    80    24 */
	void *                     buf;                  /*   104     8 */
	void                       (*verify)(BlkverifyAIOCB *); /*   112     8 */

	/* size: 120, cachelines: 2, members: 10 */
	/* sum members: 109, holes: 2, sum holes: 11 */
	/* last cacheline: 56 bytes */
};
struct Request {
	Coroutine *                co;                   /*     0     8 */
	QEMUBH *                   bh;                   /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct BlockBackend {
	char *                     name;                 /*     0     8 */
	int                        refcnt;               /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	BdrvChild *                root;                 /*    16     8 */
	DriveInfo *                legacy_dinfo;         /*    24     8 */
	struct {
		struct BlockBackend * tqe_next;          /*    32     8 */
		struct BlockBackend * * tqe_prev;        /*    40     8 */
	} link;                                          /*    32    16 */
	struct {
		struct BlockBackend * tqe_next;          /*    48     8 */
		struct BlockBackend * * tqe_prev;        /*    56     8 */
	} monitor_link;                                  /*    48    16 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	BlockBackendPublic         public;               /*    64   120 */
	/* --- cacheline 2 boundary (128 bytes) was 56 bytes ago --- */
	void *                     dev;                  /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	_Bool                      legacy_dev;           /*   192     1 */

	/* XXX 7 bytes hole, try to pack */

	const BlockDevOps  *       dev_ops;              /*   200     8 */
	void *                     dev_opaque;           /*   208     8 */
	int                        guest_block_size;     /*   216     4 */
	BlockBackendRootState      root_state;           /*   220    12 */
	_Bool                      enable_write_cache;   /*   232     1 */

	/* XXX 7 bytes hole, try to pack */

	BlockAcctStats             stats;                /*   240   168 */
	/* --- cacheline 6 boundary (384 bytes) was 24 bytes ago --- */
	BlockdevOnError            on_read_error;        /*   408     4 */
	BlockdevOnError            on_write_error;       /*   412     4 */
	_Bool                      iostatus_enabled;     /*   416     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockDeviceIoStatus        iostatus;             /*   420     4 */
	_Bool                      allow_write_beyond_eof; /*   424     1 */

	/* XXX 7 bytes hole, try to pack */

	NotifierList               remove_bs_notifiers;  /*   432     8 */
	NotifierList               insert_bs_notifiers;  /*   440     8 */

	/* size: 448, cachelines: 7, members: 22 */
	/* sum members: 420, holes: 5, sum holes: 28 */
};
struct BlockBackendAIOCB {
	BlockAIOCB                 common;               /*     0    40 */
	BlockBackend *             blk;                  /*    40     8 */
	int                        ret;                  /*    48     4 */

	/* size: 56, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct BlkRwCo {
	BlockBackend *             blk;                  /*     0     8 */
	int64_t                    offset;               /*     8     8 */
	QEMUIOVector *             qiov;                 /*    16     8 */
	int                        ret;                  /*    24     4 */
	BdrvRequestFlags           flags;                /*    28     4 */

	/* size: 32, cachelines: 1, members: 5 */
	/* last cacheline: 32 bytes */
};
struct BlkAioEmAIOCB {
	BlockAIOCB                 common;               /*     0    40 */
	BlkRwCo                    rwco;                 /*    40    32 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	int                        bytes;                /*    72     4 */
	_Bool                      has_returned;         /*    76     1 */

	/* size: 80, cachelines: 2, members: 4 */
	/* padding: 3 */
	/* last cacheline: 16 bytes */
};
struct hd_geometry {
	unsigned char              heads;                /*     0     1 */
	unsigned char              sectors;              /*     1     1 */
	short unsigned int         cylinders;            /*     2     2 */

	/* XXX 4 bytes hole, try to pack */

	long unsigned int          start;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 4 */
	/* sum members: 12, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct BDRVRawReopenState {
	int                        fd;                   /*     0     4 */
	int                        open_flags;           /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct RawPosixAIOData {
	BlockDriverState *         bs;                   /*     0     8 */
	int                        aio_fildes;           /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		struct iovec *     aio_iov;              /*    16     8 */
		void *             aio_ioctl_buf;        /*    16     8 */
	};                                               /*    16     8 */
	int                        aio_niov;             /*    24     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   aio_nbytes;           /*    32     8 */
	off_t                      aio_offset;           /*    40     8 */
	int                        aio_type;             /*    48     4 */

	/* size: 56, cachelines: 1, members: 7 */
	/* sum members: 44, holes: 2, sum holes: 8 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct MirrorBuffer {
	struct {
		struct MirrorBuffer * sqe_next;          /*     0     8 */
	} next;                                          /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct MirrorBlockJob {
	BlockJob                   common;               /*     0   168 */
	/* --- cacheline 2 boundary (128 bytes) was 40 bytes ago --- */
	RateLimit                  limit;                /*   168    40 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	BlockBackend *             target;               /*   208     8 */
	BlockDriverState *         base;                 /*   216     8 */
	char *                     replaces;             /*   224     8 */
	BlockDriverState *         to_replace;           /*   232     8 */
	Error *                    replace_blocker;      /*   240     8 */
	_Bool                      is_none_mode;         /*   248     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockMirrorBackingMode     backing_mode;         /*   252     4 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	BlockdevOnError            on_source_error;      /*   256     4 */
	BlockdevOnError            on_target_error;      /*   260     4 */
	_Bool                      synced;               /*   264     1 */
	_Bool                      should_complete;      /*   265     1 */

	/* XXX 6 bytes hole, try to pack */

	int64_t                    granularity;          /*   272     8 */
	size_t                     buf_size;             /*   280     8 */
	int64_t                    bdev_length;          /*   288     8 */
	long unsigned int *        cow_bitmap;           /*   296     8 */
	BdrvDirtyBitmap *          dirty_bitmap;         /*   304     8 */
	BdrvDirtyBitmapIter *      dbi;                  /*   312     8 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	uint8_t *                  buf;                  /*   320     8 */
	struct {
		struct MirrorBuffer * sqh_first;         /*   328     8 */
		struct MirrorBuffer * * sqh_last;        /*   336     8 */
	} buf_free;                                      /*   328    16 */
	int                        buf_free_count;       /*   344     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   last_pause_ns;        /*   352     8 */
	long unsigned int *        in_flight_bitmap;     /*   360     8 */
	int                        in_flight;            /*   368     4 */

	/* XXX 4 bytes hole, try to pack */

	int64_t                    sectors_in_flight;    /*   376     8 */
	/* --- cacheline 6 boundary (384 bytes) --- */
	int                        ret;                  /*   384     4 */
	_Bool                      unmap;                /*   388     1 */
	_Bool                      waiting_for_io;       /*   389     1 */

	/* XXX 2 bytes hole, try to pack */

	int                        target_cluster_sectors; /*   392     4 */
	int                        max_iov;              /*   396     4 */

	/* size: 400, cachelines: 7, members: 31 */
	/* sum members: 381, holes: 5, sum holes: 19 */
	/* last cacheline: 16 bytes */
};
struct MirrorOp {
	MirrorBlockJob *           s;                    /*     0     8 */
	QEMUIOVector               qiov;                 /*     8    24 */
	int64_t                    sector_num;           /*    32     8 */
	int                        nb_sectors;           /*    40     4 */

	/* size: 48, cachelines: 1, members: 4 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct CommitBlockJob {
	BlockJob                   common;               /*     0   168 */
	/* --- cacheline 2 boundary (128 bytes) was 40 bytes ago --- */
	RateLimit                  limit;                /*   168    40 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	BlockDriverState *         active;               /*   208     8 */
	BlockBackend *             top;                  /*   216     8 */
	BlockBackend *             base;                 /*   224     8 */
	BlockdevOnError            on_error;             /*   232     4 */
	int                        base_flags;           /*   236     4 */
	int                        orig_overlay_flags;   /*   240     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     backing_file_str;     /*   248     8 */

	/* size: 256, cachelines: 4, members: 9 */
	/* sum members: 252, holes: 1, sum holes: 4 */
};
struct RwCo {
	BdrvChild *                child;                /*     0     8 */
	int64_t                    offset;               /*     8     8 */
	QEMUIOVector *             qiov;                 /*    16     8 */
	_Bool                      is_write;             /*    24     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        ret;                  /*    28     4 */
	BdrvRequestFlags           flags;                /*    32     4 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 33, holes: 1, sum holes: 3 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct CoroutineIOCompletion {
	Coroutine *                coroutine;            /*     0     8 */
	int                        ret;                  /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct BdrvCoGetBlockStatusData {
	BlockDriverState *         bs;                   /*     0     8 */
	BlockDriverState *         base;                 /*     8     8 */
	BlockDriverState * *       file;                 /*    16     8 */
	int64_t                    sector_num;           /*    24     8 */
	int                        nb_sectors;           /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	int *                      pnum;                 /*    40     8 */
	int64_t                    ret;                  /*    48     8 */
	_Bool                      done;                 /*    56     1 */

	/* size: 64, cachelines: 1, members: 8 */
	/* sum members: 53, holes: 1, sum holes: 4 */
	/* padding: 7 */
};
struct BdrvVmstateCo {
	BlockDriverState *         bs;                   /*     0     8 */
	QEMUIOVector *             qiov;                 /*     8     8 */
	int64_t                    pos;                  /*    16     8 */
	_Bool                      is_read;              /*    24     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        ret;                  /*    28     4 */

	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 29, holes: 1, sum holes: 3 */
	/* last cacheline: 32 bytes */
};
struct BlockRequest {
	union {
		struct {
			int64_t    offset;               /*     0     8 */
			int        bytes;                /*     8     4 */
			int        flags;                /*    12     4 */
			QEMUIOVector * qiov;             /*    16     8 */
		};                                       /*     0    24 */
		struct {
			int        req;                  /*     0     4 */

			/* XXX 4 bytes hole, try to pack */

			void *     buf;                  /*     8     8 */
		};                                       /*     0    16 */
	};                                               /*     0    24 */
	BlockCompletionFunc *      cb;                   /*    24     8 */
	void *                     opaque;               /*    32     8 */
	int                        error;                /*    40     4 */

	/* size: 48, cachelines: 1, members: 4 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct BlockAIOCBCoroutine {
	BlockAIOCB                 common;               /*     0    40 */
	BdrvChild *                child;                /*    40     8 */
	BlockRequest               req;                  /*    48    48 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	_Bool                      is_write;             /*    96     1 */
	_Bool                      need_bh;              /*    97     1 */

	/* XXX 6 bytes hole, try to pack */

	_Bool *                    done;                 /*   104     8 */

	/* size: 112, cachelines: 2, members: 6 */
	/* sum members: 106, holes: 1, sum holes: 6 */
	/* last cacheline: 48 bytes */
};
struct FlushCo {
	BlockDriverState *         bs;                   /*     0     8 */
	int                        ret;                  /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct DiscardCo {
	BlockDriverState *         bs;                   /*     0     8 */
	int64_t                    offset;               /*     8     8 */
	int                        count;                /*    16     4 */
	int                        ret;                  /*    20     4 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct ThrottleGroup {
	char *                     name;                 /*     0     8 */
	QemuMutex                  lock;                 /*     8    40 */
	ThrottleState              ts;                   /*    48   256 */
	/* --- cacheline 4 boundary (256 bytes) was 48 bytes ago --- */
	struct {
		struct BlockBackendPublic * lh_first;    /*   304     8 */
	} head;                                          /*   304     8 */
	BlockBackend *             tokens[2];            /*   312    16 */
	/* --- cacheline 5 boundary (320 bytes) was 8 bytes ago --- */
	_Bool                      any_timer_armed[2];   /*   328     2 */

	/* XXX 2 bytes hole, try to pack */

	unsigned int               refcount;             /*   332     4 */
	struct {
		struct ThrottleGroup * tqe_next;         /*   336     8 */
		struct ThrottleGroup * * tqe_prev;       /*   344     8 */
	} list;                                          /*   336    16 */

	/* size: 352, cachelines: 6, members: 8 */
	/* sum members: 350, holes: 1, sum holes: 2 */
	/* last cacheline: 32 bytes */
};
struct NBDReply {
	uint64_t                   handle;               /*     0     8 */
	uint32_t                   error;                /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct NBDClientSession {
	QIOChannelSocket *         sioc;                 /*     0     8 */
	QIOChannel *               ioc;                  /*     8     8 */
	uint16_t                   nbdflags;             /*    16     2 */

	/* XXX 6 bytes hole, try to pack */

	off_t                      size;                 /*    24     8 */
	CoMutex                    send_mutex;           /*    32    32 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	CoQueue                    free_sema;            /*    64    16 */
	Coroutine *                send_coroutine;       /*    80     8 */
	int                        in_flight;            /*    88     4 */

	/* XXX 4 bytes hole, try to pack */

	Coroutine *                recv_coroutine[16];   /*    96   128 */
	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
	NBDReply                   reply;                /*   224    16 */
	_Bool                      is_unix;              /*   240     1 */

	/* size: 248, cachelines: 4, members: 11 */
	/* sum members: 231, holes: 2, sum holes: 10 */
	/* padding: 7 */
	/* last cacheline: 56 bytes */
};
struct URI {
	char *                     scheme;               /*     0     8 */
	char *                     opaque;               /*     8     8 */
	char *                     authority;            /*    16     8 */
	char *                     server;               /*    24     8 */
	char *                     user;                 /*    32     8 */
	int                        port;                 /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     path;                 /*    48     8 */
	char *                     fragment;             /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        cleanup;              /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     query;                /*    72     8 */

	/* size: 80, cachelines: 2, members: 10 */
	/* sum members: 72, holes: 2, sum holes: 8 */
	/* last cacheline: 16 bytes */
};
struct QueryParam {
	char *                     name;                 /*     0     8 */
	char *                     value;                /*     8     8 */
	int                        ignore;               /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct QueryParams {
	int                        n;                    /*     0     4 */
	int                        alloc;                /*     4     4 */
	QueryParam *               p;                    /*     8     8 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct BDRVNBDState {
	NBDClientSession           client;               /*     0   248 */
	/* --- cacheline 3 boundary (192 bytes) was 56 bytes ago --- */
	SocketAddress *            saddr;                /*   248     8 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	char *                     export;               /*   256     8 */
	char *                     tlscredsid;           /*   264     8 */

	/* size: 272, cachelines: 5, members: 4 */
	/* last cacheline: 16 bytes */
};
struct NBDRequest {
	uint64_t                   handle;               /*     0     8 */
	uint64_t                   from;                 /*     8     8 */
	uint32_t                   len;                  /*    16     4 */
	uint16_t                   flags;                /*    20     2 */
	uint16_t                   type;                 /*    22     2 */

	/* size: 24, cachelines: 1, members: 5 */
	/* last cacheline: 24 bytes */
};
struct SheepdogReq {
	uint8_t                    proto_ver;            /*     0     1 */
	uint8_t                    opcode;               /*     1     1 */
	uint16_t                   flags;                /*     2     2 */
	uint32_t                   epoch;                /*     4     4 */
	uint32_t                   id;                   /*     8     4 */
	uint32_t                   data_length;          /*    12     4 */
	uint32_t                   opcode_specific[8];   /*    16    32 */

	/* size: 48, cachelines: 1, members: 7 */
	/* last cacheline: 48 bytes */
};
struct SheepdogObjReq {
	uint8_t                    proto_ver;            /*     0     1 */
	uint8_t                    opcode;               /*     1     1 */
	uint16_t                   flags;                /*     2     2 */
	uint32_t                   epoch;                /*     4     4 */
	uint32_t                   id;                   /*     8     4 */
	uint32_t                   data_length;          /*    12     4 */
	uint64_t                   oid;                  /*    16     8 */
	uint64_t                   cow_oid;              /*    24     8 */
	uint8_t                    copies;               /*    32     1 */
	uint8_t                    copy_policy;          /*    33     1 */
	uint8_t                    reserved[6];          /*    34     6 */
	uint64_t                   offset;               /*    40     8 */

	/* size: 48, cachelines: 1, members: 12 */
	/* last cacheline: 48 bytes */
};
struct SheepdogObjRsp {
	uint8_t                    proto_ver;            /*     0     1 */
	uint8_t                    opcode;               /*     1     1 */
	uint16_t                   flags;                /*     2     2 */
	uint32_t                   epoch;                /*     4     4 */
	uint32_t                   id;                   /*     8     4 */
	uint32_t                   data_length;          /*    12     4 */
	uint32_t                   result;               /*    16     4 */
	uint8_t                    copies;               /*    20     1 */
	uint8_t                    copy_policy;          /*    21     1 */
	uint8_t                    reserved[2];          /*    22     2 */
	uint32_t                   pad[6];               /*    24    24 */

	/* size: 48, cachelines: 1, members: 11 */
	/* last cacheline: 48 bytes */
};
struct SheepdogVdiReq {
	uint8_t                    proto_ver;            /*     0     1 */
	uint8_t                    opcode;               /*     1     1 */
	uint16_t                   flags;                /*     2     2 */
	uint32_t                   epoch;                /*     4     4 */
	uint32_t                   id;                   /*     8     4 */
	uint32_t                   data_length;          /*    12     4 */
	uint64_t                   vdi_size;             /*    16     8 */
	uint32_t                   base_vdi_id;          /*    24     4 */
	uint8_t                    copies;               /*    28     1 */
	uint8_t                    copy_policy;          /*    29     1 */
	uint8_t                    store_policy;         /*    30     1 */
	uint8_t                    block_size_shift;     /*    31     1 */
	uint32_t                   snapid;               /*    32     4 */
	uint32_t                   type;                 /*    36     4 */
	uint32_t                   pad[2];               /*    40     8 */

	/* size: 48, cachelines: 1, members: 15 */
	/* last cacheline: 48 bytes */
};
struct SheepdogVdiRsp {
	uint8_t                    proto_ver;            /*     0     1 */
	uint8_t                    opcode;               /*     1     1 */
	uint16_t                   flags;                /*     2     2 */
	uint32_t                   epoch;                /*     4     4 */
	uint32_t                   id;                   /*     8     4 */
	uint32_t                   data_length;          /*    12     4 */
	uint32_t                   result;               /*    16     4 */
	uint32_t                   rsvd;                 /*    20     4 */
	uint32_t                   vdi_id;               /*    24     4 */
	uint32_t                   pad[5];               /*    28    20 */

	/* size: 48, cachelines: 1, members: 10 */
	/* last cacheline: 48 bytes */
};
struct SheepdogClusterRsp {
	uint8_t                    proto_ver;            /*     0     1 */
	uint8_t                    opcode;               /*     1     1 */
	uint16_t                   flags;                /*     2     2 */
	uint32_t                   epoch;                /*     4     4 */
	uint32_t                   id;                   /*     8     4 */
	uint32_t                   data_length;          /*    12     4 */
	uint32_t                   result;               /*    16     4 */
	uint8_t                    nr_copies;            /*    20     1 */
	uint8_t                    copy_policy;          /*    21     1 */
	uint8_t                    block_size_shift;     /*    22     1 */
	uint8_t                    __pad1;               /*    23     1 */
	uint32_t                   __pad2[6];            /*    24    24 */

	/* size: 48, cachelines: 1, members: 12 */
	/* last cacheline: 48 bytes */
};
struct SheepdogInode {
	char                       name[256];            /*     0   256 */
	/* --- cacheline 4 boundary (256 bytes) --- */
	char                       tag[256];             /*   256   256 */
	/* --- cacheline 8 boundary (512 bytes) --- */
	uint64_t                   ctime;                /*   512     8 */
	uint64_t                   snap_ctime;           /*   520     8 */
	uint64_t                   vm_clock_nsec;        /*   528     8 */
	uint64_t                   vdi_size;             /*   536     8 */
	uint64_t                   vm_state_size;        /*   544     8 */
	uint16_t                   copy_policy;          /*   552     2 */
	uint8_t                    nr_copies;            /*   554     1 */
	uint8_t                    block_size_shift;     /*   555     1 */
	uint32_t                   snap_id;              /*   556     4 */
	uint32_t                   vdi_id;               /*   560     4 */
	uint32_t                   parent_vdi_id;        /*   564     4 */
	uint32_t                   child_vdi_id[1024];   /*   568  4096 */
	/* --- cacheline 72 boundary (4608 bytes) was 56 bytes ago --- */
	uint32_t                   data_vdi_id[1048576]; /*  4664 4194304 */

	/* size: 4198968, cachelines: 65609, members: 15 */
	/* last cacheline: 56 bytes */
};
struct SheepdogAIOCB {
	BlockAIOCB                 common;               /*     0    40 */
	QEMUIOVector *             qiov;                 /*    40     8 */
	int64_t                    sector_num;           /*    48     8 */
	int                        nb_sectors;           /*    56     4 */
	int                        ret;                  /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	enum AIOCBState            aiocb_type;           /*    64     4 */

	/* XXX 4 bytes hole, try to pack */

	Coroutine *                coroutine;            /*    72     8 */
	void                       (*aio_done_func)(SheepdogAIOCB *); /*    80     8 */
	_Bool                      cancelable;           /*    88     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        nr_pending;           /*    92     4 */
	uint32_t                   min_affect_data_idx;  /*    96     4 */
	uint32_t                   max_affect_data_idx;  /*   100     4 */
	uint32_t                   min_dirty_data_idx;   /*   104     4 */
	uint32_t                   max_dirty_data_idx;   /*   108     4 */
	struct {
		struct SheepdogAIOCB * le_next;          /*   112     8 */
		struct SheepdogAIOCB * * le_prev;        /*   120     8 */
	} aiocb_siblings;                                /*   112    16 */

	/* size: 128, cachelines: 2, members: 15 */
	/* sum members: 121, holes: 2, sum holes: 7 */
};
struct AIOReq {
	SheepdogAIOCB *            aiocb;                /*     0     8 */
	unsigned int               iov_offset;           /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	uint64_t                   oid;                  /*    16     8 */
	uint64_t                   base_oid;             /*    24     8 */
	uint64_t                   offset;               /*    32     8 */
	unsigned int               data_len;             /*    40     4 */
	uint8_t                    flags;                /*    44     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   id;                   /*    48     4 */
	_Bool                      create;               /*    52     1 */

	/* XXX 3 bytes hole, try to pack */

	struct {
		struct AIOReq *    le_next;              /*    56     8 */
		/* --- cacheline 1 boundary (64 bytes) --- */
		struct AIOReq * *  le_prev;              /*    64     8 */
	} aio_siblings;                                  /*    56    16 */

	/* size: 72, cachelines: 2, members: 10 */
	/* sum members: 62, holes: 3, sum holes: 10 */
	/* last cacheline: 8 bytes */
};
struct inflight_aio_head {
	struct AIOReq *            lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct failed_aio_head {
	struct AIOReq *            lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct inflight_aiocb_head {
	struct SheepdogAIOCB *     lh_first;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct BDRVSheepdogState {
	BlockDriverState *         bs;                   /*     0     8 */
	AioContext *               aio_context;          /*     8     8 */
	SheepdogInode              inode;                /*    16 4198968 */
	/* --- cacheline 65609 boundary (4198976 bytes) was 8 bytes ago --- */
	char                       name[256];            /* 4198984   256 */
	/* --- cacheline 65613 boundary (4199232 bytes) was 8 bytes ago --- */
	_Bool                      is_snapshot;          /* 4199240     1 */

	/* XXX 3 bytes hole, try to pack */

	uint32_t                   cache_flags;          /* 4199244     4 */
	_Bool                      discard_supported;    /* 4199248     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     host_spec;            /* 4199256     8 */
	_Bool                      is_unix;              /* 4199264     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        fd;                   /* 4199268     4 */
	CoMutex                    lock;                 /* 4199272    32 */
	/* --- cacheline 65614 boundary (4199296 bytes) was 8 bytes ago --- */
	Coroutine *                co_send;              /* 4199304     8 */
	Coroutine *                co_recv;              /* 4199312     8 */
	uint32_t                   aioreq_seq_num;       /* 4199320     4 */

	/* XXX 4 bytes hole, try to pack */

	struct inflight_aio_head   inflight_aio_head;    /* 4199328     8 */
	struct failed_aio_head     failed_aio_head;      /* 4199336     8 */
	CoQueue                    overlapping_queue;    /* 4199344    16 */
	/* --- cacheline 65615 boundary (4199360 bytes) --- */
	struct inflight_aiocb_head inflight_aiocb_head;  /* 4199360     8 */

	/* size: 4199368, cachelines: 65616, members: 18 */
	/* sum members: 4199351, holes: 4, sum holes: 17 */
	/* last cacheline: 8 bytes */
};
struct BDRVSheepdogReopenState {
	int                        fd;                   /*     0     4 */
	int                        cache_flags;          /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct SheepdogReqCo {
	int                        sockfd;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	BlockDriverState *         bs;                   /*     8     8 */
	AioContext *               aio_context;          /*    16     8 */
	SheepdogReq *              hdr;                  /*    24     8 */
	void *                     data;                 /*    32     8 */
	unsigned int *             wlen;                 /*    40     8 */
	unsigned int *             rlen;                 /*    48     8 */
	int                        ret;                  /*    56     4 */
	_Bool                      finished;             /*    60     1 */

	/* size: 64, cachelines: 1, members: 9 */
	/* sum members: 57, holes: 1, sum holes: 4 */
	/* padding: 3 */
};
struct BdrvDirtyBitmap {
	HBitmap *                  bitmap;               /*     0     8 */
	HBitmap *                  meta;                 /*     8     8 */
	BdrvDirtyBitmap *          successor;            /*    16     8 */
	char *                     name;                 /*    24     8 */
	int64_t                    size;                 /*    32     8 */
	_Bool                      disabled;             /*    40     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        active_iterators;     /*    44     4 */
	struct {
		struct BdrvDirtyBitmap * le_next;        /*    48     8 */
		struct BdrvDirtyBitmap * * le_prev;      /*    56     8 */
	} list;                                          /*    48    16 */

	/* size: 64, cachelines: 1, members: 8 */
	/* sum members: 61, holes: 1, sum holes: 3 */
};
struct BdrvDirtyBitmapIter {
	HBitmapIter                hbi;                  /*     0    80 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	BdrvDirtyBitmap *          bitmap;               /*    80     8 */

	/* size: 88, cachelines: 2, members: 2 */
	/* last cacheline: 24 bytes */
};
struct HBitmapIter {
	const HBitmap  *           hb;                   /*     0     8 */
	int                        granularity;          /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     pos;                  /*    16     8 */
	long unsigned int          cur[7];               /*    24    56 */

	/* size: 80, cachelines: 2, members: 4 */
	/* sum members: 76, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct CoRwlock {
	_Bool                      writer;               /*     0     1 */

	/* XXX 3 bytes hole, try to pack */

	int                        reader;               /*     4     4 */
	CoQueue                    queue;                /*     8    16 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 21, holes: 1, sum holes: 3 */
	/* last cacheline: 24 bytes */
};
struct CowRequest {
	int64_t                    start;                /*     0     8 */
	int64_t                    end;                  /*     8     8 */
	struct {
		struct CowRequest * le_next;             /*    16     8 */
		struct CowRequest * * le_prev;           /*    24     8 */
	} list;                                          /*    16    16 */
	CoQueue                    wait_queue;           /*    32    16 */

	/* size: 48, cachelines: 1, members: 4 */
	/* last cacheline: 48 bytes */
};
struct BackupBlockJob {
	BlockJob                   common;               /*     0   168 */
	/* --- cacheline 2 boundary (128 bytes) was 40 bytes ago --- */
	BlockBackend *             target;               /*   168     8 */
	BdrvDirtyBitmap *          sync_bitmap;          /*   176     8 */
	MirrorSyncMode             sync_mode;            /*   184     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) --- */
	RateLimit                  limit;                /*   192    40 */
	BlockdevOnError            on_source_error;      /*   232     4 */
	BlockdevOnError            on_target_error;      /*   236     4 */
	CoRwlock                   flush_rwlock;         /*   240    24 */
	/* --- cacheline 4 boundary (256 bytes) was 8 bytes ago --- */
	uint64_t                   sectors_read;         /*   264     8 */
	long unsigned int *        done_bitmap;          /*   272     8 */
	int64_t                    cluster_size;         /*   280     8 */
	_Bool                      compress;             /*   288     1 */

	/* XXX 7 bytes hole, try to pack */

	NotifierWithReturn         before_write;         /*   296    24 */
	/* --- cacheline 5 boundary (320 bytes) --- */
	struct {
		struct CowRequest * lh_first;            /*   320     8 */
	} inflight_reqs;                                 /*   320     8 */

	/* size: 328, cachelines: 6, members: 14 */
	/* sum members: 317, holes: 2, sum holes: 11 */
	/* last cacheline: 8 bytes */
};
struct BDRVReplicationState {
	ReplicationMode            mode;                 /*     0     4 */
	int                        replication_state;    /*     4     4 */
	BdrvChild *                active_disk;          /*     8     8 */
	BdrvChild *                hidden_disk;          /*    16     8 */
	BdrvChild *                secondary_disk;       /*    24     8 */
	char *                     top_id;               /*    32     8 */
	ReplicationState *         rs;                   /*    40     8 */
	Error *                    blocker;              /*    48     8 */
	int                        orig_hidden_flags;    /*    56     4 */
	int                        orig_secondary_flags; /*    60     4 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	int                        error;                /*    64     4 */

	/* size: 72, cachelines: 2, members: 11 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
struct QCryptoBlockCreateOptions {
	QCryptoBlockFormat         format;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		QCryptoBlockOptionsQCow qcow;            /*     8    16 */
		QCryptoBlockCreateOptionsLUKS luks;      /*     8    72 */
	} u;                                             /*     8    72 */

	/* size: 80, cachelines: 2, members: 2 */
	/* sum members: 76, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct QCryptoBlockCreateOptionsLUKS {
	_Bool                      has_key_secret;       /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     key_secret;           /*     8     8 */
	_Bool                      has_cipher_alg;       /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	QCryptoCipherAlgorithm     cipher_alg;           /*    20     4 */
	_Bool                      has_cipher_mode;      /*    24     1 */

	/* XXX 3 bytes hole, try to pack */

	QCryptoCipherMode          cipher_mode;          /*    28     4 */
	_Bool                      has_ivgen_alg;        /*    32     1 */

	/* XXX 3 bytes hole, try to pack */

	QCryptoIVGenAlgorithm      ivgen_alg;            /*    36     4 */
	_Bool                      has_ivgen_hash_alg;   /*    40     1 */

	/* XXX 3 bytes hole, try to pack */

	QCryptoHashAlgorithm       ivgen_hash_alg;       /*    44     4 */
	_Bool                      has_hash_alg;         /*    48     1 */

	/* XXX 3 bytes hole, try to pack */

	QCryptoHashAlgorithm       hash_alg;             /*    52     4 */
	_Bool                      has_iter_time;        /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	int64_t                    iter_time;            /*    64     8 */

	/* size: 72, cachelines: 2, members: 14 */
	/* sum members: 43, holes: 7, sum holes: 29 */
	/* last cacheline: 8 bytes */
};
struct QCryptoBlockInfo {
	QCryptoBlockFormat         format;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		QCryptoBlockInfoQCow qcow;               /*     8     1 */
		QCryptoBlockInfoLUKS luks;               /*     8    56 */
	} u;                                             /*     8    56 */

	/* size: 64, cachelines: 1, members: 2 */
	/* sum members: 60, holes: 1, sum holes: 4 */
};
struct QCryptoBlockInfoQCow {
	char                       qapi_dummy_for_empty_struct; /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
};
struct QCryptoBlockOpenOptions {
	QCryptoBlockFormat         format;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		QCryptoBlockOptionsQCow qcow;            /*     8    16 */
		QCryptoBlockOptionsLUKS luks;            /*     8    16 */
	} u;                                             /*     8    16 */

	/* size: 24, cachelines: 1, members: 2 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct QCryptoBlockOptionsLUKS {
	_Bool                      has_key_secret;       /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     key_secret;           /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 9, holes: 1, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct QCryptoBlockOptionsQCow {
	_Bool                      has_key_secret;       /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     key_secret;           /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* sum members: 9, holes: 1, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct BlockCrypto {
	QCryptoBlock *             block;                /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct BlockCryptoCreateData {
	const char  *              filename;             /*     0     8 */
	QemuOpts *                 opts;                 /*     8     8 */
	BlockBackend *             blk;                  /*    16     8 */
	uint64_t                   size;                 /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct NBDExport {
	int                        refcount;             /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	void                       (*close)(NBDExport *); /*     8     8 */
	BlockBackend *             blk;                  /*    16     8 */
	char *                     name;                 /*    24     8 */
	char *                     description;          /*    32     8 */
	off_t                      dev_offset;           /*    40     8 */
	off_t                      size;                 /*    48     8 */
	uint16_t                   nbdflags;             /*    56     2 */

	/* XXX 6 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	struct {
		struct NBDClient * tqh_first;            /*    64     8 */
		struct NBDClient * * tqh_last;           /*    72     8 */
	} clients;                                       /*    64    16 */
	struct {
		struct NBDExport * tqe_next;             /*    80     8 */
		struct NBDExport * * tqe_prev;           /*    88     8 */
	} next;                                          /*    80    16 */
	AioContext *               ctx;                  /*    96     8 */
	BlockBackend *             eject_notifier_blk;   /*   104     8 */
	Notifier                   eject_notifier;       /*   112    24 */

	/* size: 136, cachelines: 3, members: 13 */
	/* sum members: 126, holes: 2, sum holes: 10 */
	/* last cacheline: 8 bytes */
};
struct NBDClient {
	int                        refcount;             /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	void                       (*close)(NBDClient *); /*     8     8 */
	_Bool                      no_zeroes;            /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	NBDExport *                exp;                  /*    24     8 */
	QCryptoTLSCreds *          tlscreds;             /*    32     8 */
	char *                     tlsaclname;           /*    40     8 */
	QIOChannelSocket *         sioc;                 /*    48     8 */
	QIOChannel *               ioc;                  /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	Coroutine *                recv_coroutine;       /*    64     8 */
	CoMutex                    send_lock;            /*    72    32 */
	Coroutine *                send_coroutine;       /*   104     8 */
	_Bool                      can_read;             /*   112     1 */

	/* XXX 7 bytes hole, try to pack */

	struct {
		struct NBDClient * tqe_next;             /*   120     8 */
		/* --- cacheline 2 boundary (128 bytes) --- */
		struct NBDClient * * tqe_prev;           /*   128     8 */
	} next;                                          /*   120    16 */
	int                        nb_requests;          /*   136     4 */
	_Bool                      closing;              /*   140     1 */

	/* size: 144, cachelines: 3, members: 15 */
	/* sum members: 123, holes: 3, sum holes: 18 */
	/* padding: 3 */
	/* last cacheline: 16 bytes */
};
struct NBDTLSHandshakeData {
	GMainLoop *                loop;                 /*     0     8 */
	_Bool                      complete;             /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	Error *                    error;                /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct NBDRequestData {
	struct {
		struct NBDRequestData * sqe_next;        /*     0     8 */
	} entry;                                         /*     0     8 */
	NBDClient *                client;               /*     8     8 */
	uint8_t *                  data;                 /*    16     8 */
	_Bool                      complete;             /*    24     1 */

	/* size: 32, cachelines: 1, members: 4 */
	/* padding: 7 */
	/* last cacheline: 32 bytes */
};
struct nbd_option {
	uint64_t                   magic;                /*     0     8 */
	uint32_t                   option;               /*     8     4 */
	uint32_t                   length;               /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct nbd_opt_reply {
	uint64_t                   magic;                /*     0     8 */
	uint32_t                   option;               /*     8     4 */
	uint32_t                   type;                 /*    12     4 */
	uint32_t                   length;               /*    16     4 */

	/* size: 20, cachelines: 1, members: 4 */
	/* last cacheline: 20 bytes */
} __attribute__((__packed__));
struct aes_key_st {
	uint32_t                   rd_key[60];           /*     0   240 */
	/* --- cacheline 3 boundary (192 bytes) was 48 bytes ago --- */
	int                        rounds;               /*   240     4 */

	/* size: 244, cachelines: 4, members: 2 */
	/* last cacheline: 52 bytes */
};
struct QCryptoCipherBuiltinAESContext {
	AES_KEY                    enc;                  /*     0   244 */
	/* --- cacheline 3 boundary (192 bytes) was 52 bytes ago --- */
	AES_KEY                    dec;                  /*   244   244 */

	/* size: 488, cachelines: 8, members: 2 */
	/* last cacheline: 40 bytes */
};
struct QCryptoCipherBuiltinAES {
	QCryptoCipherBuiltinAESContext key;              /*     0   488 */
	/* --- cacheline 7 boundary (448 bytes) was 40 bytes ago --- */
	QCryptoCipherBuiltinAESContext key_tweak;        /*   488   488 */
	/* --- cacheline 15 boundary (960 bytes) was 16 bytes ago --- */
	uint8_t                    iv[16];               /*   976    16 */

	/* size: 992, cachelines: 16, members: 3 */
	/* last cacheline: 32 bytes */
};
struct QCryptoCipherBuiltinDESRFB {
	uint8_t *                  key;                  /*     0     8 */
	size_t                     nkey;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct QCryptoCipherBuiltin {
	union {
		QCryptoCipherBuiltinAES aes;             /*     0   992 */
		QCryptoCipherBuiltinDESRFB desrfb;       /*     0    16 */
	} state;                                         /*     0   992 */
	/* --- cacheline 15 boundary (960 bytes) was 32 bytes ago --- */
	size_t                     blocksize;            /*   992     8 */
	void                       (*free)(QCryptoCipher *); /*  1000     8 */
	int                        (*setiv)(QCryptoCipher *, const uint8_t  *, size_t, Error * *); /*  1008     8 */
	int                        (*encrypt)(QCryptoCipher *, const void  *, void *, size_t, Error * *); /*  1016     8 */
	/* --- cacheline 16 boundary (1024 bytes) --- */
	int                        (*decrypt)(QCryptoCipher *, const void  *, void *, size_t, Error * *); /*  1024     8 */

	/* size: 1032, cachelines: 17, members: 6 */
	/* last cacheline: 8 bytes */
};
struct QCryptoTLSCredsAnon {
	QCryptoTLSCreds            parent_obj;           /*     0    64 */

	/* size: 64, cachelines: 1, members: 1 */
};
struct QCryptoTLSCredsX509 {
	QCryptoTLSCreds            parent_obj;           /*     0    64 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      sanityCheck;          /*    64     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     passwordid;           /*    72     8 */

	/* size: 80, cachelines: 2, members: 3 */
	/* sum members: 73, holes: 1, sum holes: 7 */
	/* last cacheline: 16 bytes */
};
struct QCryptoSecret {
	Object                     parent_obj;           /*     0    40 */
	uint8_t *                  rawdata;              /*    40     8 */
	size_t                     rawlen;               /*    48     8 */
	QCryptoSecretFormat        format;               /*    56     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     data;                 /*    64     8 */
	char *                     file;                 /*    72     8 */
	char *                     keyid;                /*    80     8 */
	char *                     iv;                   /*    88     8 */

	/* size: 96, cachelines: 2, members: 8 */
	/* sum members: 92, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct rusage {
	struct timeval             ru_utime;             /*     0    16 */
	struct timeval             ru_stime;             /*    16    16 */
	union {
		long int           ru_maxrss;            /*    32     8 */
		__syscall_slong_t  __ru_maxrss_word;     /*    32     8 */
	};                                               /*    32     8 */
	union {
		long int           ru_ixrss;             /*    40     8 */
		__syscall_slong_t  __ru_ixrss_word;      /*    40     8 */
	};                                               /*    40     8 */
	union {
		long int           ru_idrss;             /*    48     8 */
		__syscall_slong_t  __ru_idrss_word;      /*    48     8 */
	};                                               /*    48     8 */
	union {
		long int           ru_isrss;             /*    56     8 */
		__syscall_slong_t  __ru_isrss_word;      /*    56     8 */
	};                                               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	union {
		long int           ru_minflt;            /*    64     8 */
		__syscall_slong_t  __ru_minflt_word;     /*    64     8 */
	};                                               /*    64     8 */
	union {
		long int           ru_majflt;            /*    72     8 */
		__syscall_slong_t  __ru_majflt_word;     /*    72     8 */
	};                                               /*    72     8 */
	union {
		long int           ru_nswap;             /*    80     8 */
		__syscall_slong_t  __ru_nswap_word;      /*    80     8 */
	};                                               /*    80     8 */
	union {
		long int           ru_inblock;           /*    88     8 */
		__syscall_slong_t  __ru_inblock_word;    /*    88     8 */
	};                                               /*    88     8 */
	union {
		long int           ru_oublock;           /*    96     8 */
		__syscall_slong_t  __ru_oublock_word;    /*    96     8 */
	};                                               /*    96     8 */
	union {
		long int           ru_msgsnd;            /*   104     8 */
		__syscall_slong_t  __ru_msgsnd_word;     /*   104     8 */
	};                                               /*   104     8 */
	union {
		long int           ru_msgrcv;            /*   112     8 */
		__syscall_slong_t  __ru_msgrcv_word;     /*   112     8 */
	};                                               /*   112     8 */
	union {
		long int           ru_nsignals;          /*   120     8 */
		__syscall_slong_t  __ru_nsignals_word;   /*   120     8 */
	};                                               /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	union {
		long int           ru_nvcsw;             /*   128     8 */
		__syscall_slong_t  __ru_nvcsw_word;      /*   128     8 */
	};                                               /*   128     8 */
	union {
		long int           ru_nivcsw;            /*   136     8 */
		__syscall_slong_t  __ru_nivcsw_word;     /*   136     8 */
	};                                               /*   136     8 */

	/* size: 144, cachelines: 3, members: 16 */
	/* last cacheline: 16 bytes */
};
struct QCryptoIVGen {
	QCryptoIVGenDriver *       driver;               /*     0     8 */
	void *                     private;              /*     8     8 */
	QCryptoIVGenAlgorithm      algorithm;            /*    16     4 */
	QCryptoCipherAlgorithm     cipher;               /*    20     4 */
	QCryptoHashAlgorithm       hash;                 /*    24     4 */

	/* size: 32, cachelines: 1, members: 5 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct QCryptoIVGenDriver {
	int                        (*init)(QCryptoIVGen *, const uint8_t  *, size_t, Error * *); /*     0     8 */
	int                        (*calculate)(QCryptoIVGen *, uint64_t, uint8_t *, size_t, Error * *); /*     8     8 */
	void                       (*cleanup)(QCryptoIVGen *); /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct QCryptoIVGenESSIV {
	QCryptoCipher *            cipher;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct QCryptoBlock {
	QCryptoBlockFormat         format;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	const QCryptoBlockDriver  * driver;              /*     8     8 */
	void *                     opaque;               /*    16     8 */
	QCryptoCipher *            cipher;               /*    24     8 */
	QCryptoIVGen *             ivgen;                /*    32     8 */
	QCryptoHashAlgorithm       kdfhash;              /*    40     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     niv;                  /*    48     8 */
	uint64_t                   payload_offset;       /*    56     8 */

	/* size: 64, cachelines: 1, members: 8 */
	/* sum members: 56, holes: 2, sum holes: 8 */
};
struct QCryptoBlockDriver {
	int                        (*open)(QCryptoBlock *, QCryptoBlockOpenOptions *, QCryptoBlockReadFunc, void *, unsigned int, Error * *); /*     0     8 */
	int                        (*create)(QCryptoBlock *, QCryptoBlockCreateOptions *, QCryptoBlockInitFunc, QCryptoBlockWriteFunc, void *, Error * *); /*     8     8 */
	int                        (*get_info)(QCryptoBlock *, QCryptoBlockInfo *, Error * *); /*    16     8 */
	void                       (*cleanup)(QCryptoBlock *); /*    24     8 */
	int                        (*encrypt)(QCryptoBlock *, uint64_t, uint8_t *, size_t, Error * *); /*    32     8 */
	int                        (*decrypt)(QCryptoBlock *, uint64_t, uint8_t *, size_t, Error * *); /*    40     8 */
	_Bool                      (*has_format)(const uint8_t  *, size_t); /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* last cacheline: 56 bytes */
};
struct QCryptoBlockLUKS {
	QCryptoBlockLUKSHeader     header;               /*     0   592 */
	/* --- cacheline 9 boundary (576 bytes) was 16 bytes ago --- */
	QCryptoCipherAlgorithm     cipher_alg;           /*   592     4 */
	QCryptoCipherMode          cipher_mode;          /*   596     4 */
	QCryptoIVGenAlgorithm      ivgen_alg;            /*   600     4 */
	QCryptoHashAlgorithm       ivgen_hash_alg;       /*   604     4 */
	QCryptoHashAlgorithm       hash_alg;             /*   608     4 */

	/* size: 612, cachelines: 10, members: 6 */
	/* last cacheline: 36 bytes */
};
struct QCryptoBlockLUKSHeader {
	char                       magic[6];             /*     0     6 */
	uint16_t                   version;              /*     6     2 */
	char                       cipher_name[32];      /*     8    32 */
	char                       cipher_mode[32];      /*    40    32 */
	/* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
	char                       hash_spec[32];        /*    72    32 */
	uint32_t                   payload_offset;       /*   104     4 */
	uint32_t                   key_bytes;            /*   108     4 */
	uint8_t                    master_key_digest[20]; /*   112    20 */
	/* --- cacheline 2 boundary (128 bytes) was 4 bytes ago --- */
	uint8_t                    master_key_salt[32];  /*   132    32 */
	uint32_t                   master_key_iterations; /*   164     4 */
	uint8_t                    uuid[40];             /*   168    40 */
	/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */
	QCryptoBlockLUKSKeySlot    key_slots[8];         /*   208   384 */

	/* size: 592, cachelines: 10, members: 12 */
	/* last cacheline: 16 bytes */
};
struct QCryptoBlockLUKSKeySlot {
	uint32_t                   active;               /*     0     4 */
	uint32_t                   iterations;           /*     4     4 */
	uint8_t                    salt[32];             /*     8    32 */
	uint32_t                   key_offset;           /*    40     4 */
	uint32_t                   stripes;              /*    44     4 */

	/* size: 48, cachelines: 1, members: 5 */
	/* last cacheline: 48 bytes */
};
struct QCryptoBlockLUKSCipherSizeMap {
	uint32_t                   key_bytes;            /*     0     4 */
	int                        id;                   /*     4     4 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct QCryptoBlockLUKSCipherNameMap {
	const char  *              name;                 /*     0     8 */
	const QCryptoBlockLUKSCipherSizeMap  * sizes;    /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct QIOChannelClass {
	ObjectClass                parent;               /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	ssize_t                    (*io_writev)(QIOChannel *, const struct iovec  *, size_t, int *, size_t, Error * *); /*    96     8 */
	ssize_t                    (*io_readv)(QIOChannel *, const struct iovec  *, size_t, int * *, size_t *, Error * *); /*   104     8 */
	int                        (*io_close)(QIOChannel *, Error * *); /*   112     8 */
	GSource *                  (*io_create_watch)(QIOChannel *, GIOCondition); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int                        (*io_set_blocking)(QIOChannel *, _Bool, Error * *); /*   128     8 */
	int                        (*io_shutdown)(QIOChannel *, QIOChannelShutdown, Error * *); /*   136     8 */
	void                       (*io_set_cork)(QIOChannel *, _Bool); /*   144     8 */
	void                       (*io_set_delay)(QIOChannel *, _Bool); /*   152     8 */
	off_t                      (*io_seek)(QIOChannel *, off_t, int, Error * *); /*   160     8 */

	/* size: 168, cachelines: 3, members: 10 */
	/* last cacheline: 40 bytes */
};
struct QIOChannelYieldData {
	QIOChannel *               ioc;                  /*     0     8 */
	Coroutine *                co;                   /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct QIOChannelBufferSource {
	GSource                    parent;               /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	QIOChannelBuffer *         bioc;                 /*    96     8 */
	GIOCondition               condition;            /*   104     4 */

	/* size: 112, cachelines: 2, members: 3 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct QIOChannelSocketDGramWorkerData {
	SocketAddress *            localAddr;            /*     0     8 */
	SocketAddress *            remoteAddr;           /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct QIOChannelFDSource {
	GSource                    parent;               /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	GPollFD                    fd;                   /*    96     8 */
	QIOChannel *               ioc;                  /*   104     8 */
	GIOCondition               condition;            /*   112     4 */

	/* size: 120, cachelines: 2, members: 4 */
	/* padding: 4 */
	/* last cacheline: 56 bytes */
};
struct QIOChannelFDPairSource {
	GSource                    parent;               /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	GPollFD                    fdread;               /*    96     8 */
	GPollFD                    fdwrite;              /*   104     8 */
	QIOChannel *               ioc;                  /*   112     8 */
	GIOCondition               condition;            /*   120     4 */

	/* size: 128, cachelines: 2, members: 5 */
	/* padding: 4 */
};
struct QIOChannelWebsockHeader {
	unsigned char              b0;                   /*     0     1 */
	unsigned char              b1;                   /*     1     1 */
	union {
		struct {
			uint16_t   l16;                  /*     2     2 */
			QIOChannelWebsockMask m16;       /*     4     4 */
		} __attribute__((__packed__)) s16;       /*     2     6 */
		struct {
			uint64_t   l64;                  /*     2     8 */
			QIOChannelWebsockMask m64;       /*    10     4 */
		} __attribute__((__packed__)) s64;       /*     2    12 */
		QIOChannelWebsockMask m;                 /*     2     4 */
	} u;                                             /*     2    12 */

	/* size: 14, cachelines: 1, members: 3 */
	/* last cacheline: 14 bytes */
} __attribute__((__packed__));
struct QIOChannelWebsockSource {
	GSource                    parent;               /*     0    96 */
	/* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
	QIOChannelWebsock *        wioc;                 /*    96     8 */
	GIOCondition               condition;            /*   104     4 */

	/* size: 112, cachelines: 2, members: 3 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct QIOTask {
	Object *                   source;               /*     0     8 */
	QIOTaskFunc                func;                 /*     8     8 */
	gpointer                   opaque;               /*    16     8 */
	GDestroyNotify             destroy;              /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* last cacheline: 32 bytes */
};
struct QIOTaskThreadData {
	QIOTask *                  task;                 /*     0     8 */
	QIOTaskWorker              worker;               /*     8     8 */
	gpointer                   opaque;               /*    16     8 */
	GDestroyNotify             destroy;              /*    24     8 */
	Error *                    err;                  /*    32     8 */
	int                        ret;                  /*    40     4 */

	/* size: 48, cachelines: 1, members: 6 */
	/* padding: 4 */
	/* last cacheline: 48 bytes */
};
struct anyList {
	anyList *                  next;                 /*     0     8 */
	QObject *                  value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct boolList {
	boolList *                 next;                 /*     0     8 */
	_Bool                      value;                /*     8     1 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct int16List {
	int16List *                next;                 /*     0     8 */
	int16_t                    value;                /*     8     2 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 6 */
	/* last cacheline: 16 bytes */
};
struct int32List {
	int32List *                next;                 /*     0     8 */
	int32_t                    value;                /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct int64List {
	int64List *                next;                 /*     0     8 */
	int64_t                    value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct int8List {
	int8List *                 next;                 /*     0     8 */
	int8_t                     value;                /*     8     1 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct numberList {
	numberList *               next;                 /*     0     8 */
	double                     value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct sizeList {
	sizeList *                 next;                 /*     0     8 */
	uint64_t                   value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct uint64List {
	uint64List *               next;                 /*     0     8 */
	uint64_t                   value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct uint8List {
	uint8List *                next;                 /*     0     8 */
	uint8_t                    value;                /*     8     1 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct BlockDeviceMapEntry {
	int64_t                    start;                /*     0     8 */
	int64_t                    length;               /*     8     8 */
	int64_t                    depth;                /*    16     8 */
	_Bool                      zero;                 /*    24     1 */
	_Bool                      data;                 /*    25     1 */
	_Bool                      has_offset;           /*    26     1 */

	/* XXX 5 bytes hole, try to pack */

	int64_t                    offset;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 7 */
	/* sum members: 35, holes: 1, sum holes: 5 */
	/* last cacheline: 40 bytes */
};
struct DummyForceArrays {
	X86CPUFeatureWordInfoList * unused;              /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct ImageCheck {
	char *                     filename;             /*     0     8 */
	char *                     format;               /*     8     8 */
	int64_t                    check_errors;         /*    16     8 */
	_Bool                      has_image_end_offset; /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    image_end_offset;     /*    32     8 */
	_Bool                      has_corruptions;      /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    corruptions;          /*    48     8 */
	_Bool                      has_leaks;            /*    56     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 1 boundary (64 bytes) --- */
	int64_t                    leaks;                /*    64     8 */
	_Bool                      has_corruptions_fixed; /*    72     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    corruptions_fixed;    /*    80     8 */
	_Bool                      has_leaks_fixed;      /*    88     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    leaks_fixed;          /*    96     8 */
	_Bool                      has_total_clusters;   /*   104     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    total_clusters;       /*   112     8 */
	_Bool                      has_allocated_clusters; /*   120     1 */

	/* XXX 7 bytes hole, try to pack */

	/* --- cacheline 2 boundary (128 bytes) --- */
	int64_t                    allocated_clusters;   /*   128     8 */
	_Bool                      has_fragmented_clusters; /*   136     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    fragmented_clusters;  /*   144     8 */
	_Bool                      has_compressed_clusters; /*   152     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    compressed_clusters;  /*   160     8 */

	/* size: 168, cachelines: 3, members: 21 */
	/* sum members: 105, holes: 9, sum holes: 63 */
	/* last cacheline: 40 bytes */
};
struct MapEntry {
	int64_t                    start;                /*     0     8 */
	int64_t                    length;               /*     8     8 */
	_Bool                      data;                 /*    16     1 */
	_Bool                      zero;                 /*    17     1 */

	/* XXX 6 bytes hole, try to pack */

	int64_t                    depth;                /*    24     8 */
	_Bool                      has_offset;           /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    offset;               /*    40     8 */
	_Bool                      has_filename;         /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     filename;             /*    56     8 */

	/* size: 64, cachelines: 1, members: 9 */
	/* sum members: 44, holes: 3, sum holes: 20 */
};
struct QCryptoBlockInfoBase {
	QCryptoBlockFormat         format;               /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct QCryptoBlockOptionsBase {
	QCryptoBlockFormat         format;               /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct SchemaInfo {
	char *                     name;                 /*     0     8 */
	SchemaMetaType             meta_type;            /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	union {
		SchemaInfoBuiltin  builtin;              /*    16     4 */
		SchemaInfoEnum     q_enum;               /*    16     8 */
		SchemaInfoArray    array;                /*    16     8 */
		SchemaInfoObject   object;               /*    16    40 */
		SchemaInfoAlternate alternate;           /*    16     8 */
		SchemaInfoCommand  command;              /*    16    16 */
		SchemaInfoEvent    event;                /*    16     8 */
	} u;                                             /*    16    40 */

	/* size: 56, cachelines: 1, members: 3 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct SchemaInfoAlternate {
	SchemaInfoAlternateMemberList * members;         /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct SchemaInfoAlternateMember {
	char *                     type;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct SchemaInfoAlternateMemberList {
	SchemaInfoAlternateMemberList * next;            /*     0     8 */
	SchemaInfoAlternateMember * value;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct SchemaInfoArray {
	char *                     element_type;         /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct SchemaInfoBuiltin {
	JSONType                   json_type;            /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct SchemaInfoCommand {
	char *                     arg_type;             /*     0     8 */
	char *                     ret_type;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct SchemaInfoEnum {
	strList *                  values;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct SchemaInfoEvent {
	char *                     arg_type;             /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct SchemaInfoList {
	SchemaInfoList *           next;                 /*     0     8 */
	SchemaInfo *               value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct SchemaInfoObject {
	SchemaInfoObjectMemberList * members;            /*     0     8 */
	_Bool                      has_tag;              /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     tag;                  /*    16     8 */
	_Bool                      has_variants;         /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	SchemaInfoObjectVariantList * variants;          /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 26, holes: 2, sum holes: 14 */
	/* last cacheline: 40 bytes */
};
struct SchemaInfoObjectMember {
	char *                     name;                 /*     0     8 */
	char *                     type;                 /*     8     8 */
	_Bool                      has_q_default;        /*    16     1 */

	/* XXX 7 bytes hole, try to pack */

	QObject *                  q_default;            /*    24     8 */

	/* size: 32, cachelines: 1, members: 4 */
	/* sum members: 25, holes: 1, sum holes: 7 */
	/* last cacheline: 32 bytes */
};
struct SchemaInfoObjectMemberList {
	SchemaInfoObjectMemberList * next;               /*     0     8 */
	SchemaInfoObjectMember *   value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct SchemaInfoObjectVariant {
	char *                     q_case;               /*     0     8 */
	char *                     type;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct SchemaInfoObjectVariantList {
	SchemaInfoObjectVariantList * next;              /*     0     8 */
	SchemaInfoObjectVariant *  value;                /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct SpiceBasicInfo {
	char *                     host;                 /*     0     8 */
	char *                     port;                 /*     8     8 */
	NetworkAddressFamily       family;               /*    16     4 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 24 bytes */
};
struct SpiceServerInfo {
	char *                     host;                 /*     0     8 */
	char *                     port;                 /*     8     8 */
	NetworkAddressFamily       family;               /*    16     4 */
	_Bool                      has_auth;             /*    20     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     auth;                 /*    24     8 */

	/* size: 32, cachelines: 1, members: 5 */
	/* sum members: 29, holes: 1, sum holes: 3 */
	/* last cacheline: 32 bytes */
};
struct q_obj_ACPI_DEVICE_OST_arg {
	ACPIOSTInfo *              info;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_BALLOON_CHANGE_arg {
	int64_t                    actual;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_BLOCK_IMAGE_CORRUPTED_arg {
	char *                     device;               /*     0     8 */
	_Bool                      has_node_name;        /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     node_name;            /*    16     8 */
	char *                     msg;                  /*    24     8 */
	_Bool                      has_offset;           /*    32     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    offset;               /*    40     8 */
	_Bool                      has_size;             /*    48     1 */

	/* XXX 7 bytes hole, try to pack */

	int64_t                    size;                 /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	_Bool                      fatal;                /*    64     1 */

	/* size: 72, cachelines: 2, members: 9 */
	/* sum members: 44, holes: 3, sum holes: 21 */
	/* padding: 7 */
	/* last cacheline: 8 bytes */
};
struct q_obj_BLOCK_IO_ERROR_arg {
	char *                     device;               /*     0     8 */
	char *                     node_name;            /*     8     8 */
	IoOperationType            operation;            /*    16     4 */
	BlockErrorAction           action;               /*    20     4 */
	_Bool                      has_nospace;          /*    24     1 */
	_Bool                      nospace;              /*    25     1 */

	/* XXX 6 bytes hole, try to pack */

	char *                     reason;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 7 */
	/* sum members: 34, holes: 1, sum holes: 6 */
	/* last cacheline: 40 bytes */
};
struct q_obj_BLOCK_JOB_CANCELLED_arg {
	BlockJobType               type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	int64_t                    len;                  /*    16     8 */
	int64_t                    offset;               /*    24     8 */
	int64_t                    speed;                /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct q_obj_BLOCK_JOB_COMPLETED_arg {
	BlockJobType               type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	int64_t                    len;                  /*    16     8 */
	int64_t                    offset;               /*    24     8 */
	int64_t                    speed;                /*    32     8 */
	_Bool                      has_error;            /*    40     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     error;                /*    48     8 */

	/* size: 56, cachelines: 1, members: 7 */
	/* sum members: 45, holes: 2, sum holes: 11 */
	/* last cacheline: 56 bytes */
};
struct q_obj_BLOCK_JOB_ERROR_arg {
	char *                     device;               /*     0     8 */
	IoOperationType            operation;            /*     8     4 */
	BlockErrorAction           action;               /*    12     4 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct q_obj_BLOCK_JOB_READY_arg {
	BlockJobType               type;                 /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	int64_t                    len;                  /*    16     8 */
	int64_t                    offset;               /*    24     8 */
	int64_t                    speed;                /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct q_obj_BLOCK_WRITE_THRESHOLD_arg {
	char *                     node_name;            /*     0     8 */
	uint64_t                   amount_exceeded;      /*     8     8 */
	uint64_t                   write_threshold;      /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct q_obj_BlockdevOptions_base {
	BlockdevDriver             driver;               /*     0     4 */
	_Bool                      has_node_name;        /*     4     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     node_name;            /*     8     8 */
	_Bool                      has_discard;          /*    16     1 */

	/* XXX 3 bytes hole, try to pack */

	BlockdevDiscardOptions     discard;              /*    20     4 */
	_Bool                      has_cache;            /*    24     1 */

	/* XXX 7 bytes hole, try to pack */

	BlockdevCacheOptions *     cache;                /*    32     8 */
	_Bool                      has_read_only;        /*    40     1 */
	_Bool                      read_only;            /*    41     1 */
	_Bool                      has_detect_zeroes;    /*    42     1 */

	/* XXX 1 byte hole, try to pack */

	BlockdevDetectZeroesOptions detect_zeroes;       /*    44     4 */

	/* size: 48, cachelines: 1, members: 11 */
	/* sum members: 34, holes: 4, sum holes: 14 */
	/* last cacheline: 48 bytes */
};
struct q_obj_CpuInfo_base {
	int64_t                    CPU;                  /*     0     8 */
	_Bool                      current;              /*     8     1 */
	_Bool                      halted;               /*     9     1 */

	/* XXX 6 bytes hole, try to pack */

	char *                     qom_path;             /*    16     8 */
	int64_t                    thread_id;            /*    24     8 */
	CpuInfoArch                arch;                 /*    32     4 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 30, holes: 1, sum holes: 6 */
	/* padding: 4 */
	/* last cacheline: 40 bytes */
};
struct q_obj_DEVICE_DELETED_arg {
	_Bool                      has_device;           /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     device;               /*     8     8 */
	char *                     path;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct q_obj_DEVICE_TRAY_MOVED_arg {
	char *                     device;               /*     0     8 */
	char *                     id;                   /*     8     8 */
	_Bool                      tray_open;            /*    16     1 */

	/* size: 24, cachelines: 1, members: 3 */
	/* padding: 7 */
	/* last cacheline: 24 bytes */
};
struct q_obj_DUMP_COMPLETED_arg {
	DumpQueryResult *          result;               /*     0     8 */
	_Bool                      has_error;            /*     8     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     error;                /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct q_obj_GUEST_PANICKED_arg {
	GuestPanicAction           action;               /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct q_obj_GlusterServer_base {
	GlusterTransport           type;                 /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct q_obj_MEM_UNPLUG_ERROR_arg {
	char *                     device;               /*     0     8 */
	char *                     msg;                  /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_MIGRATION_arg {
	MigrationStatus            status;               /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct q_obj_MIGRATION_PASS_arg {
	int64_t                    pass;                 /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_NIC_RX_FILTER_CHANGED_arg {
	_Bool                      has_name;             /*     0     1 */

	/* XXX 7 bytes hole, try to pack */

	char *                     name;                 /*     8     8 */
	char *                     path;                 /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 17, holes: 1, sum holes: 7 */
	/* last cacheline: 24 bytes */
};
struct q_obj_Netdev_base {
	char *                     id;                   /*     0     8 */
	NetClientDriver            type;                 /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct q_obj_QUORUM_FAILURE_arg {
	char *                     reference;            /*     0     8 */
	int64_t                    sector_num;           /*     8     8 */
	int64_t                    sectors_count;        /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct q_obj_QUORUM_REPORT_BAD_arg {
	QuorumOpType               type;                 /*     0     4 */
	_Bool                      has_error;            /*     4     1 */

	/* XXX 3 bytes hole, try to pack */

	char *                     error;                /*     8     8 */
	char *                     node_name;            /*    16     8 */
	int64_t                    sector_num;           /*    24     8 */
	int64_t                    sectors_count;        /*    32     8 */

	/* size: 40, cachelines: 1, members: 6 */
	/* sum members: 37, holes: 1, sum holes: 3 */
	/* last cacheline: 40 bytes */
};
struct q_obj_RTC_CHANGE_arg {
	int64_t                    offset;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct q_obj_SPICE_CONNECTED_arg {
	SpiceBasicInfo *           server;               /*     0     8 */
	SpiceBasicInfo *           client;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_SPICE_DISCONNECTED_arg {
	SpiceBasicInfo *           server;               /*     0     8 */
	SpiceBasicInfo *           client;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_SPICE_INITIALIZED_arg {
	SpiceServerInfo *          server;               /*     0     8 */
	SpiceChannel *             client;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_SchemaInfo_base {
	char *                     name;                 /*     0     8 */
	SchemaMetaType             meta_type;            /*     8     4 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 4 */
	/* last cacheline: 16 bytes */
};
struct q_obj_VNC_CONNECTED_arg {
	VncServerInfo *            server;               /*     0     8 */
	VncBasicInfo *             client;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_VNC_DISCONNECTED_arg {
	VncServerInfo *            server;               /*     0     8 */
	VncClientInfo *            client;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_VNC_INITIALIZED_arg {
	VncServerInfo *            server;               /*     0     8 */
	VncClientInfo *            client;               /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_VSERPORT_CHANGE_arg {
	char *                     id;                   /*     0     8 */
	_Bool                      open;                 /*     8     1 */

	/* size: 16, cachelines: 1, members: 2 */
	/* padding: 7 */
	/* last cacheline: 16 bytes */
};
struct q_obj_WATCHDOG_arg {
	WatchdogExpirationAction   action;               /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct q_obj_device_add_arg {
	char *                     driver;               /*     0     8 */
	char *                     id;                   /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct q_obj_netdev_add_arg {
	char *                     type;                 /*     0     8 */
	char *                     id;                   /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct GenericList {
	struct GenericList *       next;                 /*     0     8 */
	char                       padding[];            /*     8     0 */

	/* size: 8, cachelines: 1, members: 2 */
	/* last cacheline: 8 bytes */
};
struct GenericAlternate {
	QType                      type;                 /*     0     4 */
	char                       padding[];            /*     4     0 */

	/* size: 4, cachelines: 1, members: 2 */
	/* last cacheline: 4 bytes */
};
struct Visitor {
	void                       (*start_struct)(Visitor *, const char  *, void * *, size_t, Error * *); /*     0     8 */
	void                       (*check_struct)(Visitor *, Error * *); /*     8     8 */
	void                       (*end_struct)(Visitor *, void * *); /*    16     8 */
	void                       (*start_list)(Visitor *, const char  *, GenericList * *, size_t, Error * *); /*    24     8 */
	GenericList *              (*next_list)(Visitor *, GenericList *, size_t); /*    32     8 */
	void                       (*end_list)(Visitor *, void * *); /*    40     8 */
	void                       (*start_alternate)(Visitor *, const char  *, GenericAlternate * *, size_t, _Bool, Error * *); /*    48     8 */
	void                       (*end_alternate)(Visitor *, void * *); /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	void                       (*type_int64)(Visitor *, const char  *, int64_t *, Error * *); /*    64     8 */
	void                       (*type_uint64)(Visitor *, const char  *, uint64_t *, Error * *); /*    72     8 */
	void                       (*type_size)(Visitor *, const char  *, uint64_t *, Error * *); /*    80     8 */
	void                       (*type_bool)(Visitor *, const char  *, _Bool *, Error * *); /*    88     8 */
	void                       (*type_str)(Visitor *, const char  *, char * *, Error * *); /*    96     8 */
	void                       (*type_number)(Visitor *, const char  *, double *, Error * *); /*   104     8 */
	void                       (*type_any)(Visitor *, const char  *, QObject * *, Error * *); /*   112     8 */
	void                       (*type_null)(Visitor *, const char  *, Error * *); /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	void                       (*optional)(Visitor *, const char  *, _Bool *); /*   128     8 */
	VisitorType                type;                 /*   136     4 */

	/* XXX 4 bytes hole, try to pack */

	void                       (*complete)(Visitor *, void *); /*   144     8 */
	void                       (*free)(Visitor *);   /*   152     8 */

	/* size: 160, cachelines: 3, members: 20 */
	/* sum members: 156, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
struct QapiDeallocVisitor {
	Visitor                    visitor;              /*     0   160 */

	/* size: 160, cachelines: 3, members: 1 */
	/* last cacheline: 32 bytes */
};
struct QObjectInputVisitor {
	Visitor                    visitor;              /*     0   160 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	QObject *                  root;                 /*   160     8 */
	struct {
		struct StackObject * slh_first;          /*   168     8 */
	} stack;                                         /*   168     8 */
	_Bool                      strict;               /*   176     1 */

	/* size: 184, cachelines: 3, members: 4 */
	/* padding: 7 */
	/* last cacheline: 56 bytes */
};
struct StackObject {
	QObject *                  obj;                  /*     0     8 */
	void *                     qapi;                 /*     8     8 */
	GHashTable *               h;                    /*    16     8 */
	const QListEntry  *        entry;                /*    24     8 */
	struct {
		struct StackObject * sle_next;           /*    32     8 */
	} node;                                          /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* last cacheline: 40 bytes */
};
struct QObjectOutputVisitor {
	Visitor                    visitor;              /*     0   160 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	struct {
		struct QStackEntry * slh_first;          /*   160     8 */
	} stack;                                         /*   160     8 */
	QObject *                  root;                 /*   168     8 */
	QObject * *                result;               /*   176     8 */

	/* size: 184, cachelines: 3, members: 4 */
	/* last cacheline: 56 bytes */
};
struct QStackEntry {
	QObject *                  value;                /*     0     8 */
	void *                     qapi;                 /*     8     8 */
	struct {
		struct QStackEntry * sle_next;           /*    16     8 */
	} node;                                          /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct QmpCommandList {
	struct QmpCommand *        tqh_first;            /*     0     8 */
	struct QmpCommand * *      tqh_last;             /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct StringInputVisitor {
	Visitor                    visitor;              /*     0   160 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	GList *                    ranges;               /*   160     8 */
	GList *                    cur_range;            /*   168     8 */
	int64_t                    cur;                  /*   176     8 */
	const char  *              string;               /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	void *                     list;                 /*   192     8 */

	/* size: 200, cachelines: 4, members: 6 */
	/* last cacheline: 8 bytes */
};
struct StringOutputVisitor {
	Visitor                    visitor;              /*     0   160 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	_Bool                      human;                /*   160     1 */

	/* XXX 7 bytes hole, try to pack */

	GString *                  string;               /*   168     8 */
	char * *                   result;               /*   176     8 */
	ListMode                   list_mode;            /*   184     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) --- */
	union {
		int64_t            s;                    /*   192     8 */
		uint64_t           u;                    /*   192     8 */
	} range_start;                                   /*   192     8 */
	union {
		int64_t            s;                    /*   200     8 */
		uint64_t           u;                    /*   200     8 */
	} range_end;                                     /*   200     8 */
	GList *                    ranges;               /*   208     8 */
	void *                     list;                 /*   216     8 */

	/* size: 224, cachelines: 4, members: 9 */
	/* sum members: 213, holes: 2, sum holes: 11 */
	/* last cacheline: 32 bytes */
};
struct OptsVisitor {
	Visitor                    visitor;              /*     0   160 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	const QemuOpts  *          opts_root;            /*   160     8 */
	unsigned int               depth;                /*   168     4 */

	/* XXX 4 bytes hole, try to pack */

	GHashTable *               unprocessed_opts;     /*   176     8 */
	ListMode                   list_mode;            /*   184     4 */

	/* XXX 4 bytes hole, try to pack */

	/* --- cacheline 3 boundary (192 bytes) --- */
	GQueue *                   repeated_opts;        /*   192     8 */
	union {
		int64_t            s;                    /*   200     8 */
		uint64_t           u;                    /*   200     8 */
	} range_next;                                    /*   200     8 */
	union {
		int64_t            s;                    /*   208     8 */
		uint64_t           u;                    /*   208     8 */
	} range_limit;                                   /*   208     8 */
	QemuOpt *                  fake_id_opt;          /*   216     8 */

	/* size: 224, cachelines: 4, members: 9 */
	/* sum members: 216, holes: 2, sum holes: 8 */
	/* last cacheline: 32 bytes */
};
struct QapiCloneVisitor {
	Visitor                    visitor;              /*     0   160 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	size_t                     depth;                /*   160     8 */

	/* size: 168, cachelines: 3, members: 2 */
	/* last cacheline: 40 bytes */
};
struct JSONParsingState {
	JSONMessageParser          parser;               /*     0    64 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	va_list *                  ap;                   /*    64     8 */
	QObject *                  result;               /*    72     8 */

	/* size: 80, cachelines: 2, members: 3 */
	/* last cacheline: 16 bytes */
};
struct ToJsonIterState {
	int                        indent;               /*     0     4 */
	int                        pretty;               /*     4     4 */
	int                        count;                /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	QString *                  str;                  /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct JSONToken {
	int                        type;                 /*     0     4 */
	int                        x;                    /*     4     4 */
	int                        y;                    /*     8     4 */
	char                       str[];                /*    12     0 */

	/* size: 12, cachelines: 1, members: 4 */
	/* last cacheline: 12 bytes */
};
struct JSONParserContext {
	Error *                    err;                  /*     0     8 */
	JSONToken *                current;              /*     8     8 */
	GQueue *                   buf;                  /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* last cacheline: 24 bytes */
};
struct TraceEventGroup {
	TraceEvent * *             events;               /*     0     8 */

	/* size: 8, cachelines: 1, members: 1 */
	/* last cacheline: 8 bytes */
};
struct sigfd_compat_info {
	sigset_t                   mask;                 /*     0   128 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	int                        fd;                   /*   128     4 */

	/* size: 136, cachelines: 3, members: 2 */
	/* padding: 4 */
	/* last cacheline: 8 bytes */
};
struct statfs {
	__fsword_t                 f_type;               /*     0     8 */
	__fsword_t                 f_bsize;              /*     8     8 */
	__fsblkcnt64_t             f_blocks;             /*    16     8 */
	__fsblkcnt64_t             f_bfree;              /*    24     8 */
	__fsblkcnt64_t             f_bavail;             /*    32     8 */
	__fsfilcnt64_t             f_files;              /*    40     8 */
	__fsfilcnt64_t             f_ffree;              /*    48     8 */
	__fsid_t                   f_fsid;               /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	__fsword_t                 f_namelen;            /*    64     8 */
	__fsword_t                 f_frsize;             /*    72     8 */
	__fsword_t                 f_flags;              /*    80     8 */
	__fsword_t                 f_spare[4];           /*    88    32 */

	/* size: 120, cachelines: 2, members: 12 */
	/* last cacheline: 56 bytes */
};
struct winsize {
	short unsigned int         ws_row;               /*     0     2 */
	short unsigned int         ws_col;               /*     2     2 */
	short unsigned int         ws_xpixel;            /*     4     2 */
	short unsigned int         ws_ypixel;            /*     6     2 */

	/* size: 8, cachelines: 1, members: 4 */
	/* last cacheline: 8 bytes */
};
union pthread_attr_t {
	char                       __size[56];         /*     0    56 */
	long int                   __align;            /*     0     8 */
};
union NotifierThreadData {
	void *                     ptr;                /*     0     8 */
	NotifierList               list;               /*     0     8 */
};
struct ModuleEntry {
	void                       (*init)(void);        /*     0     8 */
	struct {
		struct ModuleEntry * tqe_next;           /*     8     8 */
		struct ModuleEntry * * tqe_prev;         /*    16     8 */
	} node;                                          /*     8    16 */
	module_init_type           type;                 /*    24     4 */

	/* size: 32, cachelines: 1, members: 3 */
	/* padding: 4 */
	/* last cacheline: 32 bytes */
};
struct HBitmap {
	uint64_t                   size;                 /*     0     8 */
	uint64_t                   count;                /*     8     8 */
	int                        granularity;          /*    16     4 */

	/* XXX 4 bytes hole, try to pack */

	HBitmap *                  meta;                 /*    24     8 */
	long unsigned int *        levels[7];            /*    32    56 */
	/* --- cacheline 1 boundary (64 bytes) was 24 bytes ago --- */
	uint64_t                   sizes[7];             /*    88    56 */

	/* size: 144, cachelines: 3, members: 6 */
	/* sum members: 140, holes: 1, sum holes: 4 */
	/* last cacheline: 16 bytes */
};
struct Error {
	char *                     msg;                  /*     0     8 */
	ErrorClass                 err_class;            /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	const char  *              src;                  /*    16     8 */
	const char  *              func;                 /*    24     8 */
	int                        line;                 /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	GString *                  hint;                 /*    40     8 */

	/* size: 48, cachelines: 1, members: 6 */
	/* sum members: 40, holes: 2, sum holes: 8 */
	/* last cacheline: 48 bytes */
};
struct _GTimeVal {
	glong                      tv_sec;               /*     0     8 */
	glong                      tv_usec;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct ConfigWriteData {
	QemuOptsList *             list;                 /*     0     8 */
	FILE *                     fp;                   /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct ConnectState {
	int                        fd;                   /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	struct addrinfo *          addr_list;            /*     8     8 */
	struct addrinfo *          current_addr;         /*    16     8 */
	NonBlockingConnectHandler * callback;            /*    24     8 */
	void *                     opaque;               /*    32     8 */

	/* size: 40, cachelines: 1, members: 5 */
	/* sum members: 36, holes: 1, sum holes: 4 */
	/* last cacheline: 40 bytes */
};
struct OptsFromQDictState {
	QemuOpts *                 opts;                 /*     0     8 */
	Error * *                  errp;                 /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct CoSleepCB {
	QEMUTimer *                ts;                   /*     0     8 */
	Coroutine *                co;                   /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
struct sigaltstack {
	void *                     ss_sp;                /*     0     8 */
	int                        ss_flags;             /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	size_t                     ss_size;              /*    16     8 */

	/* size: 24, cachelines: 1, members: 3 */
	/* sum members: 20, holes: 1, sum holes: 4 */
	/* last cacheline: 24 bytes */
};
struct _libc_fpxreg {
	short unsigned int         significand[4];       /*     0     8 */
	short unsigned int         exponent;             /*     8     2 */
	short unsigned int         padding[3];           /*    10     6 */

	/* size: 16, cachelines: 1, members: 3 */
	/* last cacheline: 16 bytes */
};
struct _libc_xmmreg {
	__uint32_t                 element[4];           /*     0    16 */

	/* size: 16, cachelines: 1, members: 1 */
	/* last cacheline: 16 bytes */
};
struct _libc_fpstate {
	__uint16_t                 cwd;                  /*     0     2 */
	__uint16_t                 swd;                  /*     2     2 */
	__uint16_t                 ftw;                  /*     4     2 */
	__uint16_t                 fop;                  /*     6     2 */
	__uint64_t                 rip;                  /*     8     8 */
	__uint64_t                 rdp;                  /*    16     8 */
	__uint32_t                 mxcsr;                /*    24     4 */
	__uint32_t                 mxcr_mask;            /*    28     4 */
	struct _libc_fpxreg        _st[8];               /*    32   128 */
	/* --- cacheline 2 boundary (128 bytes) was 32 bytes ago --- */
	struct _libc_xmmreg        _xmm[16];             /*   160   256 */
	/* --- cacheline 6 boundary (384 bytes) was 32 bytes ago --- */
	__uint32_t                 padding[24];          /*   416    96 */

	/* size: 512, cachelines: 8, members: 11 */
};
struct ucontext {
	long unsigned int          uc_flags;             /*     0     8 */
	struct ucontext *          uc_link;              /*     8     8 */
	stack_t                    uc_stack;             /*    16    24 */
	mcontext_t                 uc_mcontext;          /*    40   256 */
	/* --- cacheline 4 boundary (256 bytes) was 40 bytes ago --- */
	__sigset_t                 uc_sigmask;           /*   296   128 */
	/* --- cacheline 6 boundary (384 bytes) was 40 bytes ago --- */
	struct _libc_fpstate       __fpregs_mem;         /*   424   512 */

	/* size: 936, cachelines: 15, members: 6 */
	/* last cacheline: 40 bytes */
};
union cc_arg {
	void *                     p;                  /*     0     8 */
	int                        i[2];               /*     0     8 */
};
struct QemuSpin {
	int                        value;                /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
struct qht_map {
	struct rcu_head            rcu;                  /*     0    16 */
	struct qht_bucket *        buckets;              /*    16     8 */
	size_t                     n_buckets;            /*    24     8 */
	size_t                     n_added_buckets;      /*    32     8 */
	size_t                     n_added_buckets_threshold; /*    40     8 */

	/* size: 48, cachelines: 1, members: 5 */
	/* last cacheline: 48 bytes */
};
struct qht_bucket {
	QemuSpin                   lock;                 /*     0     4 */
	QemuSeqLock                sequence;             /*     4     4 */
	uint32_t                   hashes[4];            /*     8    16 */
	void *                     pointers[4];          /*    24    32 */
	struct qht_bucket *        next;                 /*    56     8 */

	/* size: 64, cachelines: 1, members: 5 */
};
